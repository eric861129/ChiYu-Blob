<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>全部文章 on ChiYu Code Journey</title><link>/ChiYu-Blob/posts/</link><description>Recent content in 全部文章 on ChiYu Code Journey</description><generator>Hugo -- gohugo.io</generator><language>zh-TW</language><lastBuildDate>Wed, 17 Dec 2025 16:50:00 +0800</lastBuildDate><atom:link href="/ChiYu-Blob/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>【撰寫指南】Hugo 文章 Front Matter 參數詳解</title><link>/ChiYu-Blob/posts/hugo-front-matter-guide/</link><pubDate>Wed, 17 Dec 2025 16:50:00 +0800</pubDate><guid>/ChiYu-Blob/posts/hugo-front-matter-guide/</guid><description>這篇文章是為了快速查閱 Front Matter (文章開頭的設定區塊) 而建立的範本。
完整範本 (可以直接複製) +++ title = &amp;#34;文章標題&amp;#34; date = 2025-12-17T16:00:00+08:00 slug = &amp;#34;自訂文章網址-Slug&amp;#34; # 顯示於側邊欄日曆的日期 (通常與 date 相同) dates = [&amp;#34;2025-12-17&amp;#34;] # 標籤與系列 tags = [&amp;#34;Tag1&amp;#34;, &amp;#34;Tag2&amp;#34;] series = [&amp;#34;系列名稱&amp;#34;] categories = [&amp;#34;分類名稱&amp;#34;] # 系列文章排序 (數字越小越前面) weight = 10 # 手動指定上下篇 (選填，若不填則依時間自動排序) # 填寫對應文章的 Slug 或 檔名 (不含副檔名) prev_post_slug = &amp;#34;&amp;#34; next_post_slug = &amp;#34;&amp;#34; # 是否為草稿 (true 則不會被發布) draft = true +++ 參數詳細說明 基礎設定 title: 文章的主標題。 date: 發布日期。Hugo 會根據這個日期進行排序。 slug: 自定義網址的尾端。例如設為 my-post，文章網址就會是 .</description></item><item><title>想快速打造個人部落格？試試 HugoBlobTemplate，極簡、開源，讓你專注寫作！</title><link>/ChiYu-Blob/posts/%E6%83%B3%E5%BF%AB%E9%80%9F%E6%89%93%E9%80%A0%E5%80%8B%E4%BA%BA%E9%83%A8%E8%90%BD%E6%A0%BC%E8%A9%A6%E8%A9%A6-hugoblobtemplate%E6%A5%B5%E7%B0%A1%E9%96%8B%E6%BA%90%E8%AE%93%E4%BD%A0%E5%B0%88%E6%B3%A8%E5%AF%AB%E4%BD%9C/</link><pubDate>Wed, 11 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E6%83%B3%E5%BF%AB%E9%80%9F%E6%89%93%E9%80%A0%E5%80%8B%E4%BA%BA%E9%83%A8%E8%90%BD%E6%A0%BC%E8%A9%A6%E8%A9%A6-hugoblobtemplate%E6%A5%B5%E7%B0%A1%E9%96%8B%E6%BA%90%E8%AE%93%E4%BD%A0%E5%B0%88%E6%B3%A8%E5%AF%AB%E4%BD%9C/</guid><description>【文章最終整合版】 想快速打造個人部落格？試試 HugoBlobTemplate，極簡、開源，讓你專注寫作！ 你是不是也曾想過，要建立一個屬於自己的小天地，放些技術筆記、生活隨筆，或是作品集？但一想到要租主機、搞定複雜的後台設定、擔心網站速度，頭就開始痛了？
別擔心！今天就是要來跟你介紹一個我完成的開源專案：HugoBlobTemplate，它能讓你幾乎零成本、超快速地建立一個美觀又實用的個人部落格。
點我前往 HugoBlobTemplate 的 GitHub 專案頁面 這到底是什麼？適合誰用？ 簡單來說，HugoBlobTemplate 是一個基於 Hugo 這個靜態網站生成器所打造的「部落格模板」。
你可能聽過 WordPress，但 Hugo 不一樣。它不會動態去讀取資料庫，而是在你寫完文章後，直接「生成」一整個網站的 HTML 靜態檔案。這樣做有幾個超強的優點：
快！快到飛起！ 因為使用者瀏覽的都只是純粹的 HTML，沒有後端處理、沒有資料庫查詢，載入速度幾乎是瞬間完成。 安全！ 沒有後台登入頁面、沒有資料庫，自然就少了很多被攻擊的風險。 便宜（甚至免費）！ 你可以把生成好的網站檔案，輕鬆部署到像是 GitHub Pages、Netlify 或 Vercel 這些提供免費託管服務的平台上。 所以，HugoBlobTemplate 就是幫你把 Hugo 的環境都設定好，給你一個「開箱即用」的部落格樣式。它特別適合：
工程師/學生：想記錄技術筆記、學習心得，需要一個簡潔、支援程式碼高亮的平台。 文字創作者：不想被複雜的編輯器綁架，希望專注在內容本身。 任何人：想擁有一個「自己的」網站，不想付月費，也不想花大把時間在維護上。 HugoBlobTemplate 有哪些貼心的功能？ 這個專案雖然主打極簡，但在基礎功能上一點也不馬虎。我已經幫你內建了許多實用的功能：
內建亮色/暗色模式：自動偵測使用者系統的偏好設定，也可以讓訪客手動切換，非常貼心。 社群連結整合：想放你的 GitHub、LinkedIn 等連結？只要在設定檔裡填上你的帳號，就會自動出現在個人介紹區塊。 SEO 友善：專案已經幫你處理好基礎的搜尋引擎優化（SEO），讓你的內容更容易被 Google 等搜尋引擎找到。 響應式設計 (RWD)：無論你的訪客用的是電腦、平板還是手機，網站版面都能自動適應，提供最佳的閱讀體驗。 好！我想用！該如何開始？ 整個過程比你想像的還要簡單，大概可以分成以下幾步：
第 1 步：準備環境 (若想在本機預覽) 如果你想在自己的電腦上看到網站的即時變化，需要先安裝兩樣東西：
Git：用來抓取專案程式碼。 Hugo：用來產生網站的核心工具。（官方安裝說明 ） 第 2 步：把專案抓下來 打開你的終端機，輸入以下指令：
git clone https://github.</description></item><item><title>Day 4: 【工具篇 #2】程式碼的時光機：Git 與 GitHub 版本控制</title><link>/ChiYu-Blob/posts/2025ithomeironmanday4/</link><pubDate>Sat, 23 Aug 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday4/</guid><description>安安，我是 ChiYu！
昨天，我們扮演了「技師與軍火官」的角色，把我們的駕駛艙 (VS Code) 從毛胚屋打造成了精裝房，並備妥了所有核心的建材與燃料 (Python &amp;amp; Node.js)。
我們的開發環境已經準備就緒，但在我們正式動工、蓋起萬丈高樓之前，還有一件至關重要的事要做：我們需要為我們的建築工地，安裝一套最頂級的「安全監控系統」與「時光倒流機器」。
今天，我們就要來深入軟體開發中最最最重要的觀念——版本控制，並親手設定我們專案的「雲端保險庫」與「時光機總部」：Git 與 GitHub。
Part 1：核心觀念：什麼是「版本控制」？ 在開始操作前，我們先用白話文搞懂什麼是「版控 (版本控制)」。你可以把它想像成玩遊戲時的「存檔」機制。
你在寫報告時，是不是常常會這樣做：企劃書_v1.docx、企劃書_v2_改了標題.docx、企劃書_最終版.docx、企劃書_最終版真的啦.docx？這就是最原始、最土炮的「手動版本控制」。你害怕把東西改壞，所以存了一大堆備份，最後連自己都搞不清楚哪個才是最新的。
而「版本控制系統」就是一個專業、自動化的工具，來幫你優雅地做這件事。它的好處有：
追蹤歷史紀錄：系統會幫你記錄每一次的「存檔」，你可以清楚看到何時、何人、修改了什麼內容。 隨時回到過去：如果不小心把專案改爛了、功能寫壞了，你可以像讀取遊戲存檔一樣，輕鬆回到任何一個過去的版本。 方便多人協作：當很多人一起開發同一個專案時，版控系統能聰明地幫大家整合程式碼，避免互相覆蓋的慘劇。 鼓勵大膽實驗：這是最棒的一點！它讓你可以隨時開一個「平行時空」，在裡面隨便亂搞、嘗試新功能，而完全不用擔心會把主線劇情（主要程式碼）搞砸。 Part 2：釐清工具：Git 與 GitHub 的關係 很多新手會把這兩個搞混，我們用一個簡單的比喻來拆解：
Git - 你的程式碼時光機 它是什麼：Git 是一個「版本控制系統」，是你電腦裡的工具，用來建立「存檔點 (commit)」。 Git 官網：https://git-scm.com/ (建議先下載安裝) GitHub - 你的雲端程式碼基地 它是什麼：GitHub 是一個「提供 Git 託管服務的網站平台」。如果說 Git 是 Word 軟體，那 GitHub 就是 Google Docs。你可以在 GitHub 上建立一個專案倉庫 (Repository)，然後把你用 Git 管理的本地專案，同步一份到這個雲端倉庫裡。 GitHub 官網：https://github.com/ Part 3：最重要的觀念：分支 (Branching) - 你的平行時空 在我們建立倉庫之前，你必須先理解「分支 (Branching)」這個專業開發中最重要的概念。
你可以把你的專案想像成一部電影的「主線劇情」，這條主線就是所謂的 main 分支。main 分支上的程式碼，永遠都必須是最穩定、可以正常運作的版本。</description></item><item><title>讓部落格成為你的形狀：Hugo 個人化設定終極指南</title><link>/ChiYu-Blob/posts/%E8%AE%93%E9%83%A8%E8%90%BD%E6%A0%BC%E6%88%90%E7%82%BA%E4%BD%A0%E7%9A%84%E5%BD%A2%E7%8B%80hugo-%E5%80%8B%E4%BA%BA%E5%8C%96%E8%A8%AD%E5%AE%9A%E7%B5%82%E6%A5%B5%E6%8C%87%E5%8D%97/</link><pubDate>Wed, 11 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E8%AE%93%E9%83%A8%E8%90%BD%E6%A0%BC%E6%88%90%E7%82%BA%E4%BD%A0%E7%9A%84%E5%BD%A2%E7%8B%80hugo-%E5%80%8B%E4%BA%BA%E5%8C%96%E8%A8%AD%E5%AE%9A%E7%B5%82%E6%A5%B5%E6%8C%87%E5%8D%97/</guid><description>讓部落格成為你的形狀：Hugo 個人化設定終極指南 當你成功部署了這個部落格模板，恭喜你完成了第一步！但真正的樂趣現在才開始：將這個公版的部落格，徹底改造成專屬於你的樣子。
這篇文章是一份完整的個人化指南，將帶你從裡到外，一步步設定與調整，打造出獨一無二的個人網站。
第一站：核心設定 (hugo.toml) hugo.toml 是你部落格的「大腦」與「指揮中心」，幾乎所有基本資訊都在這裡設定。
1. 網站基本資訊 首先，打開 hugo.toml 檔案，找到並修改以下幾個關鍵欄位：
baseURL: (最重要!) 這裡必須換成你未來部署網站的最終網址。如果是使用 GitHub Pages，通常會是 https://&amp;lt;你的GitHub帳號&amp;gt;.github.io/&amp;lt;你的專案名稱&amp;gt;/。 title: 你部落格的主要名稱，會顯示在瀏覽器分頁和網站標頭上。 [params] description: 網站的副標題或描述，會顯示在首頁的大標題下方。 [params.author] name: 你的名字或暱稱。 2. 你的社交連結 在 hugo.toml 中，有一個 [params.social] 區塊，你可以在這裡新增、刪除或修改你的社群媒體連結。
# hugo.toml [params.social] GitHub = &amp;#34;https://github.com/eric861129&amp;#34; LinkedIn = &amp;#34;https://www.linkedin.com/in/chiyu-huang/&amp;#34; Threads = &amp;#34;https://www.threads.com/@chiyuisme&amp;#34; # 你也可以新增自己的，例如： # Twitter = &amp;#34;https://twitter.com/your_account&amp;#34; 3. 啟用你自己的留言區 (Giscus) 這個部落格模板整合了 Giscus 留言系統。為了讓讀者能在你的部落格留言，而不是在我的模板專案上，你必須進行設定：
跟隨 Giscus 官網的教學，為你自己的 GitHub 專案啟用 Giscus。 將 hugo.toml 檔案中 [params.giscus] 的設定值，換成你在 Giscus 官網上取得的你自己的設定。 這些設定會被 layouts/_default/baseof.</description></item><item><title>Day 5: 【工具篇 #3】終端機裡的魔法：什麼是 Vibe Coding 與 Gemini CLI？</title><link>/ChiYu-Blob/posts/2025ithomeironmanday5/</link><pubDate>Sun, 24 Aug 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday5/</guid><description>安安，我是 ChiYu！
昨天，我們完成了技師的工作，為我們的專案蓋好了雲端機棚 (GitHub)，也把駕駛艙 (VS Code) 裝潢得舒適又專業。硬體設施全部到位，現在，是時候為我們的專案注入真正的「靈魂」了。
今天，我們將迎來本系列第一個令人心跳加速的轉捩點。我們不只要安裝「引擎」，我們還要學會詠唱「魔法的咒語」，真正地與 AI 對話，把我們的意念灌注到終端機之中！準備好迎接你的「魔法覺醒」了嗎？
Part 1：到底什麼是「Vibe Coding」？ 最近你可能常常聽到 Vibe Coding 這個詞，但它到底是什麼意思？
它不是什麼艱深的技術或框架，而是一種徹底顛覆傳統的開發風格或心態。
這徹底顛覆了我們過去學習程式的模式。以前我們學的是機器的**「語法 (Syntax)」，現在我們學的是如何更精準地「表達意圖 (Intent)」**。你的中文能力，從未像此刻一樣，直接與你的生產力掛鉤。
這就像你從一個樂手，變成了一個指揮家。你不用親自演奏每個樂器，你只需要揮舞你的指揮法杖，告訴整個樂團（AI），這一段要「雄壯激昂」、那一段要「溫柔婉約」。你負責定義**「氛圍 (Vibe)」**，AI 負責實現它。
而我們今天要安裝的 Gemini CLI，就是我們的第一支客製化指揮法杖。
Part 2：我們的魔法法杖：Gemini CLI，你的開源 AI 代理人 CLI 的全名是 Command Line Interface (命令列介面)。你不用害怕這個詞，它指的就是我們在 VS Code 裡打開的那個黑黑的、看起來很像駭客電影的「終端機」視窗。
我們要介紹的 gemini-cli，根據 Google 官方的說法，它不只是一個工具，更是一個**「開源的 AI 代理人 (Open Source AI Agent)」**。這代表它是一個住在你終端機裡的智慧夥伴，可以幫你讀取檔案、存取網路、甚至與其他工具串接，來完成更複雜的任務。
官方參考資料 對 gemini-cli 有興趣的讀者，可以直接參考它的官方 GitHub 倉庫與 Google 官方部落格文章：
GitHub: https://github.com/google-gemini/gemini-cli Google Blog: https://blog.google/intl/zh-tw/products/cloud/gemini-cli-your-open-source-ai-agent/ Part 3：安裝與授權：法杖的鑄造與認主 好的，讓我們開始進行法杖的「鑄造與附魔」！
Step 1：前置作業 - 準備 Node.</description></item><item><title>搞懂設計模式到底是什麼？</title><link>/ChiYu-Blob/posts/%E6%90%9E%E6%87%82%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E9%BA%BC/</link><pubDate>Wed, 11 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E6%90%9E%E6%87%82%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E9%BA%BC/</guid><description>哈囉！最近我決定開始一個新的 Side Project，要來用比較輕鬆的方式跟大家分享一下什麼是「設計模式（Design Patterns）」。
等等先別跑！雖然聽起來很硬，但設計模式其實就是一些「前輩工程師們」留下來的解決問題的好方法。懂了這些，你的程式碼會變得更容易維護，更容易擴充，甚至看起來更專業！（聽起來是不是有點心動了？）
這篇先帶你入個門，我們會聊聊設計模式的概念、分類，最後也會簡單列出一些常見好用的模式，讓你一次搞懂設計模式到底在幹嘛。
🧐 所以，到底什麼是設計模式啊？ 簡單說，設計模式就像是程式設計師之間的「共通語言」。
你一定有過這種經驗：
「欸，我怎麼又寫出這種一團亂的程式碼？」 「這個功能之前不是做過了嗎？為什麼還要再寫一次？」 這時候，如果你腦袋裡裝著幾種設計模式，就像工具箱一樣，你就能更快速地解決這些問題。
設計模式其實就是經過無數開發者實踐後得出的好用解決方案，就像老前輩的私房武功，學起來絕對讓你的程式碼更整齊、更有架構，也比較不容易踩坑。
設計模式可以怎麼分？ 一般來說，設計模式分成三大類：
建立型模式（Creational Patterns）
重點在教你怎麼更聰明地「建立」物件，避免程式碼越寫越複雜。
結構型模式（Structural Patterns）
教你怎麼把物件組合在一起，像拼樂高一樣，輕鬆擴充或調整程式的架構。
行為型模式（Behavioral Patterns）
教你搞定物件之間複雜的「溝通與互動」，讓你的程式碼彼此合作起來更加順暢。
是不是聽起來越來越清楚了？接下來我們更進一步，列出每個分類下的常見模式，讓你一眼看懂設計模式家族有什麼好貨！
常見設計模式大集合 這邊先條列式介紹，未來我會用獨立的文章、一個一個講清楚：
🚀 建立型模式（Creational） 單例模式（Singleton） 工廠方法模式（Factory Method） 抽象工廠模式（Abstract Factory） 原型模式（Prototype） 建造者模式（Builder） 📌 特點： 這一類幫你搞定物件的建立，讓你不用一直煩惱物件從哪裡來，要怎麼產生之類的問題。
2. 結構型模式（Structural） 介面卡模式（Adapter） 橋接模式（Bridge） 組合模式（Composite） 裝飾者模式（Decorator） 外觀模式（Facade） 享元模式（Flyweight） 代理模式（Proxy） 📌 特點： 這些模式專門解決如何「拼裝」不同物件，讓你的程式更容易擴充、更有彈性。
想像成在玩樂高，一個一個小零件組裝起來，最後變成超酷的東西！
🚦 行為型模式（Behavioral） 責任鏈模式（Chain of Responsibility） 命令模式（Command） 解譯器模式（Interpreter） 迭代器模式（Iterator） 中介者模式（Mediator） 備忘錄模式（Memento） 觀察者模式（Observer） 狀態模式（State） 策略模式（Strategy） 模板方法模式（Template Method） 訪問者模式（Visitor） 📌 特點： 處理物件之間的「互動」。如果你常常覺得你的物件們關係很亂，溝通起來像在吵架，那這些模式就是你的救星！</description></item><item><title>Day 6: 【文件 #1】專案的靈魂：用 Gemini CLI 生成「專案章程」</title><link>/ChiYu-Blob/posts/2025ithomeironmanday6/</link><pubDate>Mon, 25 Aug 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday6/</guid><description>安安，我是 ChiYu！
經過了五天的「前置作業」，我們的駕駛艙 (VS Code)、引擎 (Python)、魔法法杖 (Gemini CLI) 全都準備就緒了。是不是已經手癢難耐，準備大展身手了？
別急！還記得我們的核心心法嗎？先有藍圖，再有魔法。
今天，我們就要正式啟動專案，打響「左手藍圖」的第一槍！我們將完全在 VS Code 終端機內，為我們的太空船，設定好最初也最重要的航行座標。我們要來產出整個專案中，位階最高、最重要的一份文件——專案章程 (Project Charter)。
Part 1：什麼是「專案章程」？它到底有多重要？ 「專案章程」…這名字聽起來好像很厲害、很嚴肅，但你別被它嚇到。
你可以把它想像成這個專案的「出生證明」或「身分證」。它用最精簡的方式，回答了幾個最根本的問題：我們是誰？我們要去哪裡？我們要做什麼？以及，我們「不做」什麼？
在團隊開發中，這份文件至關重要，因為它是：
建立共識的基石：專案最怕的就是「我以為我們是要做A，結果你做的是B」。專案章程是第一份讓所有人（老闆、PM、工程師）都點頭同意的文件，確保大家從第一天起，對專案的想像就是一致的。 正式啟動的號角：在企業裡，一份被簽核的專案章程，代表著這個專案被「正式授權」。對我們來說，完成這份文件，就像是為自己舉辦一個開工儀式，代表我們對這個專案的承諾，從此刻起，它不再只是個空想。 未來決策的北極星：開發過程中，我們肯定會冒出各種新點子。這時候，我們就可以拿出專案章程來檢視：「這個新點子，符合我們的『願景』和『範圍』嗎？」它能幫助我們抵抗「範圍潛變 (Scope Creep)」這個專案的無聲殺手，確保我們能聚焦在核心價值上。 總之，在一頭熱地栽進去開發前，先把這份文件定義清楚，就像開車前先在 Google Maps 設定好目的地。它就是我們後續所有文件的最高指導原則。
Part 2：實戰開始：在終端機中從無到有 接下來，就是見證奇蹟的時刻。我們將把腦中那個非常模糊的想法，透過與 Gemini CLI 的對話，直接在我們的專案中，生成一份專業文件。
魔法的基礎：什麼是提示工程 (Prompt Engineering)？ 在我們詠唱第一個咒語之前，我們先來學習「咒語的文法」。與 AI 溝通，是一門藝術，也是一門科學，這就是所謂的「提示工程 (Prompt Engineering)」。
你可以把它想像成你在對一個法力無邊的「許願精靈」下指令。
糟糕的許願：「我想要變有錢！」 -&amp;gt; 精靈可能會給你一張樂透彩券，或是讓你家地下冒出處理起來很麻煩的石油。 優秀的許願：「請在今天下午三點前，將一百萬新台幣，以合法的銀行轉帳方式，存入我指定的銀行帳戶。」 看到了嗎？一個好的 Prompt，就像一個好的許願，它清晰、具體、有邊界、有上下文。這能大幅降低 AI「理解錯誤」或「自由發揮」的機率。
根據業界的最佳實踐（例如 OpenAI 的官方文件），一個高品質的 Prompt 通常包含幾個關鍵要素，而這也正是我們接下來所有咒語的設計核心：
1. 角色扮演 (Role-playing)：為 AI 賦予專家身份 這是最重要，也最容易被忽略的一點。在指令的開頭，先告訴 AI 他「是誰」。這會讓模型進入一個特定的知識領域與思考模式，產出的內容會更專業、更貼近你的需求。
不好的指令: 幫我寫一個 Python 函式來驗證電子郵件。 好的指令: 你是一位資深的 Python 開發者，專長是後端開發與資料驗證。請幫我寫一個符合 RFC 5322 標準的 Python 函式來驗證電子郵件.</description></item><item><title>單例模式：只要一個就夠！</title><link>/ChiYu-Blob/posts/%E5%96%AE%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%8F%AA%E8%A6%81%E4%B8%80%E5%80%8B%E5%B0%B1%E5%A4%A0/</link><pubDate>Thu, 12 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E5%96%AE%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%8F%AA%E8%A6%81%E4%B8%80%E5%80%8B%E5%B0%B1%E5%A4%A0/</guid><description>在上一篇文章中，我們簡單認識了什麼是「設計模式」。這次，就讓我們從最經典的「單例模式（Singleton）」開始，看看它究竟能為開發帶來什麼幫助吧！
☕ 小故事：世界上只此一家 想像你開了一間只允許存在一個分店的咖啡廳，無論客人怎麼找，都只能到這家。單例模式的精神也差不多：確保整個應用程式裡只有同一個實例存在。
🤔 什麼情境適合用 Singleton？ 系統設定：確保設定檔只有一份，避免各模組各自讀取產生混亂。 日誌記錄：統一紀錄進入點，不會讓檔案四散。 資料庫連線：集中管理連線、節省資源。 接下來的範例將以「系統設定」為主角，用 C# 程式碼示範 Singleton 的實作。
💻 Singleton 類別 using System; /// &amp;lt;summary&amp;gt; /// 系統設定管理器，只允許產生一個實例 /// &amp;lt;/summary&amp;gt; public sealed class ConfigurationManager { // 保留唯一實例 private static ConfigurationManager _instance; // 執行緒鎖定物件，確保多執行緒環境下仍只會建立一次 private static readonly object _lock = new object(); /// &amp;lt;summary&amp;gt; /// 連線字串設定 /// &amp;lt;/summary&amp;gt; public string ConnectionString { get; private set; } // 建構子設為私有，阻止外部直接建立 private ConfigurationManager() { Console.WriteLine(&amp;#34;建立 ConfigurationManager 唯一實例&amp;#34;); // 模擬載入設定值 ConnectionString = &amp;#34;Server=myServer;Database=myDB;User Id=myUser;&amp;#34;; } /// &amp;lt;summary&amp;gt; /// 取得唯一實例的存取點 /// &amp;lt;/summary&amp;gt; public static ConfigurationManager Instance { get { if (_instance == null) { lock (_lock) { if (_instance == null) { _instance = new ConfigurationManager(); } } } return _instance; } } } 🚀 實際使用範例 using System; class Program { static void Main(string[] args) { // 第一次取得實例 ConfigurationManager config1 = ConfigurationManager.</description></item><item><title>Day 7: 【文件 #2】使用者的旅程：用 Gemini CLI 描繪「使用者故事」</title><link>/ChiYu-Blob/posts/2025ithomeironmanday7/</link><pubDate>Tue, 26 Aug 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday7/</guid><description>安安，我是 ChiYu！
昨天，我們確立了專案的「北極星」——專案章程，並在 GitHub 上留下了第一個不可磨滅的印記。如果說昨天的「專案章程」是我們的**「戰略地圖」，告訴我們為何而戰、要攻下哪座城池。那今天，我們就要化身為「戰場指揮官」，繪製出士兵（使用者）在戰場上的具體「戰術路線圖」**。
今天，我們將完全在終端機內，描繪這張地圖，產出兩份從「使用者視角」出發的關鍵文件：使用者故事 (User Stories) 與 使用者流程圖 (User Flowchart)。
Part 1：什麼是「使用者故事」？ 別被「故事」這兩個字嚇到，我們不是要寫小說。使用者故事其實是一種在敏捷開發中，用來描述需求的強大工具。
你可以把它想像成你在跟咖啡師點餐。你不會直接跟他說「給我咖啡因、水和牛奶的混合物」，你會說：
身為 一個想提神的顧客 (使用者)，
我想要 一杯大杯的熱拿鐵 (功能)，
以便 讓我有精神撐過下午的會議 (價值)。
看到這個格式的威力了嗎？它強迫我們停止用「工程師的語言」思考，而是用「使用者的語言」思考。一個好的使用者故事，包含了經典的「3C」要素：
Card (卡片)：故事本身簡短扼要，像一張可以貼在牆上的便利貼。 Conversation (對話)：它不是一份冰冷的規格書，而是一個「邀請」，邀請你和 AI 針對這個需求進行對話，釐清細節。 Confirmation (確認)：這是最關鍵的一步！每個故事都應該伴隨著**「驗收條件 (Acceptance Criteria)」**，也就是一個非黑即白、不容狡辯的簡單清單，用來確認「怎樣才算完成了這個故事」。 Part 2：什麼是「使用者流程圖」與 Mermaid.js？ 如果說使用者故事是描述一個個「單點需求」，那「使用者流程圖」就是把這些點串連起來的「路線圖」。它用視覺化的方式，呈現使用者為了完成一個特定目標所需要經過的完整路徑。
一張圖勝過千言萬語，但一張圖配上精闢的文字解說，才能確保所有人對這千言萬語的理解是完全一致的。
而 Mermaid.js 就是一個能讓我們用「文字」來畫流程圖的神奇工具。因為是純文字，所以我們可以輕鬆地用 Git 進行版本控制，這對開發者來說再方便不過了！
Mermaid的語法我暫時不花太多篇幅作介紹，感覺要介紹可以花一天的文章篇幅來完整介紹，在系列文章結束後我再來補充好了(挖坑給自己)！畢竟Mermaid.js 真的有他非常好用的地方，語法簡單直觀、便於版本控制、易於整合與維護而且還跨平台!!!
Part 3：實戰開始：在終端機中扮演我們的產品經理 好了，理論課結束，讓我們再次召喚 Gemini CLI，請它繼續扮演我們的產品經理。
Step 1：詠唱我們的魔法 (Craft the Prompt) 我們要讓 Gemini 直接讀取我們本地的「專案章程」，來確保我們的工作是基於最新、最正確的藍圖。
打開 VS Code 終端機，詠唱我們的第二個「文件生成咒語」：
【魔法詠唱：我們的 Prompt】 # 角色 (Role) 你是一位頂尖的產品經理 (PM)，擁有豐富的敏捷開發經驗，擅長將高階的專案目標，轉化為清晰、可執行的使用者故事與流程。你的產出兼具使用者同理心與技術可行性。 # 目標 (Objective) 我的目標是讓你將一份高階的「專案章程」分解為開發團隊可以立即投入工作的敏捷開發產物 (Agile Artifacts)，包含使用者故事和流程圖。 # 上下文 (Context) - **唯一的真相來源 (Single Source of Truth)**: 請將 @docs/PROJECT_CHARTER.</description></item><item><title>工廠方法模式：點披薩不用親自下廚</title><link>/ChiYu-Blob/posts/%E5%B7%A5%E5%BB%A0%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E9%BB%9E%E6%8A%AB%E8%96%A9%E4%B8%8D%E7%94%A8%E8%A6%AA%E8%87%AA%E4%B8%8B%E5%BB%9A/</link><pubDate>Thu, 12 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E5%B7%A5%E5%BB%A0%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E9%BB%9E%E6%8A%AB%E8%96%A9%E4%B8%8D%E7%94%A8%E8%A6%AA%E8%87%AA%E4%B8%8B%E5%BB%9A/</guid><description>哈囉大家，接續上一次 Singleton 模式，這一次我們要介紹的是另一個超實用的模式：工廠方法模式（Factory Method）。
別看到「工廠」兩個字就開始緊張，其實它超簡單！讓我們先來個輕鬆的比喻吧：
假設你今天去一家披薩店，店員跟你說：「告訴我你想吃什麼披薩，我們後面的廚師就會幫你做出來！」你不用在意披薩到底怎麼做，反正店家會處理好所有製作細節。這樣，你只要說出你想要的東西，剩下的交給專業的工廠就行。
這就是「工廠方法模式」的核心精神啦！
🤔 工廠方法模式什麼時候派得上用場？ 當你遇到以下狀況時，就可以考慮使用工廠方法模式：
你有多種類似的物件需要建立，但你不想每次都自己指定具體的類別。 你想要簡化物件的建立過程，並且統一管理物件的生成邏輯。 你想要未來可以輕鬆新增不同類型的物件，而不需要大幅修改現有的程式碼。 C# 工廠方法模式實作範例 這次我們就以「披薩店」作為具體的案例，示範如何使用工廠方法模式：
🍕 首先，定義產品介面 /// &amp;lt;summary&amp;gt; /// 披薩產品介面 /// &amp;lt;/summary&amp;gt; public interface IPizza { /// &amp;lt;summary&amp;gt; /// 準備食材 /// &amp;lt;/summary&amp;gt; void Prepare(); /// &amp;lt;summary&amp;gt; /// 烘烤披薩 /// &amp;lt;/summary&amp;gt; void Bake(); /// &amp;lt;summary&amp;gt; /// 切割披薩 /// &amp;lt;/summary&amp;gt; void Cut(); /// &amp;lt;summary&amp;gt; /// 裝盒披薩 /// &amp;lt;/summary&amp;gt; void Box(); } 🧑‍🍳 建立具體的產品類別 using System; /// &amp;lt;summary&amp;gt; /// 起司披薩 /// &amp;lt;/summary&amp;gt; public class CheesePizza : IPizza { public void Prepare() =&amp;gt; Console.</description></item><item><title>抽象工廠模式：系列產品輕鬆生產</title><link>/ChiYu-Blob/posts/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%BB%A0%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E7%94%A2%E5%93%81%E8%BC%95%E9%AC%86%E7%94%9F%E7%94%A2/</link><pubDate>Thu, 12 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%BB%A0%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E7%94%A2%E5%93%81%E8%BC%95%E9%AC%86%E7%94%9F%E7%94%A2/</guid><description>嗨各位朋友～前面我們介紹過了 Singleton 和 Factory Method，今天要繼續往下走，聊一個稍微進階一點點的設計模式：「抽象工廠模式（Abstract Factory）」。
🌟 什麼是抽象工廠模式？ 簡單來說，抽象工廠模式就是提供一個介面，讓你可以建立一整系列相關的產品，而不需要關心產品具體的實作方式。
舉個例子，今天你到 IKEA 買家具，通常會想要一次買齊同一系列的產品，比如椅子、桌子、書架等等。如果這些家具都是同系列，外觀看起來會很搭調，品質和風格也會一致。這樣的一個系列產品，就是抽象工廠想幫你解決的問題！
🧐 抽象工廠模式適合什麼場景？ 以下情境適合用抽象工廠模式解決：
你的產品需要有不同的系列或主題，每個系列內又有多個相關產品。 想要保證同系列產品之間能夠完美兼容。 未來可能需要新增更多產品系列，而希望盡可能避免修改現有程式碼。 🛋️ C# 抽象工廠模式範例 這次，我們就用「家具工廠」作為範例來示範抽象工廠模式的實作吧！
1️⃣ 定義產品介面 /// &amp;lt;summary&amp;gt; /// 椅子介面 /// &amp;lt;/summary&amp;gt; public interface IChair { /// &amp;lt;summary&amp;gt; /// 坐在椅子上 /// &amp;lt;/summary&amp;gt; void SitOn(); } /// &amp;lt;summary&amp;gt; /// 桌子介面 /// &amp;lt;/summary&amp;gt; public interface ITable { /// &amp;lt;summary&amp;gt; /// 使用桌子 /// &amp;lt;/summary&amp;gt; void Use(); } 🛋️ 建立具體產品（現代系列和古典系列） using System; /// &amp;lt;summary&amp;gt; /// 現代風格椅子 /// &amp;lt;/summary&amp;gt; public class ModernChair : IChair { public void SitOn() =&amp;gt; Console.</description></item><item><title>原型模式：複製的藝術</title><link>/ChiYu-Blob/posts/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E8%A4%87%E8%A3%BD%E7%9A%84%E8%97%9D%E8%A1%93/</link><pubDate>Thu, 12 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E8%A4%87%E8%A3%BD%E7%9A%84%E8%97%9D%E8%A1%93/</guid><description>嗨！繼續設計模式系列，這次要介紹的主角是原型模式（Prototype）。聽到「原型」這個詞是不是有點不太確定這到底是什麼？別擔心，我們還是用輕鬆易懂的方式來理解它吧！
🌟 原型模式到底在做什麼？ 原型模式簡單來說就是透過「複製」現有的物件，來建立一個新物件。就像我們常用的「複製貼上」一樣。
比如你去文具店要印名片，你只需要給店員一張原稿，他就能根據這份原稿複製出許多張一模一樣的名片，而不用一張一張重新設計。
🤔 什麼時候該用原型模式？ 物件的建立成本較高（例如需要從資料庫讀取大量資料）。 你要建立的物件跟現有物件差異不大，只需要稍微修改一下就可以使用。 希望降低物件建立時的複雜度與耗時。 📑 C# 原型模式範例 這次我們就以「履歷表複製」作為實際案例，來看看怎麼使用原型模式吧！
📄 定義原型介面 /// &amp;lt;summary&amp;gt; /// 原型介面，提供複製方法 /// &amp;lt;/summary&amp;gt; public interface IResume { /// &amp;lt;summary&amp;gt; /// 複製自身 /// &amp;lt;/summary&amp;gt; IResume Clone(); /// &amp;lt;summary&amp;gt; /// 顯示履歷內容 /// &amp;lt;/summary&amp;gt; void Display(); } 📄 實作具體原型類別 using System; /// &amp;lt;summary&amp;gt; /// 履歷表 /// &amp;lt;/summary&amp;gt; public class Resume : IResume { /// &amp;lt;summary&amp;gt; /// 姓名 /// &amp;lt;/summary&amp;gt; public string Name { get; set; } /// &amp;lt;summary&amp;gt; /// 工作經驗 /// &amp;lt;/summary&amp;gt; public string Experience { get; set; } public Resume(string name, string experience) { Name = name; Experience = experience; } /// &amp;lt;summary&amp;gt; /// 複製自身 /// &amp;lt;/summary&amp;gt; public IResume Clone() { // 直接淺層複製即可 return (IResume)this.</description></item><item><title>建造者模式：一步步完成複雜任務</title><link>/ChiYu-Blob/posts/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%80%E6%AD%A5%E6%AD%A5%E5%AE%8C%E6%88%90%E8%A4%87%E9%9B%9C%E4%BB%BB%E5%8B%99/</link><pubDate>Thu, 12 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%80%E6%AD%A5%E6%AD%A5%E5%AE%8C%E6%88%90%E8%A4%87%E9%9B%9C%E4%BB%BB%E5%8B%99/</guid><description>哈囉各位朋友們～今天我們繼續設計模式之旅，來聊聊 建造者模式（Builder） 吧！
🌟 建造者模式是什麼？ 簡單地說，建造者模式就是將一個複雜產品的建構過程拆分成幾個獨立的步驟，然後逐步組裝起來。
你可以想像去 Subway 點三明治：店員會一步一步詢問你想加什麼食材，麵包種類、起司、蔬菜、醬料……最後做出你最愛的那個獨特三明治。這個點餐流程就有點像建造者模式的概念。
透過建造者模式，你可以有系統地建立出不同組合的複雜產品，並且輕鬆管理每一個步驟。
🤔 什麼時候要用建造者模式？ 產品建立過程複雜，有許多可變步驟或選項。 想要明確區分物件的構建步驟與產出的物件。 未來可能會新增更多的建構方式，但不想更動產品本身。 🥪 C# 建造者模式範例 我們就用「三明治店」當作實際範例，讓你馬上理解這個模式吧！
🥖 首先定義產品類別 using System; using System.Collections.Generic; /// &amp;lt;summary&amp;gt; /// 三明治產品 /// &amp;lt;/summary&amp;gt; public class Sandwich { /// &amp;lt;summary&amp;gt; /// 麵包種類 /// &amp;lt;/summary&amp;gt; public string Bread { get; set; } /// &amp;lt;summary&amp;gt; /// 起司種類 /// &amp;lt;/summary&amp;gt; public string Cheese { get; set; } /// &amp;lt;summary&amp;gt; /// 蔬菜配料 /// &amp;lt;/summary&amp;gt; public List&amp;lt;string&amp;gt; Veggies { get; set; } = new List&amp;lt;string&amp;gt;(); /// &amp;lt;summary&amp;gt; /// 醬料 /// &amp;lt;/summary&amp;gt; public string Sauce { get; set; } /// &amp;lt;summary&amp;gt; /// 顯示三明治內容 /// &amp;lt;/summary&amp;gt; public void Display() { Console.</description></item><item><title>介面卡模式：讓不相容也能合作</title><link>/ChiYu-Blob/posts/%E4%BB%8B%E9%9D%A2%E5%8D%A1%E6%A8%A1%E5%BC%8F%E8%AE%93%E4%B8%8D%E7%9B%B8%E5%AE%B9%E4%B9%9F%E8%83%BD%E5%90%88%E4%BD%9C/</link><pubDate>Thu, 12 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E4%BB%8B%E9%9D%A2%E5%8D%A1%E6%A8%A1%E5%BC%8F%E8%AE%93%E4%B8%8D%E7%9B%B8%E5%AE%B9%E4%B9%9F%E8%83%BD%E5%90%88%E4%BD%9C/</guid><description>哈囉大家！今天我們要介紹的設計模式是：介面卡模式（Adapter），又叫做轉接器模式。
🌟 介面卡模式（Adapter）到底在做什麼？ 就像生活中的轉接頭，它能讓本來不相容的介面順利溝通。在軟體開發裡，Adapter 模式同樣扮演橋樑角色，讓舊有系統與新系統或外部套件能順利合作。
🤔 什麼時候適合用 Adapter？ 既有系統或類別的介面與你需要的不相容。 想使用外部套件，但介面不同，無法直接套用。 希望在不修改既有程式碼的前提下解決介面不合的問題。 🔌 C# Adapter 模式範例 我們以「充電器轉接頭」的例子來說明介面卡模式。
🔋 既有不相容的類別 using System; /// &amp;lt;summary&amp;gt; /// 現有的歐洲插座 /// &amp;lt;/summary&amp;gt; public class EuropeanSocket { public void SpecificRequest() =&amp;gt; Console.WriteLine(&amp;#34;使用歐洲規格的插座&amp;#34;); } 🔋 定義目標介面 /// &amp;lt;summary&amp;gt; /// 台灣插頭介面 /// &amp;lt;/summary&amp;gt; public interface ITaiwanPlug { /// &amp;lt;summary&amp;gt; /// 連接插座 /// &amp;lt;/summary&amp;gt; void Request(); } 🔌 建立介面卡 /// &amp;lt;summary&amp;gt; /// 介面卡：讓歐洲插座能用於台灣插頭 /// &amp;lt;/summary&amp;gt; public class PlugAdapter : ITaiwanPlug { private EuropeanSocket _europeanSocket; public PlugAdapter(EuropeanSocket socket) { _europeanSocket = socket; } public void Request() { // 透過轉接頭呼叫原本的歐洲規格插座 _europeanSocket.</description></item><item><title>橋接模式：抽象與實作分離</title><link>/ChiYu-Blob/posts/%E6%A9%8B%E6%8E%A5%E6%A8%A1%E5%BC%8F%E6%8A%BD%E8%B1%A1%E8%88%87%E5%AF%A6%E4%BD%9C%E5%88%86%E9%9B%A2/</link><pubDate>Thu, 12 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E6%A9%8B%E6%8E%A5%E6%A8%A1%E5%BC%8F%E6%8A%BD%E8%B1%A1%E8%88%87%E5%AF%A6%E4%BD%9C%E5%88%86%E9%9B%A2/</guid><description>哈囉大家～我們繼續來探索設計模式的世界吧！今天要介紹的是一個聽起來可能有點陌生，但其實很實用的設計模式：橋接模式（Bridge）。
🌟 橋接模式是什麼？ 橋接模式將抽象部分和實作部分分離，讓它們可以獨立變化。想像遙控器與電視：不希望為每種遙控器和電視的組合都寫一次程式碼，這時就能運用橋接模式。
🤔 什麼時候適合用橋接模式？ 避免抽象和實作之間產生過多耦合。 有多個維度需要獨立擴充。 想降低程式複雜度，避免類別過多。 📺 C# 橋接模式範例 以「遙控器控制電視」為例說明。
📡 建立實作介面（電視） /// &amp;lt;summary&amp;gt; /// 電視實作介面 /// &amp;lt;/summary&amp;gt; public interface ITV { void On(); void Off(); void SetChannel(int channel); } 📺 建立具體實作 using System; /// &amp;lt;summary&amp;gt; /// Sony 電視 /// &amp;lt;/summary&amp;gt; public class SonyTV : ITV { public void On() =&amp;gt; Console.WriteLine(&amp;#34;Sony 電視開機&amp;#34;); public void Off() =&amp;gt; Console.WriteLine(&amp;#34;Sony 電視關機&amp;#34;); public void SetChannel(int channel) =&amp;gt; Console.WriteLine($&amp;#34;Sony 電視設定頻道：{channel}&amp;#34;); } /// &amp;lt;summary&amp;gt; /// Samsung 電視 /// &amp;lt;/summary&amp;gt; public class SamsungTV : ITV { public void On() =&amp;gt; Console.</description></item><item><title>組合模式：樹狀結構的好幫手</title><link>/ChiYu-Blob/posts/%E7%B5%84%E5%90%88%E6%A8%A1%E5%BC%8F%E6%A8%B9%E7%8B%80%E7%B5%90%E6%A7%8B%E7%9A%84%E5%A5%BD%E5%B9%AB%E6%89%8B/</link><pubDate>Thu, 12 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E7%B5%84%E5%90%88%E6%A8%A1%E5%BC%8F%E6%A8%B9%E7%8B%80%E7%B5%90%E6%A7%8B%E7%9A%84%E5%A5%BD%E5%B9%AB%E6%89%8B/</guid><description>哈囉大家，歡迎繼續探索設計模式之旅！今天要介紹的是一個既實用又好理解的設計模式：組合模式（Composite）。
🌟 組合模式是什麼？ 組合模式讓你能將物件組織成樹狀結構，表示「整體—部分」的層次關係。像資料夾裡有資料夾、檔案又放在資料夾中，這正是組合模式的典型應用。
🤔 什麼時候適合用組合模式？ 需要表示物件的「整體—部分」階層。 想要用一致的方式處理個別物件和物件群組。 希望簡化客戶端程式碼，不必區分個體與集合的處理邏輯。 📁 C# 組合模式範例 用「檔案系統」來示範組合模式。
📄 建立抽象組件介面 /// &amp;lt;summary&amp;gt; /// 抽象檔案系統元件 /// &amp;lt;/summary&amp;gt; public interface IFileSystemComponent { /// &amp;lt;summary&amp;gt; /// 以縮排方式顯示結構 /// &amp;lt;/summary&amp;gt; void Display(int depth); } 📁 建立樹枝構件（資料夾） using System; using System.Collections.Generic; /// &amp;lt;summary&amp;gt; /// 資料夾 /// &amp;lt;/summary&amp;gt; public class Folder : IFileSystemComponent { private string _name; private List&amp;lt;IFileSystemComponent&amp;gt; _components = new List&amp;lt;IFileSystemComponent&amp;gt;(); public Folder(string name) { _name = name; } /// &amp;lt;summary&amp;gt; /// 新增子元件 /// &amp;lt;/summary&amp;gt; public void Add(IFileSystemComponent component) { _components.</description></item><item><title>裝飾者模式：讓功能自由加點</title><link>/ChiYu-Blob/posts/%E8%A3%9D%E9%A3%BE%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AE%93%E5%8A%9F%E8%83%BD%E8%87%AA%E7%94%B1%E5%8A%A0%E9%BB%9E/</link><pubDate>Thu, 12 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E8%A3%9D%E9%A3%BE%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AE%93%E5%8A%9F%E8%83%BD%E8%87%AA%E7%94%B1%E5%8A%A0%E9%BB%9E/</guid><description>哈囉朋友們～今天要介紹的設計模式可是非常實用又有趣的喔，那就是 裝飾者模式（Decorator）！
🌟 什麼是裝飾者模式？ 裝飾者模式讓你在不修改現有物件程式碼的情況下，動態地增加新的功能。簡單來說，就是「包一層再包一層」的概念。
想像一下買一杯飲料，你可以加珍珠、椰果、鮮奶油等等，每個配料就像一個裝飾，你可以自由組合，做出你專屬的飲料，這就是裝飾者模式的概念！
🤔 什麼情況適合用裝飾者模式？ 當你遇到以下情境時，很適合使用裝飾者模式：
需要動態地為物件增加或移除功能。 不想直接修改原本類別的程式碼，避免影響原本物件的穩定性。 想要彈性地組合不同的功能，並且可以隨時調整功能。 🎂 C# 裝飾者模式範例 我們用最容易理解的「咖啡加料」案例，來看看怎麼實作裝飾者模式吧！
☕ 定義抽象元件（Component） using System; /// &amp;lt;summary&amp;gt; /// 咖啡抽象元件 /// &amp;lt;/summary&amp;gt; public abstract class Coffee { /// &amp;lt;summary&amp;gt; /// 取得描述 /// &amp;lt;/summary&amp;gt; public abstract string GetDescription(); /// &amp;lt;summary&amp;gt; /// 供應咖啡 /// &amp;lt;/summary&amp;gt; public abstract void Serve(); } ☕ 實作具體元件 using System; /// &amp;lt;summary&amp;gt; /// 基本咖啡 /// &amp;lt;/summary&amp;gt; public class SimpleCoffee : Coffee { /// &amp;lt;summary&amp;gt; /// 取得描述 /// &amp;lt;/summary&amp;gt; public override string GetDescription() =&amp;gt; &amp;#34;基本咖啡&amp;#34;; /// &amp;lt;summary&amp;gt; /// 供應咖啡 /// &amp;lt;/summary&amp;gt; public override void Serve() { Console.</description></item><item><title>外觀模式：化繁為簡</title><link>/ChiYu-Blob/posts/%E5%A4%96%E8%A7%80%E6%A8%A1%E5%BC%8F%E5%8C%96%E7%B9%81%E7%82%BA%E7%B0%A1/</link><pubDate>Thu, 12 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E5%A4%96%E8%A7%80%E6%A8%A1%E5%BC%8F%E5%8C%96%E7%B9%81%E7%82%BA%E7%B0%A1/</guid><description>哈囉大家～今天的主題非常實用，那就是「外觀模式（Facade）」！這個模式可以有效地讓複雜的系統變得簡單又好用，就像你按下遙控器的開機鍵，電視就會自動開啟、調整音量，甚至切換到你最愛的頻道一樣。
🌟 外觀模式是什麼？ 外觀模式其實就是為複雜系統提供一個簡單的介面，讓使用者不需要了解複雜的細節，就能輕鬆操作系統內部的功能。
例如，去電影院看電影時，你只需要買一張電影票，電影院就幫你搞定座位安排、播放電影、空調系統等等，這就是外觀模式的概念啦！
🤔 什麼情況適合用外觀模式？ 當你遇到以下的狀況時，特別適合使用外觀模式：
系統變得複雜，使用者需要了解太多細節。 想提供一個簡單的介面給使用者，隱藏複雜的內部運作細節。 想降低系統的耦合性，提高易用性與可維護性。 🎬 C# 外觀模式範例 這次我們就用「電影院系統」的例子，來看看外觀模式怎麼運作吧！
🎥 複雜的子系統類別 using System; /// &amp;lt;summary&amp;gt; /// 投影機 /// &amp;lt;/summary&amp;gt; public class Projector { /// &amp;lt;summary&amp;gt; /// 開啟投影機 /// &amp;lt;/summary&amp;gt; public void TurnOn() =&amp;gt; Console.WriteLine(&amp;#34;投影機已開啟。&amp;#34;); /// &amp;lt;summary&amp;gt; /// 關閉投影機 /// &amp;lt;/summary&amp;gt; public void TurnOff() =&amp;gt; Console.WriteLine(&amp;#34;投影機已關閉。&amp;#34;); } /// &amp;lt;summary&amp;gt; /// 音響系統 /// &amp;lt;/summary&amp;gt; public class AudioSystem { /// &amp;lt;summary&amp;gt; /// 開啟音響系統 /// &amp;lt;/summary&amp;gt; public void TurnOn() =&amp;gt; Console.</description></item><item><title>享元模式：節省記憶體的利器</title><link>/ChiYu-Blob/posts/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E7%AF%80%E7%9C%81%E8%A8%98%E6%86%B6%E9%AB%94%E7%9A%84%E5%88%A9%E5%99%A8/</link><pubDate>Thu, 12 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E7%AF%80%E7%9C%81%E8%A8%98%E6%86%B6%E9%AB%94%E7%9A%84%E5%88%A9%E5%99%A8/</guid><description>哈囉各位朋友，今天我們要聊的是一個特別省資源的設計模式：享元模式（Flyweight）。
🌟 享元模式是什麼？ 享元模式是一種可以有效節省記憶體的設計模式，透過共享相同或相似的物件，避免建立過多重複的小型物件。
舉個例子：假設你在做簡報，需要大量使用同一張圖片，與其在每張投影片裡都重新複製一次圖片，不如只保留一張原始圖片，其他投影片只需要參考這張圖片就好。這樣一來可以降低檔案大小，節省記憶體。
🤔 什麼情境適合使用享元模式？ 系統中存在大量重複的物件。 物件的建立與銷毀成本過高，並且這些物件大多類似。 想節省記憶體資源，提升系統效能。 🌳 C# 享元模式範例 以下以遊戲中常見的「樹木」為例，示範享元模式的實作方式。
🌳 享元介面與實作 using System; /// &amp;lt;summary&amp;gt; /// 樹木介面 /// &amp;lt;/summary&amp;gt; public interface ITree { /// &amp;lt;summary&amp;gt; /// 顯示樹木 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;x&amp;#34;&amp;gt;位置 X 座標&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;y&amp;#34;&amp;gt;位置 Y 座標&amp;lt;/param&amp;gt; void Display(int x, int y); } /// &amp;lt;summary&amp;gt; /// 具體享元類別 /// &amp;lt;/summary&amp;gt; public class Tree : ITree { private readonly string _treeType; public Tree(string treeType) { _treeType = treeType; Console.</description></item><item><title>代理模式：控制存取的守門員</title><link>/ChiYu-Blob/posts/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E6%8E%A7%E5%88%B6%E5%AD%98%E5%8F%96%E7%9A%84%E5%AE%88%E9%96%80%E5%93%A1/</link><pubDate>Thu, 12 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E6%8E%A7%E5%88%B6%E5%AD%98%E5%8F%96%E7%9A%84%E5%AE%88%E9%96%80%E5%93%A1/</guid><description>哈囉各位朋友～今天我們要介紹的是很實用且日常生活也常碰到的 代理模式（Proxy）！
🌟 代理模式是什麼？ 代理模式提供一個中介物件來控制對某個目標物件的存取，藉此加入額外行為或保護原本的物件。 就像看醫生必須先掛號一樣，櫃檯人員就是代理，他負責管理你與醫生之間的互動。
🤔 什麼情況適合用代理模式？ 需要控制物件的存取權限，例如安全管理或權限限制。 想延遲建立昂貴的物件實例，例如檔案或資料庫連線。 想在不影響原有物件的情況下，加入額外行為（例如日誌紀錄）。 🛂 C# 代理模式範例 這裡以「檔案存取權限控制」為例，示範代理模式的實作。
📂 定義共通介面 /// &amp;lt;summary&amp;gt; /// 檔案介面 /// &amp;lt;/summary&amp;gt; public interface IFile { /// &amp;lt;summary&amp;gt; /// 顯示檔案內容 /// &amp;lt;/summary&amp;gt; void Display(); } 📄 建立具體物件類別 using System; /// &amp;lt;summary&amp;gt; /// 真實存取檔案的類別 /// &amp;lt;/summary&amp;gt; public class RealFile : IFile { private readonly string _fileName; public RealFile(string fileName) { _fileName = fileName; LoadFromDisk(fileName); } /// &amp;lt;summary&amp;gt; /// 顯示檔案 /// &amp;lt;/summary&amp;gt; public void Display() { Console.</description></item><item><title>責任鏈模式：層層把關的處理機制</title><link>/ChiYu-Blob/posts/%E8%B2%AC%E4%BB%BB%E9%8F%88%E6%A8%A1%E5%BC%8F%E5%B1%A4%E5%B1%A4%E6%8A%8A%E9%97%9C%E7%9A%84%E8%99%95%E7%90%86%E6%A9%9F%E5%88%B6/</link><pubDate>Thu, 12 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E8%B2%AC%E4%BB%BB%E9%8F%88%E6%A8%A1%E5%BC%8F%E5%B1%A4%E5%B1%A4%E6%8A%8A%E9%97%9C%E7%9A%84%E8%99%95%E7%90%86%E6%A9%9F%E5%88%B6/</guid><description>哈囉～又來到了我們設計模式系列啦，今天要介紹的是一個非常靈活又好用的模式：責任鏈模式（Chain of Responsibility）。
🌟 責任鏈模式是什麼？ 責任鏈模式是一種將請求逐一傳遞，直到找到合適的處理者來處理的設計模式。就像公司報銷流程，先交給直屬主管簽核，如果權限不足就往上一層，直到有權限的人批准為止。
透過這個模式，每個處理者只專注自己的職責，無法處理的部分就交給下一個處理者，既清楚又明確。
🤔 什麼情況適合使用責任鏈模式？ 多個物件都能處理同一個請求，但條件或處理範圍不同。 責任層級可能會更動，希望降低請求者與處理者的耦合度。 想讓系統更彈性，可依需求增減處理節點。 📝 C# 責任鏈模式範例 以下以「公司費用審核」為例，示範責任鏈模式的實作。
💼 建立抽象處理者（Handler） using System; /// &amp;lt;summary&amp;gt; /// 抽象處理者 /// &amp;lt;/summary&amp;gt; public abstract class Approver { /// &amp;lt;summary&amp;gt; /// 下一位處理者 /// &amp;lt;/summary&amp;gt; protected Approver _nextApprover; /// &amp;lt;summary&amp;gt; /// 設定下一位處理者 /// &amp;lt;/summary&amp;gt; public void SetNext(Approver approver) { _nextApprover = approver; } /// &amp;lt;summary&amp;gt; /// 處理請求 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;amount&amp;#34;&amp;gt;請求金額&amp;lt;/param&amp;gt; public abstract void HandleRequest(decimal amount); } 👩‍💻 建立具體處理者（主管、經理、總經理） using System; /// &amp;lt;summary&amp;gt; /// 主管 /// &amp;lt;/summary&amp;gt; public class Supervisor : Approver { public override void HandleRequest(decimal amount) { if (amount &amp;lt;= 1000) { Console.</description></item><item><title>命令模式：靈活封裝的請求指令</title><link>/ChiYu-Blob/posts/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E9%9D%88%E6%B4%BB%E5%B0%81%E8%A3%9D%E7%9A%84%E8%AB%8B%E6%B1%82%E6%8C%87%E4%BB%A4/</link><pubDate>Thu, 12 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E9%9D%88%E6%B4%BB%E5%B0%81%E8%A3%9D%E7%9A%84%E8%AB%8B%E6%B1%82%E6%8C%87%E4%BB%A4/</guid><description>哈囉大家，今天我們來聊聊 命令模式（Command），這個設計模式能幫助你將請求封裝成物件，讓你可以輕鬆地操作、延遲或撤銷命令。
🌟 命令模式是什麼？ 命令模式是一種將「動作」封裝成獨立物件的設計模式。這樣做的好處是，你可以隨時決定何時執行這個動作，甚至是取消它。
舉個例子來說，就像餐廳點餐時，你的每一份點餐單都是一個命令，廚房按照你的點餐單來做餐點，服務生只需將點餐單交給廚房即可，不需要知道廚房如何烹飪食物。
🤔 什麼情況適合使用命令模式？ 想要將執行動作的物件與觸發動作的物件解耦。 需要將命令排程、延遲或撤銷。 想記錄請求歷史，以支援撤銷操作。 🍔 C# 命令模式範例 這次我們以餐廳點餐的例子來實作命令模式。
📝 定義命令介面 /// &amp;lt;summary&amp;gt; /// 命令介面 /// &amp;lt;/summary&amp;gt; public interface ICommand { /// &amp;lt;summary&amp;gt; /// 執行命令 /// &amp;lt;/summary&amp;gt; void Execute(); } 🍲 建立具體命令 using System; /// &amp;lt;summary&amp;gt; /// 點餐命令 /// &amp;lt;/summary&amp;gt; public class OrderCommand : ICommand { private readonly Kitchen _kitchen; private readonly string _dish; public OrderCommand(Kitchen kitchen, string dish) { _kitchen = kitchen; _dish = dish; } /// &amp;lt;summary&amp;gt; /// 執行點餐動作 /// &amp;lt;/summary&amp;gt; public void Execute() { _kitchen.</description></item><item><title>解譯器模式：讓程式聽懂你的指令</title><link>/ChiYu-Blob/posts/%E8%A7%A3%E8%AD%AF%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%AE%93%E7%A8%8B%E5%BC%8F%E8%81%BD%E6%87%82%E4%BD%A0%E7%9A%84%E6%8C%87%E4%BB%A4/</link><pubDate>Thu, 12 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E8%A7%A3%E8%AD%AF%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%AE%93%E7%A8%8B%E5%BC%8F%E8%81%BD%E6%87%82%E4%BD%A0%E7%9A%84%E6%8C%87%E4%BB%A4/</guid><description>哈囉各位朋友，今天我們來認識一個有趣又實用的設計模式：解譯器模式（Interpreter），並以好玩的「文字冒險遊戲」為例，輕鬆學會如何讓你的程式讀懂自訂語言或指令。
🌟 解譯器模式是什麼？ 解譯器模式是一種用來解析特定語言或表達式的設計模式，它能夠讓你的程式懂得使用者輸入的特定語法或指令，並做出相應的回應或行動。
就像在玩文字冒險遊戲時，你輸入「攻擊 巨龍 使用 火球」，遊戲就能理解你的指令，並做出相應的動作一樣。
🤔 什麼情況適合使用解譯器模式？ 需要處理使用者輸入的特殊指令或語法。 想設計一個易於擴充與修改的指令解析系統。 系統需要理解並執行使用者自定義的操作。 🎮 C# 解譯器模式範例（文字冒險遊戲） 以下以文字冒險遊戲為例，示範如何透過解譯器模式解析玩家輸入的指令。
🎲 定義抽象指令介面 /// &amp;lt;summary&amp;gt; /// 遊戲指令介面 /// &amp;lt;/summary&amp;gt; public interface IGameCommand { /// &amp;lt;summary&amp;gt; /// 執行指令 /// &amp;lt;/summary&amp;gt; void Execute(); } ⚔️ 建立具體指令 using System; /// &amp;lt;summary&amp;gt; /// 攻擊指令 /// &amp;lt;/summary&amp;gt; public class AttackCommand : IGameCommand { private readonly string _target; // 攻擊目標 private readonly string _weapon; // 使用武器 public AttackCommand(string target, string weapon) { _target = target; _weapon = weapon; } /// &amp;lt;inheritdoc /&amp;gt; public void Execute() { Console.</description></item><item><title>迭代器模式：輕鬆遍歷集合元素</title><link>/ChiYu-Blob/posts/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%BC%95%E9%AC%86%E9%81%8D%E6%AD%B7%E9%9B%86%E5%90%88%E5%85%83%E7%B4%A0/</link><pubDate>Fri, 13 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%BC%95%E9%AC%86%E9%81%8D%E6%AD%B7%E9%9B%86%E5%90%88%E5%85%83%E7%B4%A0/</guid><description>哈囉朋友們～今天來聊聊迭代器模式（Iterator），這個設計模式能幫你輕鬆管理和操作集合中的元素。
🌟 什麼是迭代器模式？ 迭代器模式讓你可以逐一瀏覽集合中的每個元素，而不需知道集合的內部結構。 就像你用音樂 App 播放音樂時，播放清單會自動幫你一首一首播放下一首歌曲，你不需要知道歌曲是怎麼儲存的。這就是迭代器模式的精髓啦！
🤔 什麼情況適合使用迭代器模式？ 以下情況很適合使用迭代器模式：
當你需要循序瀏覽集合中的元素，但不想暴露集合的內部結構。 你希望使用相同的方式來遍歷不同類型的集合。 想要讓集合的操作更加直觀與易用。 🎧 C# 迭代器模式範例：音樂播放清單 我們以「音樂播放清單」為範例，讓你輕鬆理解迭代器模式的應用。
🎵 定義抽象迭代器介面 /// &amp;lt;summary&amp;gt; /// 迭代器介面 /// &amp;lt;/summary&amp;gt; public interface IIterator { /// &amp;lt;summary&amp;gt; /// 是否還有下一首 /// &amp;lt;/summary&amp;gt; bool HasNext(); /// &amp;lt;summary&amp;gt; /// 取得下一首歌曲 /// &amp;lt;/summary&amp;gt; string Next(); } 🎶 建立集合類別（播放清單） using System.Collections.Generic; /// &amp;lt;summary&amp;gt; /// 音樂播放清單 /// &amp;lt;/summary&amp;gt; public class Playlist { private readonly List&amp;lt;string&amp;gt; _songs = new(); // 儲存歌曲 /// &amp;lt;summary&amp;gt; /// 歌曲清單(唯讀) /// &amp;lt;/summary&amp;gt; public IReadOnlyList&amp;lt;string&amp;gt; Songs =&amp;gt; _songs; /// &amp;lt;summary&amp;gt; /// 新增歌曲 /// &amp;lt;/summary&amp;gt; public void AddSong(string song) { _songs.</description></item><item><title>中介者模式：管理複雜溝通的好幫手</title><link>/ChiYu-Blob/posts/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%E7%AE%A1%E7%90%86%E8%A4%87%E9%9B%9C%E6%BA%9D%E9%80%9A%E7%9A%84%E5%A5%BD%E5%B9%AB%E6%89%8B/</link><pubDate>Fri, 13 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%E7%AE%A1%E7%90%86%E8%A4%87%E9%9B%9C%E6%BA%9D%E9%80%9A%E7%9A%84%E5%A5%BD%E5%B9%AB%E6%89%8B/</guid><description>哈囉朋友們～今天要聊的設計模式是中介者模式（Mediator），這個模式能讓你的程式輕鬆管理物件之間複雜的溝通關係。
🌟 中介者模式是什麼？ 中介者模式透過一個中介者物件來協調其他物件之間的互動，避免物件間的直接聯繫導致的混亂。
想像你使用聊天室時，你並不直接跟每個使用者對話，而是透過聊天室作為中介，幫你發送訊息給其他使用者，這樣每個人只要與聊天室溝通即可，簡單明瞭。
🤔 什麼情況適合使用中介者模式？ 以下情況適合使用中介者模式：
當系統內有許多物件需要彼此溝通，關係變得複雜難以管理。 想降低物件間的耦合度，讓系統容易維護與擴充。 想集中管理物件之間的溝通邏輯。 💬 C# 中介者模式範例：聊天室應用程式 我們透過「聊天室」範例來實際展示中介者模式。
💻 定義中介者介面 /// &amp;lt;summary&amp;gt; /// 中介者介面 /// &amp;lt;/summary&amp;gt; public interface IChatMediator { /// &amp;lt;summary&amp;gt; /// 傳送訊息給其他使用者 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;message&amp;#34;&amp;gt;訊息內容&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;user&amp;#34;&amp;gt;發送者&amp;lt;/param&amp;gt; void SendMessage(string message, User user); /// &amp;lt;summary&amp;gt; /// 註冊使用者到聊天室 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;user&amp;#34;&amp;gt;新使用者&amp;lt;/param&amp;gt; void RegisterUser(User user); } 👥 建立具體中介者（聊天室） using System; using System.Collections.Generic; /// &amp;lt;summary&amp;gt; /// 聊天室中介者，負責轉發訊息 /// &amp;lt;/summary&amp;gt; public class ChatMediator : IChatMediator { private readonly List&amp;lt;User&amp;gt; _users = new(); // 聊天室中的使用者名單 /// &amp;lt;inheritdoc /&amp;gt; public void RegisterUser(User user) { _users.</description></item><item><title>備忘錄模式：保存與恢復物件狀態</title><link>/ChiYu-Blob/posts/%E5%82%99%E5%BF%98%E9%8C%84%E6%A8%A1%E5%BC%8F%E4%BF%9D%E5%AD%98%E8%88%87%E6%81%A2%E5%BE%A9%E7%89%A9%E4%BB%B6%E7%8B%80%E6%85%8B/</link><pubDate>Fri, 13 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E5%82%99%E5%BF%98%E9%8C%84%E6%A8%A1%E5%BC%8F%E4%BF%9D%E5%AD%98%E8%88%87%E6%81%A2%E5%BE%A9%E7%89%A9%E4%BB%B6%E7%8B%80%E6%85%8B/</guid><description>哈囉朋友們！今天我們要介紹的是一個超實用的設計模式：備忘錄模式（Memento），透過它，我們可以輕鬆儲存並回復物件的狀態！
🌟 備忘錄模式是什麼？ 備忘錄模式允許你捕捉一個物件的內部狀態，並且在未來需要時，能夠將物件回復到原先的狀態。
就像玩遊戲時的「存檔」和「讀取進度」功能一樣，當你不小心走錯路或失敗時，可以輕鬆回到之前的狀態重新來過。
🤔 什麼情況適合使用備忘錄模式？ 當你有以下情境時，很適合使用備忘錄模式：
需要提供撤銷（undo）或回復（redo）操作。 物件狀態可能頻繁改變，且希望能隨時回到某個特定的狀態。 不想暴露物件內部狀態的細節給外部使用者。 🎮 C# 備忘錄模式範例：遊戲存檔系統 我們透過「遊戲角色存檔」來說明備忘錄模式的應用。
🎲 建立備忘錄（Memento） /// &amp;lt;summary&amp;gt; /// 遊戲狀態備忘錄 /// &amp;lt;/summary&amp;gt; public class GameMemento { /// &amp;lt;summary&amp;gt; /// 等級 /// &amp;lt;/summary&amp;gt; public int Level { get; } /// &amp;lt;summary&amp;gt; /// 生命值 /// &amp;lt;/summary&amp;gt; public int Health { get; } public GameMemento(int level, int health) { Level = level; Health = health; } } 🧙 遊戲角色（Originator） using System; /// &amp;lt;summary&amp;gt; /// 遊戲角色 /// &amp;lt;/summary&amp;gt; public class GameCharacter { /// &amp;lt;summary&amp;gt; /// 等級 /// &amp;lt;/summary&amp;gt; public int Level { get; set; } /// &amp;lt;summary&amp;gt; /// 生命值 /// &amp;lt;/summary&amp;gt; public int Health { get; set; } /// &amp;lt;summary&amp;gt; /// 顯示目前狀態 /// &amp;lt;/summary&amp;gt; public void DisplayStatus() { Console.</description></item><item><title>觀察者模式：即時通知的好幫手</title><link>/ChiYu-Blob/posts/%E8%A7%80%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%8D%B3%E6%99%82%E9%80%9A%E7%9F%A5%E7%9A%84%E5%A5%BD%E5%B9%AB%E6%89%8B/</link><pubDate>Fri, 13 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E8%A7%80%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%8D%B3%E6%99%82%E9%80%9A%E7%9F%A5%E7%9A%84%E5%A5%BD%E5%B9%AB%E6%89%8B/</guid><description>哈囉朋友們～今天我們要聊的是觀察者模式（Observer），這個模式在現實生活中非常常見，讓我們輕鬆理解並學會如何運用它！
🌟 觀察者模式是什麼？ 觀察者模式定義了物件之間一對多的依賴關係，當一個物件的狀態發生變化時，所有依賴它的物件都能立即收到通知。
就像你在追蹤 YouTuber 的頻道一樣，當他們有新影片上傳，你就會收到通知，立刻去觀看新內容。這個頻道就像被觀察的物件（Subject），而你就像是觀察者（Observer）。
🤔 什麼時候適合使用觀察者模式？ 以下情況很適合使用觀察者模式：
當你想要在物件的狀態改變時，自動通知其他相關物件。 希望實現鬆散耦合，提升系統彈性。 當系統的變更可能會影響多個物件時。 🔔 C# 觀察者模式範例：YouTube 頻道通知系統 這次我們以 YouTube 頻道訂閱通知為例，來實作觀察者模式。
📺 建立主題介面（Subject） using System.Collections.Generic; /// &amp;lt;summary&amp;gt; /// 主題介面，負責管理訂閱者 /// &amp;lt;/summary&amp;gt; public interface IChannel { /// &amp;lt;summary&amp;gt; /// 訂閱頻道 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;subscriber&amp;#34;&amp;gt;訂閱者&amp;lt;/param&amp;gt; void Subscribe(ISubscriber subscriber); /// &amp;lt;summary&amp;gt; /// 取消訂閱 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;subscriber&amp;#34;&amp;gt;訂閱者&amp;lt;/param&amp;gt; void Unsubscribe(ISubscriber subscriber); /// &amp;lt;summary&amp;gt; /// 通知所有訂閱者 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;videoTitle&amp;#34;&amp;gt;影片標題&amp;lt;/param&amp;gt; void NotifySubscribers(string videoTitle); } 🎥 具體主題類別（頻道） using System; using System.</description></item><item><title>狀態模式：依狀態改變行為的祕訣</title><link>/ChiYu-Blob/posts/%E7%8B%80%E6%85%8B%E6%A8%A1%E5%BC%8F%E4%BE%9D%E7%8B%80%E6%85%8B%E6%94%B9%E8%AE%8A%E8%A1%8C%E7%82%BA%E7%9A%84%E7%A5%95%E8%A8%A3/</link><pubDate>Fri, 13 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E7%8B%80%E6%85%8B%E6%A8%A1%E5%BC%8F%E4%BE%9D%E7%8B%80%E6%85%8B%E6%94%B9%E8%AE%8A%E8%A1%8C%E7%82%BA%E7%9A%84%E7%A5%95%E8%A8%A3/</guid><description>哈囉朋友們～今天我們要聊的是非常實用且有趣的狀態模式（State），這個模式讓你的物件能夠根據內部狀態的變化而自動改變行為。
🌟 狀態模式是什麼？ 狀態模式允許一個物件在內部狀態改變時改變它的行為，就像換了一個角色一樣。
舉個實際例子，就像是手機的鈴聲狀態，手機在「靜音」模式時，不會響鈴；切換到「響鈴」模式後，就會有聲音通知你。這就是狀態模式的基本概念，透過改變狀態讓物件呈現不同的行為。
🤔 什麼時候適合使用狀態模式？ 以下情況很適合使用狀態模式：
物件的行為會根據內部狀態不同而有所改變。 當有大量條件判斷，且這些條件判斷取決於物件的狀態時。 希望避免使用大量的條件語句（if-else或switch），讓程式更清晰、更易於維護。 📱 C# 狀態模式範例：手機鈴聲模式 我們以手機鈴聲模式為範例來示範狀態模式。
🔕 定義狀態介面 /// &amp;lt;summary&amp;gt; /// 狀態介面 /// &amp;lt;/summary&amp;gt; public interface IMobileState { /// &amp;lt;summary&amp;gt; /// 依目前狀態執行提醒 /// &amp;lt;/summary&amp;gt; void Alert(); } 📳 建立具體狀態類別 using System; /// &amp;lt;summary&amp;gt; /// 響鈴模式 /// &amp;lt;/summary&amp;gt; public class RingingState : IMobileState { /// &amp;lt;inheritdoc /&amp;gt; public void Alert() { Console.WriteLine(&amp;#34;手機正在響鈴...&amp;#34;); } } /// &amp;lt;summary&amp;gt; /// 靜音模式 /// &amp;lt;/summary&amp;gt; public class SilentState : IMobileState { /// &amp;lt;inheritdoc /&amp;gt; public void Alert() { Console.</description></item><item><title>策略模式：靈活切換行為的好幫手</title><link>/ChiYu-Blob/posts/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E9%9D%88%E6%B4%BB%E5%88%87%E6%8F%9B%E8%A1%8C%E7%82%BA%E7%9A%84%E5%A5%BD%E5%B9%AB%E6%89%8B/</link><pubDate>Fri, 13 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E9%9D%88%E6%B4%BB%E5%88%87%E6%8F%9B%E8%A1%8C%E7%82%BA%E7%9A%84%E5%A5%BD%E5%B9%AB%E6%89%8B/</guid><description>哈囉朋友們～今天我們要介紹的設計模式是非常靈活好用的策略模式（Strategy），透過它，你可以輕鬆替換不同的行為，讓你的程式更有彈性！
🌟 策略模式是什麼？ 策略模式允許你定義一系列的演算法，並讓這些演算法可以互相替換，且獨立於使用它們的客戶端。
想像一下，你去旅行時可以選擇不同的交通方式，比如搭飛機、搭高鐵或開車。你根據不同的需求（時間、成本、舒適度）選擇不同的策略，這就是策略模式的核心概念！
🤔 什麼情況適合使用策略模式？ 以下情況很適合使用策略模式：
需要動態地切換不同的演算法或行為。 想避免使用大量的條件判斷語句（if-else 或 switch）。 希望使系統容易擴充，能輕鬆增加新的演算法或行為。 🚗 C# 策略模式範例：旅遊交通工具選擇 這次我們以旅遊時選擇交通工具作為範例。
🚅 定義策略介面 /// &amp;lt;summary&amp;gt; /// 交通策略介面 /// &amp;lt;/summary&amp;gt; public interface ITravelStrategy { /// &amp;lt;summary&amp;gt; /// 前往指定目的地 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;destination&amp;#34;&amp;gt;目的地&amp;lt;/param&amp;gt; void Travel(string destination); } ✈️ 建立具體策略類別 using System; /// &amp;lt;summary&amp;gt; /// 飛機策略 /// &amp;lt;/summary&amp;gt; public class PlaneStrategy : ITravelStrategy { public void Travel(string destination) { Console.WriteLine($&amp;#34;搭飛機前往 {destination}&amp;#34;); } } /// &amp;lt;summary&amp;gt; /// 高鐵策略 /// &amp;lt;/summary&amp;gt; public class HighSpeedRailStrategy : ITravelStrategy { public void Travel(string destination) { Console.</description></item><item><title>模板方法模式：固定流程靈活實作</title><link>/ChiYu-Blob/posts/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%9B%BA%E5%AE%9A%E6%B5%81%E7%A8%8B%E9%9D%88%E6%B4%BB%E5%AF%A6%E4%BD%9C/</link><pubDate>Fri, 13 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%9B%BA%E5%AE%9A%E6%B5%81%E7%A8%8B%E9%9D%88%E6%B4%BB%E5%AF%A6%E4%BD%9C/</guid><description>哈囉朋友們～今天我們要介紹的是非常實用且常見的模板方法模式（Template Method），透過它你可以固定一系列的步驟，讓子類別靈活地去實現細節。
🌟 模板方法模式是什麼？ 模板方法模式定義了一個演算法的骨架，並將一些步驟延遲到子類別去實現。這樣的設計可以確保演算法的結構保持一致，但又能靈活地調整細節。
例如，你在製作各種口味的披薩時，無論是海鮮披薩還是夏威夷披薩，都有一個基本的製作步驟（揉麵團、加醬料、放餡料、烤披薩）。模板方法模式就是把這個固定步驟封裝起來，讓子類別專注於實現每個細節。
🤔 什麼時候適合使用模板方法模式？ 以下情況很適合使用模板方法模式：
當你有一系列步驟，但每個步驟的具體實現可能會有所不同。 想確保演算法的結構不被子類別改變，保證流程的統一性。 希望提供一個明確的框架，讓開發者能快速實現不同的具體步驟。 🍕 C# 模板方法模式範例：披薩製作流程 這次我們以製作披薩的流程作為範例。
🍅 建立抽象類別 using System; /// &amp;lt;summary&amp;gt; /// 披薩製作抽象類別 /// &amp;lt;/summary&amp;gt; public abstract class PizzaMaker { /// &amp;lt;summary&amp;gt; /// 製作披薩的流程 /// &amp;lt;/summary&amp;gt; public void MakePizza() { PrepareDough(); AddSauce(); AddToppings(); BakePizza(); } /// &amp;lt;summary&amp;gt; /// 準備麵團 /// &amp;lt;/summary&amp;gt; protected void PrepareDough() { Console.WriteLine(&amp;#34;揉製麵團...&amp;#34;); } /// &amp;lt;summary&amp;gt; /// 加入醬料 /// &amp;lt;/summary&amp;gt; protected void AddSauce() { Console.WriteLine(&amp;#34;加入醬料...&amp;#34;); } /// &amp;lt;summary&amp;gt; /// 加入配料，由子類別實作 /// &amp;lt;/summary&amp;gt; protected abstract void AddToppings(); /// &amp;lt;summary&amp;gt; /// 烘烤披薩 /// &amp;lt;/summary&amp;gt; protected void BakePizza() { Console.</description></item><item><title>訪問者模式：新增功能不動既有架構</title><link>/ChiYu-Blob/posts/%E8%A8%AA%E5%95%8F%E8%80%85%E6%A8%A1%E5%BC%8F%E6%96%B0%E5%A2%9E%E5%8A%9F%E8%83%BD%E4%B8%8D%E5%8B%95%E6%97%A2%E6%9C%89%E6%9E%B6%E6%A7%8B/</link><pubDate>Fri, 13 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E8%A8%AA%E5%95%8F%E8%80%85%E6%A8%A1%E5%BC%8F%E6%96%B0%E5%A2%9E%E5%8A%9F%E8%83%BD%E4%B8%8D%E5%8B%95%E6%97%A2%E6%9C%89%E6%9E%B6%E6%A7%8B/</guid><description>哈囉朋友們～今天要介紹的是比較特殊但十分強大的訪問者模式（Visitor），透過這個模式，你可以在不修改物件結構的情況下輕鬆新增功能！
🌟 訪問者模式是什麼？ 訪問者模式允許你在不改變現有類別結構的情況下，為類別增加新的操作。
舉個例子，就像遊樂園的各種設施，每個訪客來到遊樂園會玩不同的設施。設施本身不會改變，但每位訪客的行為和感受可能不同，訪客們就是訪問者（Visitor），設施則是被訪問的元素（Element）。
🤔 什麼情況適合使用訪問者模式？ 以下情況很適合使用訪問者模式：
當你需要對一個物件結構新增許多不同且不相關的操作。 希望在不修改現有結構的情況下，能輕鬆增加新功能。 當物件結構相對穩定，但操作或功能可能經常變動時。 🎢 C# 訪問者模式範例：遊樂園設施與訪客 這次我們以遊樂園的訪客與設施為例。
🎠 定義元素介面（設施） /// &amp;lt;summary&amp;gt; /// 設施介面 /// &amp;lt;/summary&amp;gt; public interface IAmusementFacility { /// &amp;lt;summary&amp;gt; /// 接受訪問者 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;visitor&amp;#34;&amp;gt;訪問者&amp;lt;/param&amp;gt; void Accept(IVisitor visitor); } 🎡 具體設施類別 /// &amp;lt;summary&amp;gt; /// 雲霄飛車 /// &amp;lt;/summary&amp;gt; public class RollerCoaster : IAmusementFacility { public void Accept(IVisitor visitor) { visitor.Visit(this); } } /// &amp;lt;summary&amp;gt; /// 摩天輪 /// &amp;lt;/summary&amp;gt; public class FerrisWheel : IAmusementFacility { public void Accept(IVisitor visitor) { visitor.</description></item><item><title>開發日誌 #1：我把『人生』變成了一款可以練功打寶的RPG！</title><link>/ChiYu-Blob/posts/hlr-devlog-1/</link><pubDate>Thu, 03 Jul 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/hlr-devlog-1/</guid><description>大家好！我是 ChiYu，很高興你正在看「習慣人生RPG」(Habit-Life RPG / H.L.R.) 的第一篇開發日誌！
先問大家一個問題：你是不是也一樣，手機裡裝了一堆待辦事項App，結果最後都懶得打開？看著那些永遠劃不完的清單，只覺得煩，完全沒有動力。
但奇怪的是，我們轉頭就能在遊戲裡，為了升1%經驗值、刷一件更好的裝備，熬夜奮戰好幾個小時。
這讓我一直在想，如果…只是如果…做正事也能像玩遊戲一樣爽，那該有多好？
這個念頭，就是「習慣人生RPG」的起點。這不只是一個App，更像是我傾注所有熱情，想實現的一個夢想：把無聊的現實生活，變成一場刺激又好玩的冒險！
所以，這到底是一款怎樣的App？ 簡單來說，你就是你自己人生的主角！你在H.L.R.中會創建一個代表你的像素小英雄，接著，你在現實中做的每一件事，都會直接影響他在遊戲裡的成長。
把鳥事變任務，把努力變獎勵！
「每日運動30分鐘」？ 這不是待辦事項，這是「體能訓練」每日任務，完成就給你滿滿的經驗值 (EXP) 和金幣！ 「交一份專案報告」？ 這不是工作，這是一次性的「史詩任務」，解完直接噴裝備！ 想戒掉宵夜？ 沒問題！把它設成你的「習慣挑戰」，只要忍住，角色就會變強；但要是破戒了…嘿嘿，角色的HP可是會下降的喔！ 打造你專屬的英雄！ 升級拿到的點數，你可以自由點在「力量」、「智力」、「敏捷」上。想當個頭好壯壯的戰士，還是聰明絕頂的法師？都由你決定！這些屬性還會強化你對應的技能，讓你在養成相關習慣時事半功倍。
獨創「BOSS戰」系統，把大目標變成超燃的副本！ 這絕對是H.L.R.的靈魂！我們誰沒有過那種超遠大的目標？像是**「多益成績要拚到金色證書」、「日文檢定要過N2」，或是「拿到那張夢寐以求的AWS雲端證照」**。
這些目標超大、超可怕，就像遊戲裡打不倒的最終BOSS。但在H.L.R.裡，你可以把它們真的變成一隻隻血條超厚的**「認證型BOSS」**！
準備多益？那「背完100個單字」就是一次普攻，「做完一回模擬測驗」就是一記強力技能，直接削掉BOSS一大格血！你會親眼看著BOSS的血條在你每天的努力下不斷減少，直到你考到證照的那天，就是你帥氣地吼出「阿搭啦！」然後擊敗BOSS的時刻！
不讓你孤單的夥伴們 冒險的路上怎麼能沒有夥伴？你可以和現實中的朋友、家人組成「公會」或「家庭」，一起挑戰公會專屬的BOSS，互相打氣。當然，還有你的AI智慧小夥伴「亞當/夏娃」，他會在你身邊給你貼心的提醒和建議。
這所有的一切，都發生在一個可愛又懷舊的像素世界裡。
接下來的計畫？ 這款App是我用愛發電的熱情專案。目前，我正全力打磨核心的任務系統，確保整個「努力-回饋」的循環玩起來是真的有趣、真的有感。同時，我也在準備「菁英大師」訂閱方案的相關功能，希望能給深度使用者帶來更多驚喜。
不久後，我們預計會展開第一輪小規模的封閉測試。
如果你也對這個「把人生變遊戲」的瘋狂計畫有興趣，想成為第一批進入這個世界的勇者，或者單純想看一個夢想是如何被一行行程式碼實現的，歡迎你繼續追蹤這個部落格。
感謝你讀完這篇日誌。我們的冒險，現在才正要開始呢！</description></item><item><title>Day 3: 【工具篇 #1】萬丈高樓平地起：建置本地開發環境</title><link>/ChiYu-Blob/posts/2025ithomeironmanday3/</link><pubDate>Fri, 22 Aug 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday3/</guid><description>安安，我是 ChiYu！
昨天，我們在腦中畫好了宏偉的建築藍圖 (DDD)，確立了「文件驅動開發」這個核心心法。今天，理論課結束，我們要開始動手了！我們將扮演「技師與軍火官」的角色，為接下來的開發大戰，準備好我們最精良的「施工機具」與「建材」。
「工欲善其事，必先利其器」。一個乾淨、強大、順手的開發環境，是所有偉大專案的起點。今天的目標非常明確：手把手帶你完成所有必要的環境安裝，包括 Python、Node.js，以及我們的開發神器 VS Code。
Part 1：我們的「總工具箱」：安裝 Visual Studio Code (VS Code) 在無數的程式碼編輯器中，VS Code 已經成為了現代開發的絕對主流。為什麼？原因很簡單：它免費、開源、速度快、功能強大，而且擁有全世界最豐富的「擴充功能」生態系，可以讓我們把它打造成任何我們想要的樣子。
Step 1：安裝 VS Code
VS Code 官網下載連結：https://code.visualstudio.com/ 請直接前往官網，網站會自動偵測你的作業系統（Windows, Mac, Linux），下載對應的版本，然後像安裝普通軟體一樣，無腦下一步到底就對了。
Step 2：初次見面！認識 VS Code 的介面
當你第一次打開 VS Code，可能會看到一個歡迎畫面。別怕，我們先來認識一下它的幾個主要區域，未來它們會成為你最熟悉的朋友：
左側活動列 (Activity Bar)：最左邊那一排圖示，是你切換不同功能的入口，例如檔案總管、搜尋、原始碼管理（就是 Git）、以及我們待會要安裝的擴充功能。 側邊欄 (Side Bar)：點擊活動列的圖示後，左邊展開的區域就是側邊欄。最常用到的就是「檔案總管」，我們專案的所有資料夾和檔案都會顯示在這裡。 編輯區 (Editor)：中間最大塊的區域，就是我們主要編寫程式碼與文件的地方。 底部面板 (Panel)：下方可以拉開的區域，這裡非常重要，因為它包含了「終端機 (Terminal)」。我們之後所有的魔法指令，都會在這裡詠唱！ Part 2：VS Code 威力升級：必備擴充功能 (Extensions) 如果說 VS Code 是一個功能強大的手機，那「擴充功能」就是上面的 App，能讓你的手機擁有各種超能力。
請在左側活動列找到像「俄羅斯方塊」一樣的圖示，那就是擴充功能的市集。點擊它，然後在搜尋框裡，找到並全部安裝以下幾個我們這次旅程必備的神級外掛：
Python (Microsoft) 這是什麼：微軟官方出品的 Python 語言支援包。 為什麼必裝：裝上它，你的 VS Code 才會真正「看懂」Python。它提供了智慧程式碼提示、自動補全、語法錯誤檢查、除錯等所有核心功能，直接將 VS Code 變身為一個頂級的 Python IDE。 Prettier - Code formatter 這是什麼：你的程式碼專屬造型師。 為什麼必裝：它會在每次存檔時，自動把你的程式碼整理成一個統一、乾淨、漂亮的風格。從此告別為了「兩個空格還是四個空格」而引發的聖戰！ GitLens — Git supercharged 這是什麼：Git 的透視眼鏡。 為什麼必裝：它能讓你直接在程式碼的每一行旁邊，看到這行是誰、在什麼時候修改的，極大地增強了 VS Code 的版本控制能力。 Thunder Client 這是什麼：內建在 VS Code 裡的 API 測試神器。 為什麼必裝：我們之後會用它來測試我們寫好的後端 API，不用再開別的軟體，非常方便。先裝起來放！ Markdown Preview Mermaid Support 這是什麼：讓你的文件活起來的魔法。 為什麼必裝：我們之後會用 Mermaid.</description></item><item><title>Day 2: 【心法篇】開發者的航海圖：什麼是文件驅動開發 (DDD)？</title><link>/ChiYu-Blob/posts/2025ithomeironmanday2/</link><pubDate>Thu, 21 Aug 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday2/</guid><description>嘿，大家好啊！我是 ChiYu。
昨天聊到 AI 開發，一不小心就把小小的「腳踏車」專案搞成一艘「航空母艦」，超頭痛的對吧？這種「AI 太能幹」造成的失控，在 Vibe Coding 的浪潮下，只會越來越常見。這不只是個笑話，它反映了一個深刻的問題：當我們擁有無窮的力量（AI），卻沒有明確的方向時，混亂是必然的結果。
那到底要怎麼辦，才能讓 AI 乖乖聽話，不要自己亂加戲？我們該如何從一個被 AI 牽著鼻子走的「使用者」，蛻變成一個能駕馭 AI 的「指揮家」？
今天就要來分享我的秘密武器，一個能讓你從「玩票」變「專業」的酷東西：文件驅動開發 (Document-Driven Development, DDD)！
我知道，一聽到「文件」兩個字，你可能就想關掉了，感覺超無聊，對吧？先別走！相信我，這東西比你想的有趣多了，它就是我們駕馭 Vibe Coding 這匹野馬最重要的「韁繩」！這不是要你回到寫八股文的老路，而是要教你一種用「文字」來駕馭「程式碼」的現代魔法。
核心精神：「左移」你的思考 (Shift-Left) 在蓋房子前，你會先畫好藍圖，還是直接叫工人來亂蓋一通？當然是先畫藍圖嘛！這個簡單的道理，在軟體開發中卻常常被遺忘。
這在我們寫程式的世界裡，有個很潮的說法叫 「左移」(Shift-Left)。意思就是，把所有燒腦的規劃、設計工作，全部往前挪。這就像規劃一場環島旅行，你不會等到出發當天才在想要去哪裡、住哪裡，對吧？你肯定會提前好幾個禮拜，就把路線、住宿、景點都研究得一清二楚。
為什麼？因為一開始在紙上改個設計，頂多花幾分鐘；等到牆都蓋好了才說要改，那可就得花好幾天敲掉重來，不只工人想罷工，連設計師都會想掐死你！修改的成本，隨著時間往右，是呈指數級暴增的，這不只是時間成本，更是團隊士氣的巨大耗損。一個小小的早期決策失誤，到後期可能會演變成需要數週才能修復的**「技術債」**，那種感覺真的糟透了。
DDD 就是這個概念的最佳實踐，先想清楚，再動手！
所以，DDD 到底在幹嘛？ 所以說，DDD 到底是在幹嘛？超簡單，就是一個規矩：
沒文件，就沒有 Code！
這聽起來可能有點極端，但它的核心是一種紀律，一種能帶來巨大回報的紀律。整個開發流程大概是這樣：
先動腦，再動手：有任何新想法？第一步絕對不是打開 VS Code，而是先把它跟 AI「聊」成一份具體的規格文件。這個「聊」的過程，其實就是在強迫我們把腦中模糊不清的想法，具象化成有邏輯、有結構的文字。很多時候，光是在這個階段，你就會發現自己想法中的矛盾與漏洞。 在文件上吵架：所有的討論、修改，都在文件上搞定。這是一種健康的吵架！把所有可能的誤解、模糊地帶，在程式碼誕生前就全部解決掉。在文件上吵架，成本是零；但在程式碼上吵架，成本可能就是好幾個工程師好幾天的工時，改文字總比改程式碼便宜吧？ 文件就是聖旨：文件一旦定稿，就是不能亂改的「施工命令單」。它成為了我們後續所有開發工作的唯一依據。這份文件就像是我們與「未來的自己」以及「AI」之間簽訂的一份契約，確保大家永遠在同一個頻道上。 寫 Code 只是翻譯：這時候，寫程式就變得很單純，不再是天馬行空的創作，而是把文件上的東西，有效率地「翻譯」成程式碼而已。開發者的認知負擔被大幅降低，我們可以更專注在如何把程式碼寫得更乾淨、更有效率，而不是一邊寫一邊想「我到底要做什麼來著？」。 面對現實：我知道，你討厭寫文件 好啦，我知道你在想什麼。講到「寫文件」，大概九成的工程師（包括我！）都會翻白眼。心裡想著：
「唉，又來了」「敏捷開發不是說不用寫文件嗎？」「我有這時間不如多寫幾行 Code」。
這真的不是我們的錯！很多人誤解了「敏捷開發」的精神，它強調的是「可工作的軟體 勝於 詳盡的文件」，而不是「不要文件」。一份沒人看的、過時的文件確實是垃圾；但一份能指引方向、建立共識的「活文件」，卻是專案成功的基石。以前寫文件又痛苦又沒用，誰想寫啊？我們都經歷過那種「文件是個謊言」的專案，規格書上寫 A，但程式碼早就改成 B 了，這種文件不如不要有。
但這次，我們不自己動手寫 但！這次完全不一樣了！
我們不用自己一個字一個字地敲文件！
我們要讓 AI 當我們的專屬寫手。我們的工作，從苦哈哈的打字員，升級成動動嘴巴的決策者。開發的瓶頸，不再是我們的打字速度，而是我們思想的清晰度。
說白了，「下指令 (Prompt)」本身，就是一種新時代的「規格設計」啦！ 我們的價值，從「如何實現」，轉變成了「如何清晰地定義問題」。這是一種更高層次的抽象能力，也是未來開發者的核心競爭力。
「好文件」不是廢話文學，而是唯一的真理 既然有 AI 幫忙，我們更應該專注在做出「有用的」文件。這份文件就是我們專案的 「單一真理來源 (Single Source of Truth, SSoT)」，所有人都得聽它的！</description></item><item><title>Day 1: 【啟程】嘿，AI！我們來做個網站，但這次，我們約法三章</title><link>/ChiYu-Blob/posts/2025ithomeironmanday1/</link><pubDate>Wed, 20 Aug 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday1/</guid><description>Day 0: 【啟程】嘿，AI！我們來做個網站，但這次，我們約法三章 嘿，大家好啊！我是 ChiYu，也可以叫我 Eric。
寫了五年的 Code，平常都在跟 .Net 還有 Azure 打交道。簡單說，就是個靠鍵盤吃飯的工程師啦。去年有參賽，但中途忘記發文中斷!!! 希望今年能培養好習慣每天準時一篇不斷更!!!
這趟旅程，是為誰準備的？ 在開始之前，我想先說說，這系列文章是為誰而寫的。
你可能完全沒有程式背景，但對現在最紅的 Vibe Coding 充滿好奇嗎？你是不是也想跟上這波 AI 浪潮，試著自己動手做點東西，甚至想成為一名開發者呢？
如果答案是「YES」，那這系列文章就是為你量身打造的！
我們不只玩 Vibe Coding，我更希望在過程中，帶你認識一些重要的「開發觀念」。像是什麼是「前端」、「後端」？什麼是「API」？版本要怎麼控制？這些在專業開發中一定會用到的術語和工作流程，我會用最白話的方式，融入到我們的實作裡。
所以，別擔心自己是「程式小白」。跟著我，我們一步一步來，不只做出一個酷專案，更要幫你打下成為開發者的堅實基礎。
那個…我只是想要一台腳踏車，你給我一艘航空母艦幹嘛？ 身為工程師，有新玩具當然會想要跟著玩看看，但純粹的 Vibe Coding 下去，到底會得到什麼？
我的故事是這樣的：我想說來做個最經典最常見的「待辦事項清單 (Todo List)」練練手感。就對 AI 下了一個超簡單的指令：「幫我做個 Todo List 網站，要有CRUD的功能，並且想要一個簡約的UI，我希望專案要越完整越好。」
那時候我心裡想的超單純：啊不就一個 HTML，裡面塞一點點 JavaScript 就搞定了嗎？簡單、好懂、我自己要改也方便。
結果呢？AI 老兄一頓操作猛如虎，給我生出了一整個專案包。我點開資料夾，下巴直接掉下來。哇靠，這是怎樣？React、Node.js、Express、MongoDB……全家餐都來了！
老實說，這 App 能跑，但感覺完全歪掉了。我只是想要一台腳踏車，結果 AI 給了我一艘航空母艦。這要我怎麼騎……啊不是，這已經超出我所了解與熟悉的範圍，且專案規模整個失控！會導致這樣的原因有各種可能，可能是我的Prompt太過鬆散，但又出現了這個「專案要越完整越好」這個關鍵字，也可能是AI自己異想天開等等。出現這種「技術奇觀」讓我意識到，完全放任的 Vibe Coding 真的很容易失控，變成一個你根本不想碰的燙手山芋。
而且老實說，有時候在社群上看到一些分享，真的會替他們頭痛，曾看到有人在分享，他的朋友VibeCoding出了一個購物網站，但登入系統不論怎麼打密碼都可以登入，或是開發出的網站把所有應加密資訊顯露出去。
我完全懂拿到新玩具那種興奮感，AI 工具也確實是開發上的一大福音，而且也讓許多程式小白能體會成為一名工程師的感覺!! 但問題出在「盲目相信」。當專案一搞大，你很快會發現：東西越來越難改、AI 給的專案根本跑不起來、就算跑起來了，噴出來的 BUG 你也看不懂。更慘的是，你叫 AI 修，它修完又生出新的 BUG，最後就卡在一個無限迴圈裡動彈不得。這對沒有太多開發經驗的人來說，真的是個超級大坑。
為魔法裝上韁繩：左手藍圖，右手魔法 所以咧？難道就要這樣放棄 AI 這個神隊友嗎？當然不行！
這就像拿到一把絕世神兵，你不能因為它太利就把它丟掉，而是要學會怎麼駕馭它。所以我就開始找方法，到底要怎麼做才能讓 AI 乖乖聽話，然後我找到了這個說新不新說舊不舊的開發法則：</description></item><item><title>我是如何使用 AI (Codex) 打造這個 Hugo 部落格的</title><link>/ChiYu-Blob/posts/%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-ai-codex-%E6%89%93%E9%80%A0%E9%80%99%E5%80%8B-hugo-%E9%83%A8%E8%90%BD%E6%A0%BC%E7%9A%84/</link><pubDate>Sun, 08 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-ai-codex-%E6%89%93%E9%80%A0%E9%80%99%E5%80%8B-hugo-%E9%83%A8%E8%90%BD%E6%A0%BC%E7%9A%84/</guid><description>在上一篇文章 《第一次認識 Codex：讓 AI 幫你寫程式不是夢！》 中，我介紹了 Codex 這個強大的 AI 程式助理。而今天，我想分享一個更具體的實戰經驗：我是如何利用 Codex 來開發你現在正在看的這個部落格。
這個網站是使用 Hugo 靜態網站產生器搭建的，並搭配 Tailwind CSS 進行樣式設計。從前端的 JavaScript 互動功能，到後端的 GitHub Actions 自動化部署，許多環節都有 AI 的深度參與。接下來，我會分享幾個關鍵功能的開發過程，以及我是如何「詠唱」我的需求，讓 AI 幫我完成任務的。
1. 前端互動功能：讓網站活起來的 JavaScript 靜態網站很容易變得單調，但透過 JavaScript，我們可以加入許多動態的現代化功能。這也是我認為 Codex 最能大顯身手的地方。
深色/淺色主題切換 這是現代網站的標配功能。我需要一個按鈕，它能：
切換 &amp;lt;html&amp;gt; 標籤上的 data-theme 屬性 (在 light 與 dark 之間)。 將用戶的偏好儲存在瀏覽器的 localStorage 中，以便下次造訪時維持設定。 當主題變更時，通知 Giscus 留言區一起變更主題。 我的提問大致如下：
「幫我寫一段 JavaScript。當使用者點擊 ID 為 theme-toggle 的按鈕時，在 &amp;lt;html&amp;gt; 元素上切換 data-theme 屬性，值為 &amp;rsquo;light&amp;rsquo; 或 &amp;lsquo;dark&amp;rsquo;。將這個設定存到 localStorage。頁面載入時，優先從 localStorage 讀取設定。最後，當主題改變時，發送一個 postMessage 給 class 為 giscus-frame 的 iframe，內容為 { giscus: { setTheme: newTheme } }。」</description></item><item><title>第一次認識 Codex：讓 AI 幫你寫程式不是夢！</title><link>/ChiYu-Blob/posts/%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%AA%8D%E8%AD%98-codex%E8%AE%93-ai-%E5%B9%AB%E4%BD%A0%E5%AF%AB%E7%A8%8B%E5%BC%8F%E4%B8%8D%E6%98%AF%E5%A4%A2/</link><pubDate>Thu, 05 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%AA%8D%E8%AD%98-codex%E8%AE%93-ai-%E5%B9%AB%E4%BD%A0%E5%AF%AB%E7%A8%8B%E5%BC%8F%E4%B8%8D%E6%98%AF%E5%A4%A2/</guid><description>最近如果你有在關注 AI 或寫程式的領域，可能會聽過一個名字——Codex。它是 OpenAI 推出的一個超厲害工具，簡單來說，就是一個會寫程式的 AI。今天這篇文章就想用比較輕鬆的方式，來帶大家初步認識一下 Codex 是什麼、可以拿來做什麼、還有怎麼開始玩看看。
Codex 是什麼？跟 ChatGPT 有關嗎？ 沒錯，Codex 是 OpenAI（就是做 ChatGPT 那家公司）開發的模型之一。它其實就是 ChatGPT 的「懂程式」版本。
你可以把它想成一個超強的助理工程師，你對它講人話，它就能幫你寫出程式碼。不管你是要寫一個 Python 函式，還是建一個簡單的網頁 API，Codex 都能幫你快速搞定，甚至連註解都幫你寫好。
Codex 可以幫你做什麼？ 它的功能說起來還真不少，這邊列幾個我覺得超實用的：
自然語言變程式碼：你只要打「幫我寫一個排序的函式」，Codex 馬上就可以用 Python 幫你寫出來。 支援多種語言：Python、JavaScript、C#、Go、Ruby……通通支援，開什麼語言的專案都能用。 幫忙除錯：看不懂 error message？丟給 Codex，讓它幫你分析。 寫測試、補註解：這些瑣碎事 Codex 做起來超快，超方便。 誰適合用 Codex？ 老實說，不管你是剛入門的新手，還是忙到炸的資深工程師，Codex 都有它的價值：
對新手來說，它就像一個 24 小時在線的老師，問什麼都不會兇你。 對老手來說，它超像一個效率助手，幫你處理一堆重複或機械性的事，省下超多時間。 要怎麼開始用？ 目前 Codex 主要是整合在 ChatGPT 專業版（Pro）裡，直接在 ChatGPT 裡輸入程式問題就可以用了。
如果你比較偏好本地開發環境，也可以試試看一些支援 Codex 的 IDE 外掛，比如 Visual Studio Code，現在已經有支援類似 Copilot 的功能。
小結一下 Codex 是一個能聽懂你說話、然後幫你寫程式的 AI，對很多人來說，它可以加速開發、降低學習門檻、甚至讓寫程式變得更輕鬆有趣。
如果你還沒試過，不妨開個 ChatGPT Pro 試試，玩玩看 Codex 的威力。這篇文章只是開個頭，之後我也會陸續寫些更進階的使用心得與實際應用分享，敬請期待！</description></item></channel></rss>