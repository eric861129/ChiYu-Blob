<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Code on ChiYu Code Journey</title><link>/ChiYu-Blob/tags/code/</link><description>Recent content in Code on ChiYu Code Journey</description><generator>Hugo -- gohugo.io</generator><language>zh-TW</language><lastBuildDate>Thu, 12 Jun 2025 16:00:00 +0800</lastBuildDate><atom:link href="/ChiYu-Blob/tags/code/index.xml" rel="self" type="application/rss+xml"/><item><title>搞懂設計模式到底是什麼？</title><link>/ChiYu-Blob/posts/%E6%90%9E%E6%87%82%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E9%BA%BC/</link><pubDate>Wed, 11 Jun 2025 12:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E6%90%9E%E6%87%82%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E9%BA%BC/</guid><description>哈囉！最近我決定開始一個新的 Side Project，要來用比較輕鬆的方式跟大家分享一下什麼是「設計模式（Design Patterns）」。
等等先別跑！雖然聽起來很硬，但設計模式其實就是一些「前輩工程師們」留下來的解決問題的好方法。懂了這些，你的程式碼會變得更容易維護，更容易擴充，甚至看起來更專業！（聽起來是不是有點心動了？）
這篇先帶你入個門，我們會聊聊設計模式的概念、分類，最後也會簡單列出一些常見好用的模式，讓你一次搞懂設計模式到底在幹嘛。
🧐 所以，到底什麼是設計模式啊？ 簡單說，設計模式就像是程式設計師之間的「共通語言」。
你一定有過這種經驗：
「欸，我怎麼又寫出這種一團亂的程式碼？」 「這個功能之前不是做過了嗎？為什麼還要再寫一次？」 這時候，如果你腦袋裡裝著幾種設計模式，就像工具箱一樣，你就能更快速地解決這些問題。
設計模式其實就是經過無數開發者實踐後得出的好用解決方案，就像老前輩的私房武功，學起來絕對讓你的程式碼更整齊、更有架構，也比較不容易踩坑。
設計模式可以怎麼分？ 一般來說，設計模式分成三大類：
建立型模式（Creational Patterns）
重點在教你怎麼更聰明地「建立」物件，避免程式碼越寫越複雜。
結構型模式（Structural Patterns）
教你怎麼把物件組合在一起，像拼樂高一樣，輕鬆擴充或調整程式的架構。
行為型模式（Behavioral Patterns）
教你搞定物件之間複雜的「溝通與互動」，讓你的程式碼彼此合作起來更加順暢。
是不是聽起來越來越清楚了？接下來我們更進一步，列出每個分類下的常見模式，讓你一眼看懂設計模式家族有什麼好貨！
常見設計模式大集合 這邊先條列式介紹，未來我會用獨立的文章、一個一個講清楚：
🚀 建立型模式（Creational） 單例模式（Singleton） 工廠方法模式（Factory Method） 抽象工廠模式（Abstract Factory） 原型模式（Prototype） 建造者模式（Builder） 📌 特點： 這一類幫你搞定物件的建立，讓你不用一直煩惱物件從哪裡來，要怎麼產生之類的問題。
2. 結構型模式（Structural） 介面卡模式（Adapter） 橋接模式（Bridge） 組合模式（Composite） 裝飾者模式（Decorator） 外觀模式（Facade） 享元模式（Flyweight） 代理模式（Proxy） 📌 特點： 這些模式專門解決如何「拼裝」不同物件，讓你的程式更容易擴充、更有彈性。
想像成在玩樂高，一個一個小零件組裝起來，最後變成超酷的東西！
🚦 行為型模式（Behavioral） 責任鏈模式（Chain of Responsibility） 命令模式（Command） 解譯器模式（Interpreter） 迭代器模式（Iterator） 中介者模式（Mediator） 備忘錄模式（Memento） 觀察者模式（Observer） 狀態模式（State） 策略模式（Strategy） 模板方法模式（Template Method） 訪問者模式（Visitor） 📌 特點： 處理物件之間的「互動」。如果你常常覺得你的物件們關係很亂，溝通起來像在吵架，那這些模式就是你的救星！</description></item><item><title>單例模式：只要一個就夠！</title><link>/ChiYu-Blob/posts/%E5%96%AE%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%8F%AA%E8%A6%81%E4%B8%80%E5%80%8B%E5%B0%B1%E5%A4%A0/</link><pubDate>Thu, 12 Jun 2025 10:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E5%96%AE%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%8F%AA%E8%A6%81%E4%B8%80%E5%80%8B%E5%B0%B1%E5%A4%A0/</guid><description>在上一篇文章中，我們簡單認識了什麼是「設計模式」。這次，就讓我們從最經典的「單例模式（Singleton）」開始，看看它究竟能為開發帶來什麼幫助吧！
☕ 小故事：世界上只此一家 想像你開了一間只允許存在一個分店的咖啡廳，無論客人怎麼找，都只能到這家。單例模式的精神也差不多：確保整個應用程式裡只有同一個實例存在。
🤔 什麼情境適合用 Singleton？ 系統設定：確保設定檔只有一份，避免各模組各自讀取產生混亂。 日誌記錄：統一紀錄進入點，不會讓檔案四散。 資料庫連線：集中管理連線、節省資源。 接下來的範例將以「系統設定」為主角，用 C# 程式碼示範 Singleton 的實作。
💻 Singleton 類別 using System; /// &amp;lt;summary&amp;gt; /// 系統設定管理器，只允許產生一個實例 /// &amp;lt;/summary&amp;gt; public sealed class ConfigurationManager { // 保留唯一實例 private static ConfigurationManager _instance; // 執行緒鎖定物件，確保多執行緒環境下仍只會建立一次 private static readonly object _lock = new object(); /// &amp;lt;summary&amp;gt; /// 連線字串設定 /// &amp;lt;/summary&amp;gt; public string ConnectionString { get; private set; } // 建構子設為私有，阻止外部直接建立 private ConfigurationManager() { Console.WriteLine(&amp;#34;建立 ConfigurationManager 唯一實例&amp;#34;); // 模擬載入設定值 ConnectionString = &amp;#34;Server=myServer;Database=myDB;User Id=myUser;&amp;#34;; } /// &amp;lt;summary&amp;gt; /// 取得唯一實例的存取點 /// &amp;lt;/summary&amp;gt; public static ConfigurationManager Instance { get { if (_instance == null) { lock (_lock) { if (_instance == null) { _instance = new ConfigurationManager(); } } } return _instance; } } } 🚀 實際使用範例 using System; class Program { static void Main(string[] args) { // 第一次取得實例 ConfigurationManager config1 = ConfigurationManager.</description></item><item><title>工廠方法模式：點披薩不用親自下廚</title><link>/ChiYu-Blob/posts/%E5%B7%A5%E5%BB%A0%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E9%BB%9E%E6%8A%AB%E8%96%A9%E4%B8%8D%E7%94%A8%E8%A6%AA%E8%87%AA%E4%B8%8B%E5%BB%9A/</link><pubDate>Thu, 12 Jun 2025 10:30:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E5%B7%A5%E5%BB%A0%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E9%BB%9E%E6%8A%AB%E8%96%A9%E4%B8%8D%E7%94%A8%E8%A6%AA%E8%87%AA%E4%B8%8B%E5%BB%9A/</guid><description>哈囉大家，接續上一次 Singleton 模式，這一次我們要介紹的是另一個超實用的模式：工廠方法模式（Factory Method）。
別看到「工廠」兩個字就開始緊張，其實它超簡單！讓我們先來個輕鬆的比喻吧：
假設你今天去一家披薩店，店員跟你說：「告訴我你想吃什麼披薩，我們後面的廚師就會幫你做出來！」你不用在意披薩到底怎麼做，反正店家會處理好所有製作細節。這樣，你只要說出你想要的東西，剩下的交給專業的工廠就行。
這就是「工廠方法模式」的核心精神啦！
🤔 工廠方法模式什麼時候派得上用場？ 當你遇到以下狀況時，就可以考慮使用工廠方法模式：
你有多種類似的物件需要建立，但你不想每次都自己指定具體的類別。 你想要簡化物件的建立過程，並且統一管理物件的生成邏輯。 你想要未來可以輕鬆新增不同類型的物件，而不需要大幅修改現有的程式碼。 C# 工廠方法模式實作範例 這次我們就以「披薩店」作為具體的案例，示範如何使用工廠方法模式：
🍕 首先，定義產品介面 /// &amp;lt;summary&amp;gt; /// 披薩產品介面 /// &amp;lt;/summary&amp;gt; public interface IPizza { /// &amp;lt;summary&amp;gt; /// 準備食材 /// &amp;lt;/summary&amp;gt; void Prepare(); /// &amp;lt;summary&amp;gt; /// 烘烤披薩 /// &amp;lt;/summary&amp;gt; void Bake(); /// &amp;lt;summary&amp;gt; /// 切割披薩 /// &amp;lt;/summary&amp;gt; void Cut(); /// &amp;lt;summary&amp;gt; /// 裝盒披薩 /// &amp;lt;/summary&amp;gt; void Box(); } 🧑‍🍳 建立具體的產品類別 using System; /// &amp;lt;summary&amp;gt; /// 起司披薩 /// &amp;lt;/summary&amp;gt; public class CheesePizza : IPizza { public void Prepare() =&amp;gt; Console.</description></item><item><title>抽象工廠模式：系列產品輕鬆生產</title><link>/ChiYu-Blob/posts/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%BB%A0%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E7%94%A2%E5%93%81%E8%BC%95%E9%AC%86%E7%94%9F%E7%94%A2/</link><pubDate>Thu, 12 Jun 2025 11:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%BB%A0%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E7%94%A2%E5%93%81%E8%BC%95%E9%AC%86%E7%94%9F%E7%94%A2/</guid><description>嗨各位朋友～前面我們介紹過了 Singleton 和 Factory Method，今天要繼續往下走，聊一個稍微進階一點點的設計模式：「抽象工廠模式（Abstract Factory）」。
🌟 什麼是抽象工廠模式？ 簡單來說，抽象工廠模式就是提供一個介面，讓你可以建立一整系列相關的產品，而不需要關心產品具體的實作方式。
舉個例子，今天你到 IKEA 買家具，通常會想要一次買齊同一系列的產品，比如椅子、桌子、書架等等。如果這些家具都是同系列，外觀看起來會很搭調，品質和風格也會一致。這樣的一個系列產品，就是抽象工廠想幫你解決的問題！
🧐 抽象工廠模式適合什麼場景？ 以下情境適合用抽象工廠模式解決：
你的產品需要有不同的系列或主題，每個系列內又有多個相關產品。 想要保證同系列產品之間能夠完美兼容。 未來可能需要新增更多產品系列，而希望盡可能避免修改現有程式碼。 🛋️ C# 抽象工廠模式範例 這次，我們就用「家具工廠」作為範例來示範抽象工廠模式的實作吧！
1️⃣ 定義產品介面 /// &amp;lt;summary&amp;gt; /// 椅子介面 /// &amp;lt;/summary&amp;gt; public interface IChair { /// &amp;lt;summary&amp;gt; /// 坐在椅子上 /// &amp;lt;/summary&amp;gt; void SitOn(); } /// &amp;lt;summary&amp;gt; /// 桌子介面 /// &amp;lt;/summary&amp;gt; public interface ITable { /// &amp;lt;summary&amp;gt; /// 使用桌子 /// &amp;lt;/summary&amp;gt; void Use(); } 🛋️ 建立具體產品（現代系列和古典系列） using System; /// &amp;lt;summary&amp;gt; /// 現代風格椅子 /// &amp;lt;/summary&amp;gt; public class ModernChair : IChair { public void SitOn() =&amp;gt; Console.</description></item><item><title>原型模式：複製的藝術</title><link>/ChiYu-Blob/posts/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E8%A4%87%E8%A3%BD%E7%9A%84%E8%97%9D%E8%A1%93/</link><pubDate>Thu, 12 Jun 2025 12:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E8%A4%87%E8%A3%BD%E7%9A%84%E8%97%9D%E8%A1%93/</guid><description>嗨！繼續設計模式系列，這次要介紹的主角是原型模式（Prototype）。聽到「原型」這個詞是不是有點不太確定這到底是什麼？別擔心，我們還是用輕鬆易懂的方式來理解它吧！
🌟 原型模式到底在做什麼？ 原型模式簡單來說就是透過「複製」現有的物件，來建立一個新物件。就像我們常用的「複製貼上」一樣。
比如你去文具店要印名片，你只需要給店員一張原稿，他就能根據這份原稿複製出許多張一模一樣的名片，而不用一張一張重新設計。
🤔 什麼時候該用原型模式？ 物件的建立成本較高（例如需要從資料庫讀取大量資料）。 你要建立的物件跟現有物件差異不大，只需要稍微修改一下就可以使用。 希望降低物件建立時的複雜度與耗時。 📑 C# 原型模式範例 這次我們就以「履歷表複製」作為實際案例，來看看怎麼使用原型模式吧！
📄 定義原型介面 /// &amp;lt;summary&amp;gt; /// 原型介面，提供複製方法 /// &amp;lt;/summary&amp;gt; public interface IResume { /// &amp;lt;summary&amp;gt; /// 複製自身 /// &amp;lt;/summary&amp;gt; IResume Clone(); /// &amp;lt;summary&amp;gt; /// 顯示履歷內容 /// &amp;lt;/summary&amp;gt; void Display(); } 📄 實作具體原型類別 using System; /// &amp;lt;summary&amp;gt; /// 履歷表 /// &amp;lt;/summary&amp;gt; public class Resume : IResume { /// &amp;lt;summary&amp;gt; /// 姓名 /// &amp;lt;/summary&amp;gt; public string Name { get; set; } /// &amp;lt;summary&amp;gt; /// 工作經驗 /// &amp;lt;/summary&amp;gt; public string Experience { get; set; } public Resume(string name, string experience) { Name = name; Experience = experience; } /// &amp;lt;summary&amp;gt; /// 複製自身 /// &amp;lt;/summary&amp;gt; public IResume Clone() { // 直接淺層複製即可 return (IResume)this.</description></item><item><title>建造者模式：一步步完成複雜任務</title><link>/ChiYu-Blob/posts/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%80%E6%AD%A5%E6%AD%A5%E5%AE%8C%E6%88%90%E8%A4%87%E9%9B%9C%E4%BB%BB%E5%8B%99/</link><pubDate>Thu, 12 Jun 2025 13:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%80%E6%AD%A5%E6%AD%A5%E5%AE%8C%E6%88%90%E8%A4%87%E9%9B%9C%E4%BB%BB%E5%8B%99/</guid><description>哈囉各位朋友們～今天我們繼續設計模式之旅，來聊聊 建造者模式（Builder） 吧！
🌟 建造者模式是什麼？ 簡單地說，建造者模式就是將一個複雜產品的建構過程拆分成幾個獨立的步驟，然後逐步組裝起來。
你可以想像去 Subway 點三明治：店員會一步一步詢問你想加什麼食材，麵包種類、起司、蔬菜、醬料……最後做出你最愛的那個獨特三明治。這個點餐流程就有點像建造者模式的概念。
透過建造者模式，你可以有系統地建立出不同組合的複雜產品，並且輕鬆管理每一個步驟。
🤔 什麼時候要用建造者模式？ 產品建立過程複雜，有許多可變步驟或選項。 想要明確區分物件的構建步驟與產出的物件。 未來可能會新增更多的建構方式，但不想更動產品本身。 🥪 C# 建造者模式範例 我們就用「三明治店」當作實際範例，讓你馬上理解這個模式吧！
🥖 首先定義產品類別 using System; using System.Collections.Generic; /// &amp;lt;summary&amp;gt; /// 三明治產品 /// &amp;lt;/summary&amp;gt; public class Sandwich { /// &amp;lt;summary&amp;gt; /// 麵包種類 /// &amp;lt;/summary&amp;gt; public string Bread { get; set; } /// &amp;lt;summary&amp;gt; /// 起司種類 /// &amp;lt;/summary&amp;gt; public string Cheese { get; set; } /// &amp;lt;summary&amp;gt; /// 蔬菜配料 /// &amp;lt;/summary&amp;gt; public List&amp;lt;string&amp;gt; Veggies { get; set; } = new List&amp;lt;string&amp;gt;(); /// &amp;lt;summary&amp;gt; /// 醬料 /// &amp;lt;/summary&amp;gt; public string Sauce { get; set; } /// &amp;lt;summary&amp;gt; /// 顯示三明治內容 /// &amp;lt;/summary&amp;gt; public void Display() { Console.</description></item><item><title>介面卡模式：讓不相容也能合作</title><link>/ChiYu-Blob/posts/%E4%BB%8B%E9%9D%A2%E5%8D%A1%E6%A8%A1%E5%BC%8F%E8%AE%93%E4%B8%8D%E7%9B%B8%E5%AE%B9%E4%B9%9F%E8%83%BD%E5%90%88%E4%BD%9C/</link><pubDate>Thu, 12 Jun 2025 14:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E4%BB%8B%E9%9D%A2%E5%8D%A1%E6%A8%A1%E5%BC%8F%E8%AE%93%E4%B8%8D%E7%9B%B8%E5%AE%B9%E4%B9%9F%E8%83%BD%E5%90%88%E4%BD%9C/</guid><description>哈囉大家！今天我們要介紹的設計模式是：介面卡模式（Adapter），又叫做轉接器模式。
🌟 介面卡模式（Adapter）到底在做什麼？ 就像生活中的轉接頭，它能讓本來不相容的介面順利溝通。在軟體開發裡，Adapter 模式同樣扮演橋樑角色，讓舊有系統與新系統或外部套件能順利合作。
🤔 什麼時候適合用 Adapter？ 既有系統或類別的介面與你需要的不相容。 想使用外部套件，但介面不同，無法直接套用。 希望在不修改既有程式碼的前提下解決介面不合的問題。 🔌 C# Adapter 模式範例 我們以「充電器轉接頭」的例子來說明介面卡模式。
🔋 既有不相容的類別 using System; /// &amp;lt;summary&amp;gt; /// 現有的歐洲插座 /// &amp;lt;/summary&amp;gt; public class EuropeanSocket { public void SpecificRequest() =&amp;gt; Console.WriteLine(&amp;#34;使用歐洲規格的插座&amp;#34;); } 🔋 定義目標介面 /// &amp;lt;summary&amp;gt; /// 台灣插頭介面 /// &amp;lt;/summary&amp;gt; public interface ITaiwanPlug { /// &amp;lt;summary&amp;gt; /// 連接插座 /// &amp;lt;/summary&amp;gt; void Request(); } 🔌 建立介面卡 /// &amp;lt;summary&amp;gt; /// 介面卡：讓歐洲插座能用於台灣插頭 /// &amp;lt;/summary&amp;gt; public class PlugAdapter : ITaiwanPlug { private EuropeanSocket _europeanSocket; public PlugAdapter(EuropeanSocket socket) { _europeanSocket = socket; } public void Request() { // 透過轉接頭呼叫原本的歐洲規格插座 _europeanSocket.</description></item><item><title>橋接模式：抽象與實作分離</title><link>/ChiYu-Blob/posts/%E6%A9%8B%E6%8E%A5%E6%A8%A1%E5%BC%8F%E6%8A%BD%E8%B1%A1%E8%88%87%E5%AF%A6%E4%BD%9C%E5%88%86%E9%9B%A2/</link><pubDate>Thu, 12 Jun 2025 15:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E6%A9%8B%E6%8E%A5%E6%A8%A1%E5%BC%8F%E6%8A%BD%E8%B1%A1%E8%88%87%E5%AF%A6%E4%BD%9C%E5%88%86%E9%9B%A2/</guid><description>哈囉大家～我們繼續來探索設計模式的世界吧！今天要介紹的是一個聽起來可能有點陌生，但其實很實用的設計模式：橋接模式（Bridge）。
🌟 橋接模式是什麼？ 橋接模式將抽象部分和實作部分分離，讓它們可以獨立變化。想像遙控器與電視：不希望為每種遙控器和電視的組合都寫一次程式碼，這時就能運用橋接模式。
🤔 什麼時候適合用橋接模式？ 避免抽象和實作之間產生過多耦合。 有多個維度需要獨立擴充。 想降低程式複雜度，避免類別過多。 📺 C# 橋接模式範例 以「遙控器控制電視」為例說明。
📡 建立實作介面（電視） /// &amp;lt;summary&amp;gt; /// 電視實作介面 /// &amp;lt;/summary&amp;gt; public interface ITV { void On(); void Off(); void SetChannel(int channel); } 📺 建立具體實作 using System; /// &amp;lt;summary&amp;gt; /// Sony 電視 /// &amp;lt;/summary&amp;gt; public class SonyTV : ITV { public void On() =&amp;gt; Console.WriteLine(&amp;#34;Sony 電視開機&amp;#34;); public void Off() =&amp;gt; Console.WriteLine(&amp;#34;Sony 電視關機&amp;#34;); public void SetChannel(int channel) =&amp;gt; Console.WriteLine($&amp;#34;Sony 電視設定頻道：{channel}&amp;#34;); } /// &amp;lt;summary&amp;gt; /// Samsung 電視 /// &amp;lt;/summary&amp;gt; public class SamsungTV : ITV { public void On() =&amp;gt; Console.</description></item><item><title>組合模式：樹狀結構的好幫手</title><link>/ChiYu-Blob/posts/%E7%B5%84%E5%90%88%E6%A8%A1%E5%BC%8F%E6%A8%B9%E7%8B%80%E7%B5%90%E6%A7%8B%E7%9A%84%E5%A5%BD%E5%B9%AB%E6%89%8B/</link><pubDate>Thu, 12 Jun 2025 16:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E7%B5%84%E5%90%88%E6%A8%A1%E5%BC%8F%E6%A8%B9%E7%8B%80%E7%B5%90%E6%A7%8B%E7%9A%84%E5%A5%BD%E5%B9%AB%E6%89%8B/</guid><description>哈囉大家，歡迎繼續探索設計模式之旅！今天要介紹的是一個既實用又好理解的設計模式：組合模式（Composite）。
🌟 組合模式是什麼？ 組合模式讓你能將物件組織成樹狀結構，表示「整體—部分」的層次關係。像資料夾裡有資料夾、檔案又放在資料夾中，這正是組合模式的典型應用。
🤔 什麼時候適合用組合模式？ 需要表示物件的「整體—部分」階層。 想要用一致的方式處理個別物件和物件群組。 希望簡化客戶端程式碼，不必區分個體與集合的處理邏輯。 📁 C# 組合模式範例 用「檔案系統」來示範組合模式。
📄 建立抽象組件介面 /// &amp;lt;summary&amp;gt; /// 抽象檔案系統元件 /// &amp;lt;/summary&amp;gt; public interface IFileSystemComponent { /// &amp;lt;summary&amp;gt; /// 以縮排方式顯示結構 /// &amp;lt;/summary&amp;gt; void Display(int depth); } 📁 建立樹枝構件（資料夾） using System; using System.Collections.Generic; /// &amp;lt;summary&amp;gt; /// 資料夾 /// &amp;lt;/summary&amp;gt; public class Folder : IFileSystemComponent { private string _name; private List&amp;lt;IFileSystemComponent&amp;gt; _components = new List&amp;lt;IFileSystemComponent&amp;gt;(); public Folder(string name) { _name = name; } /// &amp;lt;summary&amp;gt; /// 新增子元件 /// &amp;lt;/summary&amp;gt; public void Add(IFileSystemComponent component) { _components.</description></item></channel></rss>