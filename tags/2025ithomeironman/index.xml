<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>2025iThomeIronman on ChiYu Code Journey</title><link>/ChiYu-Blob/tags/2025ithomeironman/</link><description>Recent content in 2025iThomeIronman on ChiYu Code Journey</description><generator>Hugo -- gohugo.io</generator><language>zh-TW</language><lastBuildDate>Sat, 20 Sep 2025 00:00:00 +0800</lastBuildDate><atom:link href="/ChiYu-Blob/tags/2025ithomeironman/index.xml" rel="self" type="application/rss+xml"/><item><title>Day 1: 【啟程】嘿，AI！我們來做個網站，但這次，我們約法三章</title><link>/ChiYu-Blob/posts/2025ithomeironmanday1/</link><pubDate>Wed, 20 Aug 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday1/</guid><description>Day 0: 【啟程】嘿，AI！我們來做個網站，但這次，我們約法三章 嘿，大家好啊！我是 ChiYu，也可以叫我 Eric。
寫了五年的 Code，平常都在跟 .Net 還有 Azure 打交道。簡單說，就是個靠鍵盤吃飯的工程師啦。去年有參賽，但中途忘記發文中斷!!! 希望今年能培養好習慣每天準時一篇不斷更!!!
這趟旅程，是為誰準備的？ 在開始之前，我想先說說，這系列文章是為誰而寫的。
你可能完全沒有程式背景，但對現在最紅的 Vibe Coding 充滿好奇嗎？你是不是也想跟上這波 AI 浪潮，試著自己動手做點東西，甚至想成為一名開發者呢？
如果答案是「YES」，那這系列文章就是為你量身打造的！
我們不只玩 Vibe Coding，我更希望在過程中，帶你認識一些重要的「開發觀念」。像是什麼是「前端」、「後端」？什麼是「API」？版本要怎麼控制？這些在專業開發中一定會用到的術語和工作流程，我會用最白話的方式，融入到我們的實作裡。
所以，別擔心自己是「程式小白」。跟著我，我們一步一步來，不只做出一個酷專案，更要幫你打下成為開發者的堅實基礎。
那個…我只是想要一台腳踏車，你給我一艘航空母艦幹嘛？ 身為工程師，有新玩具當然會想要跟著玩看看，但純粹的 Vibe Coding 下去，到底會得到什麼？
我的故事是這樣的：我想說來做個最經典最常見的「待辦事項清單 (Todo List)」練練手感。就對 AI 下了一個超簡單的指令：「幫我做個 Todo List 網站，要有CRUD的功能，並且想要一個簡約的UI，我希望專案要越完整越好。」
那時候我心裡想的超單純：啊不就一個 HTML，裡面塞一點點 JavaScript 就搞定了嗎？簡單、好懂、我自己要改也方便。
結果呢？AI 老兄一頓操作猛如虎，給我生出了一整個專案包。我點開資料夾，下巴直接掉下來。哇靠，這是怎樣？React、Node.js、Express、MongoDB……全家餐都來了！
老實說，這 App 能跑，但感覺完全歪掉了。我只是想要一台腳踏車，結果 AI 給了我一艘航空母艦。這要我怎麼騎……啊不是，這已經超出我所了解與熟悉的範圍，且專案規模整個失控！會導致這樣的原因有各種可能，可能是我的Prompt太過鬆散，但又出現了這個「專案要越完整越好」這個關鍵字，也可能是AI自己異想天開等等。出現這種「技術奇觀」讓我意識到，完全放任的 Vibe Coding 真的很容易失控，變成一個你根本不想碰的燙手山芋。
而且老實說，有時候在社群上看到一些分享，真的會替他們頭痛，曾看到有人在分享，他的朋友VibeCoding出了一個購物網站，但登入系統不論怎麼打密碼都可以登入，或是開發出的網站把所有應加密資訊顯露出去。
我完全懂拿到新玩具那種興奮感，AI 工具也確實是開發上的一大福音，而且也讓許多程式小白能體會成為一名工程師的感覺!! 但問題出在「盲目相信」。當專案一搞大，你很快會發現：東西越來越難改、AI 給的專案根本跑不起來、就算跑起來了，噴出來的 BUG 你也看不懂。更慘的是，你叫 AI 修，它修完又生出新的 BUG，最後就卡在一個無限迴圈裡動彈不得。這對沒有太多開發經驗的人來說，真的是個超級大坑。
為魔法裝上韁繩：左手藍圖，右手魔法 所以咧？難道就要這樣放棄 AI 這個神隊友嗎？當然不行！
這就像拿到一把絕世神兵，你不能因為它太利就把它丟掉，而是要學會怎麼駕馭它。所以我就開始找方法，到底要怎麼做才能讓 AI 乖乖聽話，然後我找到了這個說新不新說舊不舊的開發法則：</description></item><item><title>Day 2: 【心法篇】開發者的航海圖：什麼是文件驅動開發 (DDD)？</title><link>/ChiYu-Blob/posts/2025ithomeironmanday2/</link><pubDate>Thu, 21 Aug 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday2/</guid><description>嘿，大家好啊！我是 ChiYu。
昨天聊到 AI 開發，一不小心就把小小的「腳踏車」專案搞成一艘「航空母艦」，超頭痛的對吧？這種「AI 太能幹」造成的失控，在 Vibe Coding 的浪潮下，只會越來越常見。這不只是個笑話，它反映了一個深刻的問題：當我們擁有無窮的力量（AI），卻沒有明確的方向時，混亂是必然的結果。
那到底要怎麼辦，才能讓 AI 乖乖聽話，不要自己亂加戲？我們該如何從一個被 AI 牽著鼻子走的「使用者」，蛻變成一個能駕馭 AI 的「指揮家」？
今天就要來分享我的秘密武器，一個能讓你從「玩票」變「專業」的酷東西：文件驅動開發 (Document-Driven Development, DDD)！
我知道，一聽到「文件」兩個字，你可能就想關掉了，感覺超無聊，對吧？先別走！相信我，這東西比你想的有趣多了，它就是我們駕馭 Vibe Coding 這匹野馬最重要的「韁繩」！這不是要你回到寫八股文的老路，而是要教你一種用「文字」來駕馭「程式碼」的現代魔法。
核心精神：「左移」你的思考 (Shift-Left) 在蓋房子前，你會先畫好藍圖，還是直接叫工人來亂蓋一通？當然是先畫藍圖嘛！這個簡單的道理，在軟體開發中卻常常被遺忘。
這在我們寫程式的世界裡，有個很潮的說法叫 「左移」(Shift-Left)。意思就是，把所有燒腦的規劃、設計工作，全部往前挪。這就像規劃一場環島旅行，你不會等到出發當天才在想要去哪裡、住哪裡，對吧？你肯定會提前好幾個禮拜，就把路線、住宿、景點都研究得一清二楚。
為什麼？因為一開始在紙上改個設計，頂多花幾分鐘；等到牆都蓋好了才說要改，那可就得花好幾天敲掉重來，不只工人想罷工，連設計師都會想掐死你！修改的成本，隨著時間往右，是呈指數級暴增的，這不只是時間成本，更是團隊士氣的巨大耗損。一個小小的早期決策失誤，到後期可能會演變成需要數週才能修復的**「技術債」**，那種感覺真的糟透了。
DDD 就是這個概念的最佳實踐，先想清楚，再動手！
所以，DDD 到底在幹嘛？ 所以說，DDD 到底是在幹嘛？超簡單，就是一個規矩：
沒文件，就沒有 Code！
這聽起來可能有點極端，但它的核心是一種紀律，一種能帶來巨大回報的紀律。整個開發流程大概是這樣：
先動腦，再動手：有任何新想法？第一步絕對不是打開 VS Code，而是先把它跟 AI「聊」成一份具體的規格文件。這個「聊」的過程，其實就是在強迫我們把腦中模糊不清的想法，具象化成有邏輯、有結構的文字。很多時候，光是在這個階段，你就會發現自己想法中的矛盾與漏洞。 在文件上吵架：所有的討論、修改，都在文件上搞定。這是一種健康的吵架！把所有可能的誤解、模糊地帶，在程式碼誕生前就全部解決掉。在文件上吵架，成本是零；但在程式碼上吵架，成本可能就是好幾個工程師好幾天的工時，改文字總比改程式碼便宜吧？ 文件就是聖旨：文件一旦定稿，就是不能亂改的「施工命令單」。它成為了我們後續所有開發工作的唯一依據。這份文件就像是我們與「未來的自己」以及「AI」之間簽訂的一份契約，確保大家永遠在同一個頻道上。 寫 Code 只是翻譯：這時候，寫程式就變得很單純，不再是天馬行空的創作，而是把文件上的東西，有效率地「翻譯」成程式碼而已。開發者的認知負擔被大幅降低，我們可以更專注在如何把程式碼寫得更乾淨、更有效率，而不是一邊寫一邊想「我到底要做什麼來著？」。 面對現實：我知道，你討厭寫文件 好啦，我知道你在想什麼。講到「寫文件」，大概九成的工程師（包括我！）都會翻白眼。心裡想著：
「唉，又來了」「敏捷開發不是說不用寫文件嗎？」「我有這時間不如多寫幾行 Code」。
這真的不是我們的錯！很多人誤解了「敏捷開發」的精神，它強調的是「可工作的軟體 勝於 詳盡的文件」，而不是「不要文件」。一份沒人看的、過時的文件確實是垃圾；但一份能指引方向、建立共識的「活文件」，卻是專案成功的基石。以前寫文件又痛苦又沒用，誰想寫啊？我們都經歷過那種「文件是個謊言」的專案，規格書上寫 A，但程式碼早就改成 B 了，這種文件不如不要有。
但這次，我們不自己動手寫 但！這次完全不一樣了！
我們不用自己一個字一個字地敲文件！
我們要讓 AI 當我們的專屬寫手。我們的工作，從苦哈哈的打字員，升級成動動嘴巴的決策者。開發的瓶頸，不再是我們的打字速度，而是我們思想的清晰度。
說白了，「下指令 (Prompt)」本身，就是一種新時代的「規格設計」啦！ 我們的價值，從「如何實現」，轉變成了「如何清晰地定義問題」。這是一種更高層次的抽象能力，也是未來開發者的核心競爭力。
「好文件」不是廢話文學，而是唯一的真理 既然有 AI 幫忙，我們更應該專注在做出「有用的」文件。這份文件就是我們專案的 「單一真理來源 (Single Source of Truth, SSoT)」，所有人都得聽它的！</description></item><item><title>Day 3: 【工具篇 #1】萬丈高樓平地起：建置本地開發環境</title><link>/ChiYu-Blob/posts/2025ithomeironmanday3/</link><pubDate>Fri, 22 Aug 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday3/</guid><description>安安，我是 ChiYu！
昨天，我們在腦中畫好了宏偉的建築藍圖 (DDD)，確立了「文件驅動開發」這個核心心法。今天，理論課結束，我們要開始動手了！我們將扮演「技師與軍火官」的角色，為接下來的開發大戰，準備好我們最精良的「施工機具」與「建材」。
「工欲善其事，必先利其器」。一個乾淨、強大、順手的開發環境，是所有偉大專案的起點。今天的目標非常明確：手把手帶你完成所有必要的環境安裝，包括 Python、Node.js，以及我們的開發神器 VS Code。
Part 1：我們的「總工具箱」：安裝 Visual Studio Code (VS Code) 在無數的程式碼編輯器中，VS Code 已經成為了現代開發的絕對主流。為什麼？原因很簡單：它免費、開源、速度快、功能強大，而且擁有全世界最豐富的「擴充功能」生態系，可以讓我們把它打造成任何我們想要的樣子。
Step 1：安裝 VS Code
VS Code 官網下載連結：https://code.visualstudio.com/ 請直接前往官網，網站會自動偵測你的作業系統（Windows, Mac, Linux），下載對應的版本，然後像安裝普通軟體一樣，無腦下一步到底就對了。
Step 2：初次見面！認識 VS Code 的介面
當你第一次打開 VS Code，可能會看到一個歡迎畫面。別怕，我們先來認識一下它的幾個主要區域，未來它們會成為你最熟悉的朋友：
左側活動列 (Activity Bar)：最左邊那一排圖示，是你切換不同功能的入口，例如檔案總管、搜尋、原始碼管理（就是 Git）、以及我們待會要安裝的擴充功能。 側邊欄 (Side Bar)：點擊活動列的圖示後，左邊展開的區域就是側邊欄。最常用到的就是「檔案總管」，我們專案的所有資料夾和檔案都會顯示在這裡。 編輯區 (Editor)：中間最大塊的區域，就是我們主要編寫程式碼與文件的地方。 底部面板 (Panel)：下方可以拉開的區域，這裡非常重要，因為它包含了「終端機 (Terminal)」。我們之後所有的魔法指令，都會在這裡詠唱！ Part 2：VS Code 威力升級：必備擴充功能 (Extensions) 如果說 VS Code 是一個功能強大的手機，那「擴充功能」就是上面的 App，能讓你的手機擁有各種超能力。
請在左側活動列找到像「俄羅斯方塊」一樣的圖示，那就是擴充功能的市集。點擊它，然後在搜尋框裡，找到並全部安裝以下幾個我們這次旅程必備的神級外掛：
Python (Microsoft) 這是什麼：微軟官方出品的 Python 語言支援包。 為什麼必裝：裝上它，你的 VS Code 才會真正「看懂」Python。它提供了智慧程式碼提示、自動補全、語法錯誤檢查、除錯等所有核心功能，直接將 VS Code 變身為一個頂級的 Python IDE。 Prettier - Code formatter 這是什麼：你的程式碼專屬造型師。 為什麼必裝：它會在每次存檔時，自動把你的程式碼整理成一個統一、乾淨、漂亮的風格。從此告別為了「兩個空格還是四個空格」而引發的聖戰！ GitLens — Git supercharged 這是什麼：Git 的透視眼鏡。 為什麼必裝：它能讓你直接在程式碼的每一行旁邊，看到這行是誰、在什麼時候修改的，極大地增強了 VS Code 的版本控制能力。 Thunder Client 這是什麼：內建在 VS Code 裡的 API 測試神器。 為什麼必裝：我們之後會用它來測試我們寫好的後端 API，不用再開別的軟體，非常方便。先裝起來放！ Markdown Preview Mermaid Support 這是什麼：讓你的文件活起來的魔法。 為什麼必裝：我們之後會用 Mermaid.</description></item><item><title>Day 4: 【工具篇 #2】程式碼的時光機：Git 與 GitHub 版本控制</title><link>/ChiYu-Blob/posts/2025ithomeironmanday4/</link><pubDate>Sat, 23 Aug 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday4/</guid><description>安安，我是 ChiYu！
昨天，我們扮演了「技師與軍火官」的角色，把我們的駕駛艙 (VS Code) 從毛胚屋打造成了精裝房，並備妥了所有核心的建材與燃料 (Python &amp;amp; Node.js)。
我們的開發環境已經準備就緒，但在我們正式動工、蓋起萬丈高樓之前，還有一件至關重要的事要做：我們需要為我們的建築工地，安裝一套最頂級的「安全監控系統」與「時光倒流機器」。
今天，我們就要來深入軟體開發中最最最重要的觀念——版本控制，並親手設定我們專案的「雲端保險庫」與「時光機總部」：Git 與 GitHub。
Part 1：核心觀念：什麼是「版本控制」？ 在開始操作前，我們先用白話文搞懂什麼是「版控 (版本控制)」。你可以把它想像成玩遊戲時的「存檔」機制。
你在寫報告時，是不是常常會這樣做：企劃書_v1.docx、企劃書_v2_改了標題.docx、企劃書_最終版.docx、企劃書_最終版真的啦.docx？這就是最原始、最土炮的「手動版本控制」。你害怕把東西改壞，所以存了一大堆備份，最後連自己都搞不清楚哪個才是最新的。
而「版本控制系統」就是一個專業、自動化的工具，來幫你優雅地做這件事。它的好處有：
追蹤歷史紀錄：系統會幫你記錄每一次的「存檔」，你可以清楚看到何時、何人、修改了什麼內容。 隨時回到過去：如果不小心把專案改爛了、功能寫壞了，你可以像讀取遊戲存檔一樣，輕鬆回到任何一個過去的版本。 方便多人協作：當很多人一起開發同一個專案時，版控系統能聰明地幫大家整合程式碼，避免互相覆蓋的慘劇。 鼓勵大膽實驗：這是最棒的一點！它讓你可以隨時開一個「平行時空」，在裡面隨便亂搞、嘗試新功能，而完全不用擔心會把主線劇情（主要程式碼）搞砸。 Part 2：釐清工具：Git 與 GitHub 的關係 很多新手會把這兩個搞混，我們用一個簡單的比喻來拆解：
Git - 你的程式碼時光機 它是什麼：Git 是一個「版本控制系統」，是你電腦裡的工具，用來建立「存檔點 (commit)」。 Git 官網：https://git-scm.com/ (建議先下載安裝) GitHub - 你的雲端程式碼基地 它是什麼：GitHub 是一個「提供 Git 託管服務的網站平台」。如果說 Git 是 Word 軟體，那 GitHub 就是 Google Docs。你可以在 GitHub 上建立一個專案倉庫 (Repository)，然後把你用 Git 管理的本地專案，同步一份到這個雲端倉庫裡。 GitHub 官網：https://github.com/ Part 3：最重要的觀念：分支 (Branching) - 你的平行時空 在我們建立倉庫之前，你必須先理解「分支 (Branching)」這個專業開發中最重要的概念。
你可以把你的專案想像成一部電影的「主線劇情」，這條主線就是所謂的 main 分支。main 分支上的程式碼，永遠都必須是最穩定、可以正常運作的版本。</description></item><item><title>Day 5: 【工具篇 #3】終端機裡的魔法：什麼是 Vibe Coding 與 Gemini CLI？</title><link>/ChiYu-Blob/posts/2025ithomeironmanday5/</link><pubDate>Sun, 24 Aug 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday5/</guid><description>安安，我是 ChiYu！
昨天，我們完成了技師的工作，為我們的專案蓋好了雲端機棚 (GitHub)，也把駕駛艙 (VS Code) 裝潢得舒適又專業。硬體設施全部到位，現在，是時候為我們的專案注入真正的「靈魂」了。
今天，我們將迎來本系列第一個令人心跳加速的轉捩點。我們不只要安裝「引擎」，我們還要學會詠唱「魔法的咒語」，真正地與 AI 對話，把我們的意念灌注到終端機之中！準備好迎接你的「魔法覺醒」了嗎？
Part 1：到底什麼是「Vibe Coding」？ 最近你可能常常聽到 Vibe Coding 這個詞，但它到底是什麼意思？
它不是什麼艱深的技術或框架，而是一種徹底顛覆傳統的開發風格或心態。
這徹底顛覆了我們過去學習程式的模式。以前我們學的是機器的**「語法 (Syntax)」，現在我們學的是如何更精準地「表達意圖 (Intent)」**。你的中文能力，從未像此刻一樣，直接與你的生產力掛鉤。
這就像你從一個樂手，變成了一個指揮家。你不用親自演奏每個樂器，你只需要揮舞你的指揮法杖，告訴整個樂團（AI），這一段要「雄壯激昂」、那一段要「溫柔婉約」。你負責定義**「氛圍 (Vibe)」**，AI 負責實現它。
而我們今天要安裝的 Gemini CLI，就是我們的第一支客製化指揮法杖。
Part 2：我們的魔法法杖：Gemini CLI，你的開源 AI 代理人 CLI 的全名是 Command Line Interface (命令列介面)。你不用害怕這個詞，它指的就是我們在 VS Code 裡打開的那個黑黑的、看起來很像駭客電影的「終端機」視窗。
我們要介紹的 gemini-cli，根據 Google 官方的說法，它不只是一個工具，更是一個**「開源的 AI 代理人 (Open Source AI Agent)」**。這代表它是一個住在你終端機裡的智慧夥伴，可以幫你讀取檔案、存取網路、甚至與其他工具串接，來完成更複雜的任務。
官方參考資料 對 gemini-cli 有興趣的讀者，可以直接參考它的官方 GitHub 倉庫與 Google 官方部落格文章：
GitHub: https://github.com/google-gemini/gemini-cli Google Blog: https://blog.google/intl/zh-tw/products/cloud/gemini-cli-your-open-source-ai-agent/ Part 3：安裝與授權：法杖的鑄造與認主 好的，讓我們開始進行法杖的「鑄造與附魔」！
Step 1：前置作業 - 準備 Node.</description></item><item><title>Day 6: 【文件 #1】專案的靈魂：用 Gemini CLI 生成「專案章程」</title><link>/ChiYu-Blob/posts/2025ithomeironmanday6/</link><pubDate>Mon, 25 Aug 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday6/</guid><description>安安，我是 ChiYu！
經過了五天的「前置作業」，我們的駕駛艙 (VS Code)、引擎 (Python)、魔法法杖 (Gemini CLI) 全都準備就緒了。是不是已經手癢難耐，準備大展身手了？
別急！還記得我們的核心心法嗎？先有藍圖，再有魔法。
今天，我們就要正式啟動專案，打響「左手藍圖」的第一槍！我們將完全在 VS Code 終端機內，為我們的太空船，設定好最初也最重要的航行座標。我們要來產出整個專案中，位階最高、最重要的一份文件——專案章程 (Project Charter)。
Part 1：什麼是「專案章程」？它到底有多重要？ 「專案章程」…這名字聽起來好像很厲害、很嚴肅，但你別被它嚇到。
你可以把它想像成這個專案的「出生證明」或「身分證」。它用最精簡的方式，回答了幾個最根本的問題：我們是誰？我們要去哪裡？我們要做什麼？以及，我們「不做」什麼？
在團隊開發中，這份文件至關重要，因為它是：
建立共識的基石：專案最怕的就是「我以為我們是要做A，結果你做的是B」。專案章程是第一份讓所有人（老闆、PM、工程師）都點頭同意的文件，確保大家從第一天起，對專案的想像就是一致的。 正式啟動的號角：在企業裡，一份被簽核的專案章程，代表著這個專案被「正式授權」。對我們來說，完成這份文件，就像是為自己舉辦一個開工儀式，代表我們對這個專案的承諾，從此刻起，它不再只是個空想。 未來決策的北極星：開發過程中，我們肯定會冒出各種新點子。這時候，我們就可以拿出專案章程來檢視：「這個新點子，符合我們的『願景』和『範圍』嗎？」它能幫助我們抵抗「範圍潛變 (Scope Creep)」這個專案的無聲殺手，確保我們能聚焦在核心價值上。 總之，在一頭熱地栽進去開發前，先把這份文件定義清楚，就像開車前先在 Google Maps 設定好目的地。它就是我們後續所有文件的最高指導原則。
Part 2：實戰開始：在終端機中從無到有 接下來，就是見證奇蹟的時刻。我們將把腦中那個非常模糊的想法，透過與 Gemini CLI 的對話，直接在我們的專案中，生成一份專業文件。
魔法的基礎：什麼是提示工程 (Prompt Engineering)？ 在我們詠唱第一個咒語之前，我們先來學習「咒語的文法」。與 AI 溝通，是一門藝術，也是一門科學，這就是所謂的「提示工程 (Prompt Engineering)」。
你可以把它想像成你在對一個法力無邊的「許願精靈」下指令。
糟糕的許願：「我想要變有錢！」 -&amp;gt; 精靈可能會給你一張樂透彩券，或是讓你家地下冒出處理起來很麻煩的石油。 優秀的許願：「請在今天下午三點前，將一百萬新台幣，以合法的銀行轉帳方式，存入我指定的銀行帳戶。」 看到了嗎？一個好的 Prompt，就像一個好的許願，它清晰、具體、有邊界、有上下文。這能大幅降低 AI「理解錯誤」或「自由發揮」的機率。
根據業界的最佳實踐（例如 OpenAI 的官方文件），一個高品質的 Prompt 通常包含幾個關鍵要素，而這也正是我們接下來所有咒語的設計核心：
1. 角色扮演 (Role-playing)：為 AI 賦予專家身份 這是最重要，也最容易被忽略的一點。在指令的開頭，先告訴 AI 他「是誰」。這會讓模型進入一個特定的知識領域與思考模式，產出的內容會更專業、更貼近你的需求。
不好的指令: 幫我寫一個 Python 函式來驗證電子郵件。 好的指令: 你是一位資深的 Python 開發者，專長是後端開發與資料驗證。請幫我寫一個符合 RFC 5322 標準的 Python 函式來驗證電子郵件.</description></item><item><title>Day 7: 【文件 #2】使用者的旅程：用 Gemini CLI 描繪「使用者故事」</title><link>/ChiYu-Blob/posts/2025ithomeironmanday7/</link><pubDate>Tue, 26 Aug 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday7/</guid><description>安安，我是 ChiYu！
昨天，我們確立了專案的「北極星」——專案章程，並在 GitHub 上留下了第一個不可磨滅的印記。如果說昨天的「專案章程」是我們的**「戰略地圖」，告訴我們為何而戰、要攻下哪座城池。那今天，我們就要化身為「戰場指揮官」，繪製出士兵（使用者）在戰場上的具體「戰術路線圖」**。
今天，我們將完全在終端機內，描繪這張地圖，產出兩份從「使用者視角」出發的關鍵文件：使用者故事 (User Stories) 與 使用者流程圖 (User Flowchart)。
Part 1：什麼是「使用者故事」？ 別被「故事」這兩個字嚇到，我們不是要寫小說。使用者故事其實是一種在敏捷開發中，用來描述需求的強大工具。
你可以把它想像成你在跟咖啡師點餐。你不會直接跟他說「給我咖啡因、水和牛奶的混合物」，你會說：
身為 一個想提神的顧客 (使用者)，
我想要 一杯大杯的熱拿鐵 (功能)，
以便 讓我有精神撐過下午的會議 (價值)。
看到這個格式的威力了嗎？它強迫我們停止用「工程師的語言」思考，而是用「使用者的語言」思考。一個好的使用者故事，包含了經典的「3C」要素：
Card (卡片)：故事本身簡短扼要，像一張可以貼在牆上的便利貼。 Conversation (對話)：它不是一份冰冷的規格書，而是一個「邀請」，邀請你和 AI 針對這個需求進行對話，釐清細節。 Confirmation (確認)：這是最關鍵的一步！每個故事都應該伴隨著**「驗收條件 (Acceptance Criteria)」**，也就是一個非黑即白、不容狡辯的簡單清單，用來確認「怎樣才算完成了這個故事」。 Part 2：什麼是「使用者流程圖」與 Mermaid.js？ 如果說使用者故事是描述一個個「單點需求」，那「使用者流程圖」就是把這些點串連起來的「路線圖」。它用視覺化的方式，呈現使用者為了完成一個特定目標所需要經過的完整路徑。
一張圖勝過千言萬語，但一張圖配上精闢的文字解說，才能確保所有人對這千言萬語的理解是完全一致的。
而 Mermaid.js 就是一個能讓我們用「文字」來畫流程圖的神奇工具。因為是純文字，所以我們可以輕鬆地用 Git 進行版本控制，這對開發者來說再方便不過了！
Mermaid的語法我暫時不花太多篇幅作介紹，感覺要介紹可以花一天的文章篇幅來完整介紹，在系列文章結束後我再來補充好了(挖坑給自己)！畢竟Mermaid.js 真的有他非常好用的地方，語法簡單直觀、便於版本控制、易於整合與維護而且還跨平台!!!
Part 3：實戰開始：在終端機中扮演我們的產品經理 好了，理論課結束，讓我們再次召喚 Gemini CLI，請它繼續扮演我們的產品經理。
Step 1：詠唱我們的魔法 (Craft the Prompt) 我們要讓 Gemini 直接讀取我們本地的「專案章程」，來確保我們的工作是基於最新、最正確的藍圖。
打開 VS Code 終端機，詠唱我們的第二個「文件生成咒語」：
【魔法詠唱：我們的 Prompt】 # 角色 (Role) 你是一位頂尖的產品經理 (PM)，擁有豐富的敏捷開發經驗，擅長將高階的專案目標，轉化為清晰、可執行的使用者故事與流程。你的產出兼具使用者同理心與技術可行性。 # 目標 (Objective) 我的目標是讓你將一份高階的「專案章程」分解為開發團隊可以立即投入工作的敏捷開發產物 (Agile Artifacts)，包含使用者故事和流程圖。 # 上下文 (Context) - **唯一的真相來源 (Single Source of Truth)**: 請將 @docs/PROJECT_CHARTER.</description></item><item><title>Day 8: 【文件 #3】系統的心臟：用 Gemini CLI 設計「軟體架構文件」</title><link>/ChiYu-Blob/posts/2025ithomeironmanday8/</link><pubDate>Wed, 27 Aug 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday8/</guid><description>安安，我是 ChiYu！
前兩天，我們完成了專案的「出生證明」(專案章程) 和「使用者地圖」(使用者故事)。我們現在非常清楚「為誰而做」以及「他們想做什麼」。
今天，我們要戴上「工程安全帽」，從使用者的世界暫時抽離，化身為擘劃未來的 「系統架構師」。我們要進行一次視角切換，從關注「人」，轉向關注「系統」，回答一個核心問題：「為了滿足這些使用者故事，我們的系統內部應該長什麼樣子？」
我們今天要畫的，不僅是建築的藍圖，更是未來系統穩定、高效、可擴展的基石。
Part 1：偉大的分工：什麼是「前後端分離」？ 在我們深入探討具體的架構之前，你必須先理解現代網頁開發中最核心的一個思想——前後端分離 (Frontend-Backend Separation)。
讓我們再次回到「經營一家餐廳」的比喻。一家餐廳，最基本的劃分就是「外場」與「內場」。
外場 (前端 Frontend)：這是顧客能直接接觸到的地方。包含了華麗的裝潢、舒適的座位、精美的菜單、以及親切的服務生。它的唯一職責，就是提供給顧客最棒的「用餐體驗」。在我們的專案中，這對應的就是使用者在瀏覽器上看到的所有畫面，由 HTML, CSS, JavaScript 這三劍客負責打造。 內場 (後端 Backend)：這是神秘的廚房，顧客看不見也摸不著。廚師們在這裡處理訂單、烹飪食物、管理食材庫存。它的唯一職責，就是處理所有核心的「商業邏輯」與「數據管理」。在我們的專案中，這對應的就是運行在遠端伺服器上的 Python + Flask 應用程式。 「前後端分離」就是一個嚴格的規定：外場的人不准進内場，內場的人也不准跑去外場。他們之間唯一的溝通管道，就是透過「服務生」來傳遞標準化格式的「點餐單」與「餐點」。
Part 2：溝通的契約：什麼是 API？ 這個至關重要的「服務生」，就是我們常說的 API (Application Programming Interface)。
API 的本質，就是一份前端與後端之間，神聖不可侵犯的「溝通契約」。這份契約詳細地定義了：
前端可以要求後端做哪些事（例如：查詢所有習慣、新增一筆紀錄）。 前端在提出要求時，必須提供哪些資訊（例如：新增習慣時要給習慣名稱）。 後端在完成任務後，承諾會回傳什麼格式的資料給前端。 有了這份契約，前端的「室內設計師」和後端的「大廚」就可以完全獨立、並行地工作，只要最後雙方都遵守契約，就能完美地將各自的成果組合起來。這份詳細的契約（Web API 規格書），將會是我們在 Day 10 的主題。
Part 3：設計我們的廚房：Flask 後端 API 伺服器架構 好了，理解了前後端的分工與 API 的角色後，現在我們可以聚焦在「如何設計我們的廚房 (後端)」了。
隨著我們的餐廳生意越來越好，菜色越來越多（功能越來越複雜）時，如果還把所有廚師都擠在一個廚房裡 (app.py)，肯定會天下大亂。
因此，我們需要升級成「中央廚房」模式。我們會把廚房細分成「冷盤區」、「熱炒區」、「甜點區」，每個區域有專門的師傅負責。這在我們的後端專案中，就是所謂的**「模組化 (Modularity)」**。
在 Flask 框架中，實現模組化的最佳實踐，就是使用**「藍圖 (Blueprints)」**。你可以把一個 Blueprint 想像成一個獨立的「功能模組包」。例如，我們可以規劃一個 habits.py 檔案，裡面專門放所有跟「習慣」相關的 API 路由。</description></item><item><title>Day 9: 【文件 #4】數據的家：用 Gemini 規劃「資料庫綱要」</title><link>/ChiYu-Blob/posts/2025ithomeironmanday9/</link><pubDate>Thu, 28 Aug 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday9/</guid><description>安安，我是 ChiYu！
昨天，我們化身為架構師，完成了專案的**「系統藍圖」**(軟體架構文件)，釐切了前台、後台、API 與資料庫之間的分工合作關係。
我們的餐廳藍圖畫好了，下一步，就是要來仔細規劃我們儲放所有食材的「食材庫」。在軟體世界裡，這個角色就是由**「資料庫 (Database)」來扮演。今天，我們將化身為「數據的守護者」——資料庫管理員 (DBA)，與 Gemini 一同規劃我們專案的「資料庫綱要 (Database Schema)」**！
Part 1：什麼是「資料庫 (Database)」？ 對於新手來說，你可以把資料庫想像成一個擁有超能力的、極度嚴謹的 Excel 表格。它是一個專門用來「結構化儲存」資訊的系統，有非常明確的規則，來確保我們存進去的資料是乾淨、有組織、且易於查詢的。
要理解資料庫，你只需要知道幾個核心概念：
資料表 (Table)：就像 Excel 裡的一個工作表 (Sheet)。 欄位 (Column/Field)：就像工作表裡的第一行標題。 紀錄 (Row/Record)：工作表裡的一行資料。 綱要 (Schema)：這就是整個資料庫的「設計藍圖」。它不僅定義了有哪些資料表、每張表有哪些欄位，更重要的是，它定義了規則： 資料型態 (Data Types)：規定了每個欄位只能存放哪種類型的資料（數字、文字、日期等）。 約束 (Constraints)：規定了資料必須遵守的規則，例如 email 欄位的內容必須是獨一無二的 (UNIQUE)。 關聯 (Relationships)：定義了表與表之間的連結關係。 我們今天就是要設計這份包含所有規則的「綱要 (Schema)」。
Part 2：資料庫的兩大門派：SQL vs. NoSQL 在選擇具體的資料庫之前，你需要知道，當今的資料庫世界主要有兩大門派：SQL (關聯式資料庫) 和 NoSQL (非關聯式資料庫)。
SQL 像 Excel 表格，結構嚴謹，資料之間關係明確，可靠性強。 NoSQL 像一個自由的資料夾，結構靈活彈性，擴展性極強。 對於我們的「習慣養成日誌」專案來說，要儲存的資料關係非常明確：一個「使用者」可以擁有多個「習慣」，一個「習慣」可以擁有多筆「打卡紀錄」。這種層次分明、井然有序的關係，正是 SQL 資料庫最擅長處理的。因此，選擇 SQL 陣營是我們最穩健的選擇。
Part 3：選擇我們的資料庫：為什麼是 SQLite？ 在 SQL 這個門派裡，有許多知名的武林高手。但對於新手和中小型專案，我們選擇一個更輕巧、更友善的方案：SQLite。
選擇 SQLite 的理由非常充分：零設定、單一檔案、Python 內建支援。它能讓你專注在「資料庫設計」本身，而不用分心去處理複雜的環境設定，是學習資料庫觀念的最佳起點。</description></item><item><title>Day 10: 【文件 #5】溝通的契約：用 Gemini 撰寫「Web API 規格書」</title><link>/ChiYu-Blob/posts/2025ithomeironmanday10/</link><pubDate>Fri, 29 Aug 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday10/</guid><description>安安，我是 ChiYu！
昨天，我們完成了餐廳的「食材倉庫」設計圖——資料庫綱要。至此，我們專案的願景、使用者需求、系統架構、數據儲存方式，都已經有了明確的定義。
我們的餐廳藍圖（架構）和食材倉庫（資料庫）都設計好了。下一步，就是要交給「服務生 (API)」一份精準的「菜單」，讓他知道如何跟廚房溝通，顧客可以點哪些菜，以及餐點會以什麼形式送上。
這份「菜單」，就是我們今天要產出的，後端藍圖的最後一塊拼圖——Web API 規格書。
Part 1：什麼是「API 規格書」？ 我們在 Day 7 提過，API 是前端（前台）與後端（廚房）之間的溝通橋樑。而「API 規格書」就是一份極其嚴謹、毫無模糊空間的技術文件，如同法律契約一般，精準地定義了前端與後端之間每一次互動的細節。
什麼是 OpenAPI 3.0 (Swagger)？ 為了避免每家公司都用自己的格式來寫規格書，業界發展出了一套公認的標準，其中最流行的就是 OpenAPI 3.0（前身就是大名鼎鼎的 Swagger）。它用 YAML 或 JSON 格式，提供了一套完整的語法規則來描述 API。YAML 格式因其對人類更友善、更易讀的特性而廣受歡迎。
使用 OpenAPI 的最大好處是，有非常多工具可以讀取這份文件，自動生成可以互動的 API 文件網站、不同語言的客戶端程式碼、甚至是伺服器端的程式碼骨架！這也體現了一種專業的「設計優先 (Design-First)」開發哲學——我們先把契約定義好，再動手寫程式，這與我們系列「藍圖優先」的核心思想不謀而合。
Part 2：實戰開始：讓 Gemini 成為我們的 API 設計專家 好了，讓我們來設計這份最重要的契約吧！
Step 1：詠唱我們的魔法 (Craft the Prompt) API 的設計，需要通盤考慮專案的目標、使用者故事、系統架構、以及資料庫綱要。所以這次，我們要拿出至今為止的所有成果，全部餵給 Gemini！
打開 VS Code 終端機，詠唱我們至今為止最複雜的一個「文件生成咒語」：
【魔法詠唱：我們的 Prompt】 # --------------------------------------------------------------------------- # PROMPT FOR GEMINI: Production-Ready OpenAPI 3.0.3 Specification Generator # --------------------------------------------------------------------------- # 角色 (Role) 你是一位頂尖的後端工程師與 API 設計專家，精通 RESTful API 設計原則與 OpenAPI 3.</description></item><item><title>Day 11: 【心法 #2】透過AI幫我們生成Prompt</title><link>/ChiYu-Blob/posts/2025ithomeironmanday11/</link><pubDate>Sat, 30 Aug 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday11/</guid><description>安安，我是 ChiYu！
昨天，我們終於完成了上半部分的最後一份文件！可以正式進入開發的環節！但在進入開發環節前，我想要回頭再詳細聊一下 Ai Prompt Engineering。
我相信大家在經歷了前面五天、一連串燒腦的文件生成後，肯定會有點累，心中可能還會冒出一個疑問：
「ChiYu 你每次給的 Prompt 都又臭又長，結構還那麼複雜，每次都要自己想，也太累了吧？」
你說的沒錯！所以今天，我們要稍微轉換一下節奏，暫時不推進度。我們要來一場「魔法師的幕後揭秘」，聊聊我是如何生成那些看似複雜、但效果奇佳的完整 Prompt 的！
Part 1：為什麼現在才說？先學會走路，再學會開跑車 在揭曉我的秘密武器之前，我想先解釋一下，為什麼我刻意把這個技巧，留到今天才告訴大家。
過去五天，我讓大家親手去「感受」一個 Prompt 的好壞。你們親自體驗了從一個模糊的想法，到一個結構化的指令；從 AI 給出不甚滿意的答案，到透過迭代優化，最終得到專業產出的完整過程。
這個 「手動」的過程至關重要。因為它能讓你建立起對**「好 Prompt」的品味與鑑賞力**。
如果我第一天就教你開跑車，你可能會因為速度太快而看不清沿途的風景，甚至直接翻車。只有當你親自走過一遍崎嶇的山路，你才會知道跑車的懸吊有多重要、輪胎該怎麼選。
現在，你已經是一位合格的**「Prompt 手工藝人」了。是時候，為你配備一台「Prompt 工業母機」**了！
Part 2：我們的「靈感實驗室」：Gemini Web UI 你可能又會問：「咦？我們不是說好要完全在終端機裡 Vibe Coding 嗎？怎麼又回到瀏覽器了？」
問得好！一個專業的開發者，懂得為不同的任務，選擇最適合的工具。
Gemini CLI：是我們的**「生產線」**。它追求的是效率、精準、可重複。當我們心中已經有了明確的目標時（例如：根據 @API_SPEC.yml 生成程式碼），CLI 是我們的最佳選擇。 Gemini Web UI：是我們的**「靈感實驗室」或「創意沙盒」**。它擁有更自由、更具創意的互動介面，可以同時看到多個版本的草稿、方便地進行長篇大論的對話。它最適合的場景，就是進行探索性、創造性、迭代性的任務——例如，打磨我們即將在 CLI 中使用的「終極咒語」！ Part 3：AI 幫我寫咒語：Prompt Engineering 的「後設」技巧 「Prompt Engineering」，直白點說，就是「如何跟 AI 好好說話的藝術」。我們在 Day 5 已經介紹過它的基本原則。但今天，我們要玩一個更進階的**「後設 (Meta)」**技巧——讓 AI 自己，成為一位提示工程專家。
這就像是，我們不只問許願精靈『我想要什麼』，而是拉著精靈坐下來，一起討論：『嘿，精靈！以你對魔法的理解，如果我想要一座完美的黃金城堡，我應該用什麼樣的「許願詞」、提供哪些細節（例如：尺寸、風格、純度），才能讓你最有效率、最不會理解錯誤地幫我變出來？』我們正在讓 AI 成為我們的『許願顧問』。
首先打開你的靈感實驗室，前往 gemini.google.com。
這邊我提供我在使用的萬用咒語：
【我的萬用 Prompt 模板】 # 角色 (Role) 你是一位頂尖的 AI Prompt Engineering 專家與思維框架建構師。你的核心專長是，將使用者提出的初步、模糊的想法，轉化為一個結構完整、指令清晰、包含所有最佳實踐的高品質「進階 Prompt」。 # 目標 (Objective) 我的任務是，請你根據我下方提供的「初步構想」，為我生成一個可以直接複製使用、用於驅動其他 AI 完成具體任務的「進階 Prompt」。 --- ## 使用者提供的初步構想 (User&amp;#39;s Initial Idea) * **[核心任務]**: `[請在這裡用一句話描述你最想讓 AI 做什麼。例如：幫我規劃一趟為期七天的日本東京家庭旅遊行程。]` * **[目標產出]**: `[請描述你希望最終得到的產出物是什麼。例如：一份 Markdown 格式的每日行程表。]` * **[目標受眾]**: `[請描述這個產出物是給誰看的，或在什麼情境下使用。例如：給我的家人看，成員包含兩位長輩和一位小孩。]` * **[關鍵細節與限制]**: `[請列出任何你認為重要的額外資訊、風格要求或限制。例如：行程要輕鬆，不要太趕；需要考慮長輩的體力；預算中等；希望包含至少一個親子景點。]` --- ## 你的任務與產出要求 (Your Task &amp;amp; Output Requirements) 1.</description></item><item><title>Day 12: 【後端 #1】起手式：AI 代理人 生成模組化的 Flask 專案</title><link>/ChiYu-Blob/posts/2025ithomeironmanday12/</link><pubDate>Sun, 31 Aug 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday12/</guid><description>安安，我是 ChiYu！歡迎來到歷史性的一刻！
過去一週，我們是專案的「規劃師」，用文字和圖表描繪著未來。從今天起，我們是「建築師」與「魔法師」，要將那些平面的藍圖，用程式碼，一行一行地「召喚」到這個世界上！
今天，我們不打算一個檔案一個檔案地慢慢來。我們要直接挑戰專業的作法！我們將命令 AI 代理人，根據我們 Day 8 設計的「模組化專案結構」，一步到位地為我們生成整個後端專案的基礎架構，包含所有資料庫模型的定義！
Part 1：為什麼要一開始就這麼「搞剛」？ 你可能會問，為什麼不先從一個簡單的檔案開始，之後再慢慢改？
因為專業的習慣，從第一天就要養成。
我們在 Day 7 設計的**「應用程式工廠 (Application Factory)」**模式，雖然看起來檔案比較多，但它為我們專案的未來，鋪設了一條康莊大道。這種結構能幫助我們將專案的不同部分（如設定、資料庫模型、API 路由）清晰地分開，讓專案更有條理、更容易測試與擴展。
從一開始就採用這種專業結構，就像是蓋房子時，直接把客廳、臥室、廚房的隔間都規劃好，而不是先蓋一個大通鋪，之後再來敲牆壁。
Part 2：Vibe Coding 實戰：命令 AI 代理人建立專案 好了，讓我們來指揮 Gemini，讓它為我們建立這座「中央廚房」。這次，我們不只要求它生成文字，我們要命令它直接行動！
Step 1：進入互動模式並下達總指令 我們要使用 gemini chat 互動模式，因為這最能模擬我們與一位「代理人」進行對話的感覺。
在 VS Code 終端機中，輸入 gemini chat 並按下 Enter。 看到 &amp;gt;&amp;gt;&amp;gt; 提示符後，詠唱我們的「專案創世」咒語： 【魔法詠唱：我們的 Prompt】 # --------------------------------------------------------------------------- # PROMPT FOR GEMINI: Production-Ready Flask Project Scaffolding Agent # --------------------------------------------------------------------------- # 角色 (Role) 你是一位精通 Python Flask 專案架構與 Shell 指令的 AI Code Scaffolding Agent。你的核心任務是根據設計文件，自動化地生成一個結構清晰、可立即執行的模組化 Flask 專案骨架。 # 目標 (Objective) 我的目標是讓你根據「軟體架構」與「資料庫綱要」文件，為我生成一個遵循業界最佳實踐的 Flask 專案。這個專案在生成後，應能立即安裝依賴並成功運行。 # 上下文 (Context) - **核心依據**: 你的所有操作都必須基於以下兩份文件的定義： 1.</description></item><item><title>Day 13: 【後端 #2】AI 建築師：依藍圖自動建構 CRUD API</title><link>/ChiYu-Blob/posts/2025ithomeironmanday13/</link><pubDate>Mon, 01 Sep 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday13/</guid><description>安安，我是 ChiYu！歡迎來到 Vibe Coding 協奏曲的第一個最大的開發項目！
昨天，我們用一個指令召喚出了整個專案骨架。今天，我們要進行一次令人振奮的專案升級。我們將扮演一位「專案總建築師」，把詳細的「設計藍圖 (API_SPEC.yml)」交給我們的 AI 首席工程師，命令它根據藍圖，將完整的「習慣 (Habits)」資源模組，精準地建構到我們現有的專案結構中！
而在工程完工後，我們還需要一套最先進的「驗收工具」，來驗證成果是否符合藍圖規範。而這套工具的安裝與設定，我們同樣要交給 AI 來完成！
Part 1：Vibe Coding 實戰：下達「程式碼建構」指令 專案藍圖已備妥，讓我們打開終端機，指揮我們的 AI 首席工程師開始施工。
【實戰魔法詠唱：我們的 Prompt】 # 角色 (Role) 你是一位資深的 Python 後端工程師，專精於 Flask 框架與 API 開發。 你擁有豐富的經驗，能夠根據 OpenAPI 規格書，快速、精準地建構出穩定、 安全且符合業務邏輯的後端程式碼。你擅長使用 SQLAlchemy 進行資料庫操作， 並習慣撰寫清晰、可維護的程式碼。 # 目標 (Objective) 你的任務是，根據提供的 `API_SPEC.yml` 規格書與相關設計文件， 在一個已存在的 Python Flask 專案結構中，實作所有 API 端點的後端業務邏輯。 你將直接修改指定的 Python 檔案， 填入完整、可執行、生產級別 (Production-Ready) 的程式碼。 # 上下文與關鍵資訊 (Context &amp;amp; Key Information) * **OpenAPI 規格書 (OpenAPI Specification)**: 檔案位於 `[請提供 API_SPEC.</description></item><item><title>Day 14: 【DevOps #1】AI 品管員：設定 GitHub Actions 自動化程式碼檢查</title><link>/ChiYu-Blob/posts/2025ithomeironmanday14/</link><pubDate>Tue, 02 Sep 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday14/</guid><description>安安，我是 ChiYu！
我們前幾天火力全開，後端 API 核心功能都搞定了。我們的後端架構現在什麼功能都做得出來！但問題來了，我們怎麼保證每個工程師（當然也包括幾週後的你自己！）在添加新功能時，都遵守一樣的編碼標準跟架構美學？
光靠口頭約定絕對不夠，我們需要一套自動的、鐵面無私的「 品質稽查系統 」。只要有新的程式碼被提交 (commit)，系統就自動進行檢查，確保一切都符合最高標準！
今天，我們就要來幫專案請一位 24 小時不休息的稽查員—— GitHub Actions ，順便設定好我們的第一條自動化品管流程 (CI)！
Part 1：什麼是 CI？為什麼要從「程式碼風格」開始？ CI (Continuous Integration)，持續整合，是現代軟體開發的基本功！它的精神就是「沒事多 commit，多 commit 沒事」。每次完成一小塊功能，就提交上來讓系統檢查，這樣才不會到最後要合併時，大家的程式碼風格迥異、互相衝突，那簡集是開發地獄！
我們要派給這位品管員的第一個任務，非常基礎，就是 「檢查程式碼乾不乾淨 (Linting)」！這就好像檢查建築的管線有沒有外露、牆面是否平整一樣。我們要讓所有的 Code 都遵循 Python 的官方風格指南 (PEP 8)，看起來整整齊齊、清爽漂亮！
Part 2：Vibe Coding 實戰：聘請 AI 撰寫「自動化工作手冊」 準備好了嗎？又到了我們使喚 Gemini 的快樂時光！把它當成我們的 DevOps 專家，來幫我們撰寫那份詳細的工作手冊 (.yml 檔) 吧！
Step 1: 命令 AI 準備「稽查工具清單」 第一步，我們要先列一張「工具清單 (requirements.txt)」，告訴我們的稽查員執行任務時需要哪些工具。這點小事，當然也是丟給 AI 去做！
打開終端機，切換到 gemini chat 模式，下達我們的第一道指令：
【魔法詠唱：生成依賴文件】 # 角色 (Role) 你是一位經驗豐富的 Python 開發者，非常熟悉使用 `requirements.txt` 來管理專案的相依性套件，並了解區分「生產環境依賴」與「開發環境依賴」的最佳實踐。 # 目標 (Objective) 請為一個 Python 專案生成 `requirements.</description></item><item><title>Day 15: 【後端 #3】API 測試：用 Gemini CLI 輔助撰寫 Pytest</title><link>/ChiYu-Blob/posts/2025ithomeironmanday15/</link><pubDate>Wed, 03 Sep 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday15/</guid><description>安安，我是 ChiYu！
昨天，我們的 CI 品管員 (GitHub Actions) 成功上崗，確保了所有程式碼的「風格」都符合最高標準。
但是，一本語法完全正確的食譜，不代表按照它做出來的菜就一定好吃。我們的專案，即使程式碼風格再優雅，如果 API 的商業邏輯出現錯誤，那依然是嚴重的品質問題。
今天，我們就要來建立一張更堅實的「 安全網」。我們將引入自動化測試，指揮 Gemini 化身為「 測試工程師」，為我們撰寫測試案例，並直接升級 CI 流程，確保我們的 API 邏輯永遠精準無誤！
Part 1：告別「手動點點點」：為什麼需要自動化測試？ 你可能會問：「我們不是已經用 Swagger UI 手動測試過 API 了嗎？」
手動測試在開發時很方便，但它有幾個致命缺點：效率極低、容易遺漏、無法規模化。當專案功能變多，你不可能每次修改後，都把所有 API 再手動點一次。
而自動化測試，就是「用程式碼來測試程式碼」。我們預先寫好一系列的「考卷」（測試案例），然後讓電腦在幾秒鐘內，自動「批改」我們的應用程式。
比喻來說：
自動化測試就像是高空走鋼索表演底下的那張「安全網」。有了它，開發者才能充滿信心地在鋼索上快速前進、大膽地嘗試新動作（重構或新增功能）。因為我們知道，即使不小心失足（不小心改壞了舊功能），這張安全網也會立刻接住我們（測試會失敗並報錯），而不是讓我們直接摔到地上（等使用者回報 Bug）。
Part 2：我們的測試武器：Pytest Pytest 是 Python 世界中最受歡迎、也最簡單易用的測試框架。我們將用它來撰寫我們的「考卷」。
Part 3：Vibe Coding 實戰：與 AI 測試工程師的協作 準備好了嗎？讓我們進入 gemini chat 模式，一步步指揮我們的 AI 測試工程師。
Step 1: 命令 AI 設置「測試實驗室」 首先，我們要讓 AI 為我們準備好測試所需的環境。
【魔法詠唱：設置測試環境】 好的，我們準備為專案加入自動化測試。
請幫我執行以下任務：
安裝測試框架: 使用 pip 安裝 pytest。 更新依賴清單: 將 pytest 新增到 requirements.</description></item><item><title>Day 16: 【整合篇】後端竣工！回顧與展望</title><link>/ChiYu-Blob/posts/2025ithomeironmanday16/</link><pubDate>Thu, 04 Sep 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday16/</guid><description>安安，我是 ChiYu！
走到這一步，請先放下鍵盤，靠在椅背上，深呼吸，然後給自己一個最真誠、最響亮的掌聲！你真的非常、非常了不起！
今天，是我們「左手藍圖，右手魔法」協奏曲的上半場終章。我們將暫時放下後端的程式碼，為過去兩週緊湊而充實的奮鬥，畫下一個完美的句點。今天的議程很簡單：慶祝，回顧我們走了多遠，沉澱我們學到了什麼，然後滿懷期待地展望未來。
Part 1：旅程回顧：從一個模糊的想法到一個會說話的後端 還記得兩週前的我們嗎？那時，我們手中只有一個飄在空中的、模糊的想法：「我想做個能幫助人們的習慣追蹤器」。它很美好，但也很脆弱。
而現在，經過十四天的淬鍊，我們共同打造出了一個堅實的、看得見摸得著的成果。它不再只是一個想法，而是一個功能完整、經過雙重自動化驗證、穩定可靠的後端服務。我們親手賦予了它骨骼與心跳。
讓我們一同盤點，在這趟旅程中，我們從無到有，創造了哪些寶貴的「數位資產」：
一套完整的「設計藍圖」：我們產出了五份彼此關聯、層層遞進的專業文件。從定義方向的《專案章程》，到釐清需求的《使用者故事》，再到搭建骨架的《軟體架構》、規劃數據的《資料庫綱要》，最終確立契約的《API 規格書》。這套藍圖，是我們所有工作的「單一真理來源」，它確保了我們的航行始終朝著正確的航向。 一組強大的「核心 API」：我們利用 Vibe Coding，高效地實作了身份驗證、習慣管理等所有核心的 CRUD 端點。這些 API 就是我們餐廳廚房の爐火，是我們專案未來所有功能的動力來源。 一道堅實的「自動化品質防線」：我們建立了兩道 CI 品質防線。flake8 如同一位嚴謹的文學編輯，確保我們的程式碼風格優雅；pytest 則像一位精明的邏輯考官，確保我們的功能邏輯準確無誤。這道防線，是我們未來敢於快速迭代、大膽重構的最大底氣。 一套進化的「AI 協作方法論」：這或許是我們最大的收穫。我們不再只是 AI 的使用者，我們學會了如何扮演指揮家，透過精準的 Prompt，引導 AI 成為我們的產品經理、架構師、甚至是測試工程師。我們掌握了一套能夠駕馭 AI，進行現代化高效開發的全新工作流。 我們嚴格地遵循了「先有藍圖，再有魔法」的原則，而這整個過程，其實隱含了許多超越程式碼本身、能讓你受用無窮的專業開發心法。
Part 2：超越程式碼的三個核心心法 在我們為上半場畫下句點之前，讓我們花點時間，從我們剛剛完成的後端專案中，提煉出幾個更深層次的、關於「如何思考」的專業心法。
心法一：各司其職的藝術 (關注點分離) 回想我們的餐廳比喻： 前台（Frontend） 負責點餐、 廚房（Backend） 負責做菜、 食材庫（Database）負責存貨。它們各司其職，互不干涉，透過定義好的流程（API）來溝通。這在軟體開發中，被稱為「關注點分離 (Separation of Concerns)」 。這不僅是一種技術，更是一種思維的紀律。它讓我們在面對複雜問題時，能夠將其拆解成一個個獨立、可管理的小問題，然後逐一擊破。
對 Vibe Coding 的啟示是：當你向 AI 提問時，也要保持這種思維紀律。一次只專注在一件事上。正是因為我們將任務拆解成「幫我設計資料庫」、「幫我生成 API」、「幫我寫測試」，我們才避免了 Day 1 那種「我想要一台腳踏車，AI 卻給我一艘航空母艦」的失控窘境。你的問題越聚焦，AI 給你的答案品質就越高，你也越能掌控最終的結果。
心法二：跟隨慣例，事半功倍 (慣例優於設定) 你可能已經發現，我們遵循了很多「慣例 (Convention)」：測試檔案放在 tests/，CI 設定檔放在 .github/workflows/，依賴套件寫在 requirements.txt。這些都不是硬性規定，但它們是整個開發者社群歷經多年演化，沉澱下來的「最佳實踐」。
這就是 「慣例優於設定 (Convention over Configuration)」 的哲學。當我們遵循社群普遍認可的慣例時，就等於在使用一種「共通語言」。這使得我們的專案對於任何一位有經驗的開發者（甚至是 AI！）來說，都是熟悉且可預測的。它大幅降低了溝通成本與新成員的學習曲線，同時也讓許多工具能夠「開箱即用」。</description></item><item><title>Day 17: 【前端 #0】前端世界的基石： HTML, CSS 與 JavaScript</title><link>/ChiYu-Blob/posts/2025ithomeironmanday17/</link><pubDate>Fri, 05 Sep 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday17/</guid><description>安安，我是 ChiYu！
昨天，我們為精彩的後端開發之旅，畫下了一個完美的句點。我們現在擁有一個性能強大、穩定可靠的「專案引擎」，一顆強壯、默默跳動的心臟，但它還沒有形體，等待著被賦予生命。
從今天起，我們將正式開啟一個全新的篇章： 前端開發。我們將從幕後的「引擎工程師」，搖身一變，成為面向使用者的「 造物主」與「 生命設計師」。
但在我們開始 Vibe Coding 我們的數位生命之前，我們必須先花一天時間，回歸本心，認識一下構成生命的三大基本元素。今天，是前端開發的 Day 0，我們不寫任何一行專案程式碼，只專注於一件事：用最簡單的比喻和親手實作，讓你徹底搞懂構成全世界所有網頁的生命三要素——HTML, CSS, 與 JavaScript。
Part 1：HTML - 生命的「骨骼」 想像一下我們要創造一個生命體。我們做的第一件事是什麼？塑造它的骨架。這就是 HTML (HyperText Markup Language) 的角色。
HTML 的唯一職責，就是定義網頁的「內容」與「結構」。它決定了這個生命體「有哪些器官」，但完全不管它「長什麼樣子」。
&amp;lt;h1&amp;gt; 標籤告訴瀏覽器：「嘿，這是頭顱」，是思考的中心。 &amp;lt;p&amp;gt; 標籤說：「這是一塊軀幹」，是身體的主體。 &amp;lt;img&amp;gt; 標籤說：「這裡要有眼睛」，用來觀看世界。 &amp;lt;button&amp;gt; 標籤說：「這裡要有手」，用來與世界互動。 HTML 就是生命的骨架，最基礎、最核心，沒有它，皮囊與肌肉都將無所依附。
【動手玩玩看 #1】 建立實驗室：在你的電腦桌面，建立一個新的資料夾，取名為 frontend-playground。 用 VS Code 開啟：打開 VS Code，點擊左上角「檔案 (File)」-&amp;gt;「開啟資料夾 (Open Folder)」，然後選擇我們剛剛建立的 frontend-playground。 建立 HTML 檔案：在 VS Code 左側的檔案總管中，點擊「新增檔案」的圖示，將檔案命名為 index.html。 貼上骨架程式碼：將下面的程式碼，完整地複製並貼到你剛剛建立的 index.html 檔案中。 &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;我的生命體&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;這是頭顱&amp;lt;/h1&amp;gt; &amp;lt;p&amp;gt;這是一塊樸素的軀幹。&amp;lt;/p&amp;gt; &amp;lt;button&amp;gt;這是一隻手&amp;lt;/button&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 預覽結果：直接在檔案總管中，找到 index.</description></item><item><title>Day 18: 【文件 #6】網站的風格指南：用 Gemini 定義顏色與字體</title><link>/ChiYu-Blob/posts/2025ithomeironmanday18/</link><pubDate>Sat, 06 Sep 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday18/</guid><description>安安，我是 ChiYu！
昨天，我們扮演了「造物主」，理解了構成數位生命的三大基本元素：HTML (骨骼)、CSS (皮囊) 與 JavaScript (肌肉)。
我們的生命體現在有了基本的構造，但它還沒有「氣質」與「個性」。它的膚色、瞳孔顏色、說話的語氣（字體）都尚未被定義。如果我們現在就開始隨心所欲地為它上色、化妝，最終很可能會創造出一個風格混亂、不忍直視的「四不像」。
因此，在我們動手寫任何一行 CSS 之前，我們要再次回到我們最信賴的工作流程——文件驅動。今天，我們將化身為「 首席視覺設計師」，與我們的 AI 夥伴 Gemini 深度對談，為我們的 App 定義一套獨一無二的視覺風格，並將其記錄成一份專業的**「風格指南 (Style Guide)」**文件。
Part 1：什麼是「風格指南」？為什麼它是設計的「DNA」？ 「風格指南」是一份定義了專案所有視覺元素（顏色、字體、間距、圖示、按鈕樣式等）使用規則的「設計聖經」。它就是我們數位生命的 「基因圖譜 (DNA)」。
為什麼我們需要它？
確保一致性 (Consistency)：一份好的風格指南，能確保你網站上的每一個按鈕、每一段文字，看起來都像是來自同一個「家族」。這種視覺上的一致性，會給使用者帶來專業、可靠、值得信賴的感覺。 提升開發效率 (Efficiency)：它能將設計師與工程師從無盡的「這個藍色深一點還是淺一點？」、「這個標題用多大字體？」的決策地獄中解放出來。我們不再需要每次都重新發明輪子，只需要遵循 DNA 的指示即可。 賦予 AI 清晰的指令：這對我們 Vibe Coding 的流程至關重要！當我們有了這份文件，未來就可以直接對 Gemini 說：「請用我們的 primary-color 設計一個按鈕」，AI 就能立刻理解並產出符合我們整體風格的程式碼。 Part 2：定義我們 App 的「Vibe」- 專案的個性 在挑選顏色和字體之前，我們得先回答一個更根本的問題：我們希望這個 App 給人什麼樣的「感覺 (Vibe)」？
回顧我們 Day 5 的專案章程，我們的願景是「賦予使用者力量，建立正向習慣並擁抱更健康的心態」。基於這個願景，我們可以提煉出幾個關鍵詞來定義我們 App 的個性：
Calm (平靜)：介面應該是簡潔、無干擾的，讓使用者能專注於紀錄與反思。 Encouraging (鼓勵)：視覺元素應該帶有溫度，給人一種積極、正向的感覺。 Clean (乾淨)：佈局要清晰，留有足夠的呼吸空間 (留白)，避免資訊過載。 Trustworthy (可靠)：設計要專業、一致，讓使用者願意將他們的個人數據託付給我們。 這幾個關鍵詞，就是我們接下來與 Gemini 溝通時的「通關密語」。</description></item><item><title>Day 19: 【文件 #7】頁面的骨架：用 Gemini 規劃主佈局與元件拆分</title><link>/ChiYu-Blob/posts/2025ithomeironmanday19/</link><pubDate>Sun, 07 Sep 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday19/</guid><description>安安，我是 ChiYu！
昨天，我們扮演了「首席視覺設計師」，為我們的數位生命，定義了一套獨一無二的「基因圖譜 (DNA)」——我們的 風格指南。現在，我們有了調色盤、有了字體，知道了這個生命體該有的氣質。
但光有這些還不夠。在我們開始為它披上皮囊（寫 CSS）之前，我們需要先確定它的「身體結構」。它的頭、身體、四肢要如何組織？身體的各個器官（按鈕、卡片、列表）又要如何劃分？
今天，我們將化身為「UI 架構師」，再次回到我們最信賴的文件驅動流程。我們將指揮 Gemini，根據我們的使用者故事，設計出網站的 主要佈局 (Layout)，並將複雜的介面，拆解成一份清晰的、可重複使用的 元件清單 (Component Breakdown)。
Part 1：什麼是「佈局 (Layout)」？—— 房子的「格局規劃」 如果說昨天的風格指南是「室內設計風格」（例如：北歐風、工業風），那今天的「佈局」，就是這棟房子的「格局規劃圖」。
它定義了整個應用程式最頂層的、共通的結構。例如：
玄關/大廳 (Header / Navbar)：訪客一進門會看到的地方，通常包含 Logo 和主要的導覽連結。 客廳/主要活動區 (Main Content Area)：這是房子的核心，大部分的活動都會在這裡發生。 書房/側邊功能區 (Sidebar)：一個固定的區域，用來放置次要的導覽或工具。 陽台/頁腳 (Footer)：房子的底部，通常放一些版權資訊或次要連結。 先定義好這個共通的「格局」，能確保使用者在我們網站的不同房間（頁面）之間穿梭時，永遠不會迷路，擁有一致且可預測的體驗。
Part 2：什麼是「元件拆分」？—— 用「樂高」來蓋房子 這是一個現代前端開發中，最最最重要的核心思想。
想像一下，你要蓋一座樂高城堡。你不會每次都從最微小的顆粒開始，一顆一顆地去想要怎麼組成一扇窗戶。一個聰明的樂高玩家，會先預先組裝好幾種標準尺寸的「窗戶」、「門」、「城牆塊」、「塔頂」——這些，就是我們的 「元件 (Component)」。
當你要蓋城堡時，你只需要像組合積木一樣，把這些預先做好的「元件」拼裝起來即可。
*「元件拆分 (Component Breakdown)」 **就是這個過程。我們在動手寫程式碼之前，先審視我們的設計稿（或使用者故事），然後像玩樂高一樣，思考：「這個介面，可以拆解成哪些可以重複使用的積木？」 這樣做的好處是：
可複用性 (Reusability)：我們只需要設計和製作一次「習慣卡片」這個元件，之後在儀表板、回顧頁面，都可以重複使用它。 可維護性 (Maintainability)：未來如果想修改所有習慣卡片的樣式，我們只需要修改一個地方，所有用到它的地方就全部更新了！ Vibe Coding 的加速器：這是最關鍵的一點！當我們定義好元件後，未來就可以直接對 Gemini 說：「幫我生成一個 HabitCard 元件的程式碼」，AI 就能根據這份文件，精準地產出我們需要的「樂高積木」。 Part 3：實戰開始：讓 Gemini 成為我們的 UI 架構師 好了，理論武裝完畢，讓我們再次召喚 Gemini CLI，請它扮演我們的 UI 架構師。</description></item><item><title>Day 20: 【前端 #1】Gemini Canvas 生成UI (還有新的AI建議功能)</title><link>/ChiYu-Blob/posts/2025ithomeironmanday20/</link><pubDate>Mon, 08 Sep 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday20/</guid><description>安安，我是 ChiYu！
昨天，我們完成了前端開發的最後一份規劃文件。至此，我們所有的「左手藍圖」工作，全部大功告成！
從今天起，我們將正式拿起工具，戴上安全帽，開始 Vibe Coding 的前端實作！但&amp;hellip; 我們真的要像傳統的「建築工人」那樣，一行一行地去搭建 HTML 骨架，再一點一點地去粉刷 CSS 樣式嗎？
不！時代變了！今天，我們要直接從「建築工人」一步到位，升級成「魔法建築師」！我們不再一磚一瓦地蓋房子，我們要直接攤開我們的設計藍圖，對著 Gemini 詠唱咒語，瞬間召喚出一棟功能完整、外觀精美的 UI 原型！
Part 1：為什麼要用 Canvas？—— 從「盲人摸象」到「上帝視角」 在 Day 12，我們體驗了在終端機 Vibe Coding 的快感。它很酷，但對於 UI 開發來說，它有個小缺點：我們就像是在黑暗中「盲人摸象」，敲下一行指令，然後切換到瀏覽器看看成果，來來回回，效率不高。
而 Gemini Web UI 的 Canvas 功能，則給了我們截然不同的體驗——「上帝視角」。
Canvas 是一個視覺化的 AI 互動介面，它能讓我們在描述需求的同時，即時預覽 AI 生成的 UI 畫面。它追求的是 「極速視覺化」，讓我們能在幾分鐘內，就得到一個可以直接互動、外觀精美的 UI 原型。這對於前端開發來說，簡直是夢幻般的工具！
Part 2：Canvas 實戰：為 AI 建築師提供「設計圖」 現在，讓我們打開我們的「魔法實驗室」—— gemini.google.com，然後選擇 Canvas 功能。我們要學習一門全新的 Prompt 技巧：如何用文字，向一位魔法建築師描述一棟房子？
答案很簡單：把我們嘔心瀝血產出的設計文件餵給它！
【魔法詠唱：UI 生成咒語】 # 角色 (Role) 你是一位頂尖的前端工程師，精通 HTML, CSS, JavaScript，並且對 UI/UX 設計有深刻的理解。 # 目標 (Objective) 請根據我提供的設計文件和詳細需求，為我生成一個功能完整的「習慣追蹤器」Web UI 的**單一 HTML 檔案** # 上下文 (Context) - **風格指南**: STYLE_GUIDE.</description></item><item><title>Day 21: 【前端 #2】從原型到架構：拆解並整合 AI 生成的 UI 程式碼</title><link>/ChiYu-Blob/posts/2025ithomeironmanday21/</link><pubDate>Tue, 09 Sep 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday21/</guid><description>安安，我是 ChiYu！
昨天那場「視覺魔法秀」是不是超震撼的？才幾分鐘，AI 就「咻」一下變出一個又美又能動的 UI 原型，真的太扯了！這證明 AI 拿來做 prototype 根本是開外掛啊。
不過，身為一個有格調的工程師，光是「能動」怎麼夠呢？今天，我們就要來當個「結構工程師」，幫這棟魔法變出來的漂亮房子，來個專業級的 「大改造 (Refactoring)」！
Part 1：心法時間：為什麼高手絕對不把 CSS 跟 JS 塞在同一個 HTML 檔？ 昨天 AI 給我們的那個檔案，HTML、CSS、JavaScript 全都擠在一起。拿來看看樣子當然很方便，但在真專案裡，這樣搞可是超級大忌喔！為什麼？這背後藏著三個高手才知道的心法：
各管各的 (Separation of Concerns)：這點最重要！HTML 是骨架、CSS 是外表、JS 是肌肉，大家各有各的工作。把它們全混在一起，就像把廚房、臥室、客廳的功能全塞到一個房間裡，保證亂到你媽都認不出來，以後要修根本是惡夢！ 讓瀏覽器偷懶 (Browser Caching)：你想想，你把 CSS 跟 JS 分開成獨立檔案後，瀏覽器第一次看完，就可以把它們存起來。下次你再逛同個網站的其他頁面，因為 style.css 跟 script.js 沒變，瀏覽器就不用再下載一次，直接拿舊的來用就好，這樣網站跑起來才會飛快啊！ 大家好做事 (Maintainability &amp;amp; Collaboration)：專案一搞大，肯定不止你一個人寫。把檔案分開，管畫面的同事就專心搞 .css，管功能的就專心搞 .js，大家井水不犯河水，才不會打架，做事效率才會高嘛！ 所以啦，我們的目標很簡單，就是把昨天那個漂亮的「藝術品」，改造成一個真正可以用在專案上、結構超清楚的「工業級產品」！
Part 2：開工啦：來唸個「一鍵改造」的超級咒語 這個精細的「分家手術」，我們不用慢慢來。我們要用一個更猛的 Prompt，直接叫 AI 「一次搞定」！
Step 1: 把昨天變出來的魔法成果搬進來 首先，當然是把昨天的成果，正式放到我們的專案裡。
建立前端基地：在 VS Code 的專案根目錄，建立一個叫 frontend 的新資料夾。 儲存原型：把昨天從 Canvas 下載或複製的完整程式碼，在 frontend 資料夾裡存成 prototype.</description></item><item><title>Day 22: 【前端 #3】AI 一鍵生成完整 App 靜態 UI</title><link>/ChiYu-Blob/posts/2025ithomeironmanday22/</link><pubDate>Wed, 10 Sep 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday22/</guid><description>安安，我是 ChiYu！
昨天，我們扮演了一位冷靜而專業的「結構工程師」，成功地將 AI 生成的華麗原型，重構成為一個結構清晰、職責分明的專業前端專案。我們的 index.html, style.css, script.js 現在各司其職，一切都井井有條。
我們現在有了一個專業的「建築框架」，以及一些基本的「核心傢俱」（習慣列表和 Modal）。但是，我們的房子裡還有很多房間是空的，例如完整的導覽列、心情記錄區等等。
今天，我們的任務就是進行一場 「UI 補完計畫」！我們將繼續指揮我們的 AI 助手，根據我們所有的設計藍圖，在現有的專案基礎上，將 MVP 所需的所有靜態 UI 元素全部建造完成！
Part 1：今日的作戰計畫：完成我們的「樣品屋」 我們的目標非常明確：將我們目前的 UI，擴建成一個外觀上 100% 完整的樣品屋。使用者看到它時，會覺得這就是一個功能齊全的 App，即使它內部還沒有連上數據。
根據我們的《使用者故事》和《佈局元件》文件，我們今天需要補全以下幾個關鍵部分：
一個功能完整的側邊導覽列 (Sidebar)。 一個心情記錄區 (Mood Tracker)。 整體樣式微調，確保所有新舊元件完美融合。 Part 2：Vibe Coding 實戰：指揮 AI 進行「室內精裝修」 現在，讓我們回到 gemini chat 模式，指揮 AI 在我們現有的程式碼基礎上，進行一次**「增量開發 (Incremental Development)」**。這是一個非常重要的專業開發模式，代表我們不是每次都推倒重來，而是在現有基礎上，逐步疊加新功能。
【魔法詠唱：UI 擴建】 # 角色 (Role) 你是一位頂尖的前端工程師，精通語意化 HTML 和現代 CSS，擅長在現有專案基礎上，根據設計文件擴充 UI。 **# 目標 (Objective)** 請根據我提供的所有設計文件，擴充我現有的前端程式碼，補完 MVP 所需的全部靜態 UI 元素。 **# 上下文 (Context)** - **現有 HTML**: `@frontend/index.</description></item><item><title>Day 23: 【前端 #4】非同步的藝術：深入 Fetch API 與 Promise</title><link>/ChiYu-Blob/posts/2025ithomeironmanday23/</link><pubDate>Thu, 11 Sep 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday23/</guid><description>安安，我是 ChiYu！
昨天，我們扮演了一位「創世神」，指揮 AI 在一天之內，為我們建構出了 App 完整、精美的靜態 UI。我們現在手上，有了一個外觀完美，但沒有靈魂的「App 蠟像館」。
它很美，但它是靜默的。它無法感知外界，也無法與我們在後端建立的強大「大腦」進行溝通。
今天，我們就要來為它安裝這套至關重要的神經系統！我們將深入前端開發中最核心、也最讓新手困惑的觀念——非同步程式設計 (Asynchronous Programming)，並學習如何使用 Fetch API，讓前端的「身體」與後端的「大腦」進行第一次的歷史性對話！
Part 1：前端心法：為什麼我們需要「非同步」？ 想像一個場景：你去一家超紅的手搖飲店點餐。你點完一杯「珍珠鮮奶茶，半糖少冰」後，是會呆呆地站在櫃檯前，死盯著店員，從他開始煮珍珠、泡茶、加牛奶、到最後封膜，一步都不離開嗎？
當然不會！那樣不僅你自己浪費時間，還會把後面的客人全都堵死。一個正常的流程是：你點完餐，店員給你一個會震動的「取餐呼叫器」，然後你就可以去旁邊找個位子坐下、滑滑手機、看看書。等到飲料做好了，呼叫器「嗡嗡嗡」地震動，你再優雅地過去取餐。
前端與後端的溝通，就跟這個過程一模一樣！
同步 (Synchronous)：就是那個呆站在櫃檯的笨方法。如果前端用「同步」的方式去跟後端要資料（例如，去資料庫拿你的習慣列表），那整個網頁畫面就會完全卡死，捲動不了、按鈕沒反應，直到後端把資料傳回來為止。這對使用者來說，是災難性的體驗。 非同步 (Asynchronous)：就是那個聰明的「呼叫器」方法。前端發出一個請求給後端後，它不會原地等待，而是會繼續做自己的事（例如：保持畫面的流暢、回應使用者的其他操作）。後端處理完資料後，會透過一個機制「通知」前端：「嘿，你的資料好了，快來拿！」 而這個神奇的「呼叫器」，在 JavaScript 的世界裡，就叫做 Promise。
什麼是 Promise？ Promise 是一個物件，它代表一個「承諾」。當你呼叫一個非同步操作（例如 fetch）時，它會立刻回給你一個 Promise。這個 Promise 就像是那個取餐呼叫器，它有三種狀態：
Pending (等待中)：你剛拿到呼叫器，它還沒震動。代表飲料還在做。 Fulfilled (已實現)：呼叫器震動了！代表你的珍奶做好了（數據成功取回）。 Rejected (已拒絕)：呼叫器發出悲鳴！代表珍珠賣完了（網路錯誤或伺服器出錯）。 async/await：優雅地等待呼叫器 早期的 JavaScript 處理 Promise 非常麻煩（俗稱「回調地獄」），但現代 JS 提供了一套超級優雅的語法糖——async/await。它能讓我們用寫「同步」程式碼的感覺，來處理「非同步」操作，大大提升了程式碼的可讀性。
Part 2：Vibe Coding 實戰：建立我們的「通訊模組」 好了，理論武裝完畢！在我們開始呼叫 API 之前，專業的作法是建立一個專門負責與後端溝通的「通訊模組」，而不是把 fetch 寫得到處都是。這也是一種「關注點分離」！
Step 1: 命令 AI 建立 api.js 讓我們進入 gemini chat 模式，指揮 AI 為我們建立這個模組。</description></item><item><title>Day 24: 【前端 #5】狀態管理的哲學：讓 UI 成為數據的鏡子</title><link>/ChiYu-Blob/posts/2025ithomeironmanday24/</link><pubDate>Fri, 12 Sep 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday24/</guid><description>安安，我是 ChiYu！
昨天，我們的 App 經歷了一次歷史性的飛躍。我們為它安裝了「神經系統」，成功地讓前端的「身體」與後端的「大腦」進行了第一次對話。我們的 App 不再是離線的空殼，它擁有了「記憶」。
但是，這些寶貴的記憶，現在還只靜靜地躺在瀏覽器的 console 裡，像一本鎖在保險箱裡的日記，使用者完全無法窺見其貌。我們的 App 雖然有了記憶，但它還是一個「啞巴」，無法將自己的所思所想表達出來。
今天，我們就要來為 App 安裝「聲帶」和「表情肌肉」，教它如何開口說話。我們將深入探討一個區分業餘與專業前端開發的核心心法——狀態管理 (State Management)，並引入一個輕量的「狀態中心」模式，讓我們的 UI 成為數據最忠實的鏡子。
Part 1：前端心法：為什麼「直接操作 DOM」是個壞主意？ 你可能會想：「這很簡單啊！昨天拿到數據後，我用 JavaScript 的 document.createElement、appendChild 這些方法，手動把一個個習慣項目加到畫面上不就好了嗎？」
問得好！這確實是一種方法，但它就像一個木偶戲的師傅，用線牽引著木偶（DOM 元素）的一舉一動。當只有一兩個木偶時，這套方法還行得通。但想像一下，你的 App 越來越複雜，畫面上同時有幾十個木偶，它們之間還有複雜的互動，這位可憐的師傅很快就會手忙腳亂，把線纏在一起，最終導致整場表演崩潰。
「直接操作 DOM」的壞處在於：
程式碼極度混亂：你的 script.js 將會充滿各種查找元素、新增元素、刪除元素、修改樣式的程式碼，很快就會變得難以閱讀和維護。 狀態不一致：你很可能會忘記更新某個地方的數字，導致畫面上顯示的數據，跟你內心（程式碼變數）裡記得的數據不一致，這就是 Bug 的主要來源。 難以追蹤：當 Bug 出現時，你很難知道到底是哪一段手動操作，導致了畫面最終的錯誤狀態。 專業的作法：數據驅動畫面 那麼，專業的前端開發者是怎麼做的呢？他們不做那個辛苦的木偶師傅，而是做一位「劇本設計師」。
他們會建立一個唯一的**「劇本 (State)」，這個劇本用數據完整地描述了舞台上應該是什麼樣子。然後，他們會聘請一位叫做「渲染引擎 (Render Function)」的超級演員，這位演員的唯一工作，就是閱讀劇本，然後完美地將自己扮演成劇本描述的樣子**。
開發者的工作，從「手動去移動木偶的每一根手指」，變成了**「專心修改劇本」**。每當劇本（State）有任何變動，我們就大喊一聲：「卡！重來！」，然後渲染引擎就會立刻根據最新的劇本，重新表演一次，確保舞台上的畫面永遠與劇本 100% 同步。
這個「劇本」，就是我們的**「單一真理來源 (Single Source of Truth)」**。這個過程，就是 「數據驅動畫面 (Data-Driven UI)」 的核心哲學。
Part 2：Vibe Coding 實戰：建立我們的「狀態中心」與「渲染引擎」 好了，理論武裝完畢！讓我們進入 gemini chat 模式，指揮 AI 為我們重構昨天的邏輯，將這種專業的開發模式，注入我們的 App。</description></item><item><title>Day 25: 【前端 #6】核心生命週期：一天搞定習慣的「增刪改查」與「打卡」</title><link>/ChiYu-Blob/posts/2025ithomeironmanday25/</link><pubDate>Sat, 13 Sep 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday25/</guid><description>安安，我是 ChiYu！
昨天，我們的 App 經歷了一次質的飛躍。我們為它植入了「靈魂」——一個中央的狀態 (state) 和一個渲染引擎 (render)。它學會了如何「思考」（管理數據）並「表達」（渲染畫面），成功地將從後端獲取的真實數據，呈現在使用者面前。
我們的 App 現在有了一個能反映真實數據的漂亮外殼。但是，它還是一個只能「讀」，不能「寫」的「展示品」。使用者還無法新增、修改或刪除這些習慣，無法真正地與 App 產生連結。
今天，我們將迎來一個內容極其豐富、極具挑戰、也極富成就感的 「濃縮實戰篇」。我們將火力全開，一天之內，搞定所有習慣的「增、刪、改、查」與「打卡」功能，讓我們的 App 真正地「動」起來，完成其核心功能的生命週期！
Part 1：前端心法：萬變不離其宗的「互動模式」 在我們開始瘋狂寫 Code 之前，讓我們先建立一個清晰的「心智模型」。今天我們要做的所有功能，無論是新增、刪除還是打卡，都將嚴格遵循我們前幾天建立的、那個優雅而強大的「數據驅動」模式。
這個模式，就是我們所有互動功能的 「黃金公式」：
使用者事件 (User Event)：使用者觸發一個動作（例如：點擊「儲存」按鈕）。 呼叫 API (Call API)：我們的 JavaScript 會捕捉到這個事件，然後呼叫對應的 api.js 函式，向後端發送一個請求（POST, DELETE, PUT&amp;hellip;）。 更新狀態 (Update State)：在成功收到後端的回應後，我們不去手動修改畫面，而是去更新我們中央的 state 物件。 自動渲染 (Auto Re-render)：setState 函式會自動觸發 render()，我們的 UI 就會像鏡子一樣，自動、精準地反映出 state 的最新樣貌。 記住這個公式，你會發現，再複雜的互動，都能被拆解成這幾個簡單、可預測的步驟。
Part 2：Vibe Coding 實戰 (上)：擴充我們的「通訊模組」 我們的 api.js 現在只會「讀取」(fetchHabits)，是時候教它「寫入」了。
【魔法詠唱：升級通訊模組】 讓我們進入 gemini chat 模式，指揮 AI 為我們擴充 api.js。
# 角色 (Role) 你是一位資深的 API 用戶端架構師 (API Client Architect)，精通 `fetch` API 與 `async/await`，並致力於遵循 DRY (Don&amp;#39;t Repeat Yourself) 原則，撰寫可複用、可擴展且易於維護的數據獲取模組。 # 目標 (Objective) 請對現有的 `@frontend/api.</description></item><item><title>Day 26: 【前端 #7】用戶體驗的最後一哩路：優雅地處理載入與錯誤</title><link>/ChiYu-Blob/posts/2025ithomeironmanday26/</link><pubDate>Sun, 14 Sep 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday26/</guid><description>安安，我是 ChiYu！
昨天，我們的 App 經歷了一次完全體的進化！我們在一天之內，火力全開，搞定了核心的 CRUD 功能。我們的 App 不僅能思考、能表達，現在更擁有了完整的 行動能力。
但是，一個專業的產品，不只需要考慮「成功」的情境，更需要優雅地處理「等待」與「失敗」。想像一下，你點擊「儲存」後，如果因為網路不好，畫面卡住不動長達五秒，你會不會以為 App 當機了，然後狂點好幾次？如果伺服器剛好在維護，畫面直接崩潰，你是不是會立刻對這個 App 失去信心？一個沉默的 App 是一個「無禮」的 App，它不尊重使用者的時間和情緒。
今天，我們就要來補上這至關重要的用戶體驗最後一哩路。我們將扮演一位「用戶體驗工程師」，為我們的 App 注入「同理心」，教它如何與使用者溝通，優雅地處理「載入中」和「錯誤」狀態，讓它從一個「能用」的產品，進化成一個 「好用」 且 **「貼心」**的產品！
Part 1：前端心法：從「單一路徑」到「UI 狀態機」 一個業餘的 App 只會為「成功」而設計，也就是我們常說的「快樂路徑 (Happy Path)」。但一個專業的 App，會將每一次互動都視為一個 「狀態機 (State Machine)」。這意味著，我們的 UI 介面，在任何時刻，都只會處於一個明確、可預測的狀態中。
對於資料獲取這個常見的場景，一個最基本的狀態機至少包含以下幾個狀態：
閒置狀態 (Idle)：互動發生前的初始狀態。 等待狀態 (Loading)：從使用者點擊，到後端伺服器回應之前的這段時間。這是最容易被忽略，卻也最影響使用者感受的環節。一個好的 App 會在這時給出明確的回饋（例如轉圈動畫），告訴使用者：「我知道了，正在處理中，請稍候」，而不是讓使用者在原地焦慮地猜測。 成功狀態 (Success)：我們昨天做的所有功能，都屬於這個狀態。 錯誤狀態 (Error)：當網路中斷、伺服器出錯時，就會進入這個狀態。一個好的 App 會給出清晰、友善的錯誤提示，引導使用者解決問題，而不是直接崩潰或顯示一堆看不懂的程式碼。 我們可以將這個流程視覺化：
graph TD A(閒置 Idle) --&amp;gt;|使用者操作| B(載入中 Loading); B --&amp;gt; C(成功 Success); B --&amp;gt; D(錯誤 Error); C --&amp;gt; A; D --&amp;gt; A; 我們今天的目標，就是要讓我們的「狀態中心 (State)」能夠完整地描述這個狀態機，並讓我們的「渲染引擎 (Render Function)」能夠忠實地將每一個狀態呈現出來。</description></item><item><title>Day 27: 【文件 #8】數據的畫布：用 Gemini 設計「圖表元件規格書」</title><link>/ChiYu-Blob/posts/2025ithomeironmanday27/</link><pubDate>Mon, 15 Sep 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday27/</guid><description>安安，我是 ChiYu！
昨天，我們的 App 學會了「同理心」，能夠優雅地處理載入與錯誤，大幅提升了使用者體驗。至此，我們 App 的基礎建設與核心互動功能，都已相當完備。
現在，是時候兌現我們在《專案章程》中許下的最終承諾，實現我們 App 的核心價值主張了——「關聯性洞察」。
但是，圖表功能的開發，遠比一個簡單的按鈕要複雜得多。它涉及到數據的獲取、處理、整合與視覺化，稍有不慎，就可能陷入混亂。因此，在我們一頭熱地栽進去 Vibe Coding 之前，我們要重拾我們最强大的武器，再次回到 **「文件驅動開發 (DDD)」**的懷抱。
今天，我們將回頭重新設計文件，對於較為複雜的功能，為了避免AI天馬行空脫韁，還是建議回頭重新設計一份完整詳細的規格文件！我們將扮演一位「數據產品設計師」，與 Gemini 一同腦力激盪，為這個最複雜的功能，撰寫一份清晰、專業的**「圖表元件規格書」**。
Part 1：前端心法：為什麼複雜的功能更需要「文件先行」？ 你可能會問：「我們不是已經有《使用者故事》了嗎？為什麼還要再寫一份文件？」
問得好！《使用者故事》告訴我們使用者想要 什麼 (What)，但它並沒有告訴我們技術上該 如何實現 (How)。對於一個簡單的按鈕，這兩者之間的差距很小。但對於一個圖表元件，這個差距就非常巨大了：
數據契約 (Data Contract)：這個圖表元件，到底需要從外部接收什麼格式的數據才能運作？是兩個獨立的陣列，還是一個合併過的物件陣列？ 互動行為 (Interaction Behavior)：使用者與圖表的互動有哪些？滑鼠移上去要顯示什麼？點擊圖例 (Legend) 會發生什麼事？ 邊界情況 (Edge Cases)：如果沒有數據，圖表該顯示什麼？如果數據只有一天，又該如何呈現？ 在動手寫 Code 前，先把這些問題用一份 **「技術規格書」**定義清楚，就像是在畫一張精密的「零件設計圖」。有了這張圖，我們接下來的 Vibe Coding 才能精準、高效，而不是一邊寫一邊猜。
Part 2：Vibe Coding 實戰：撰寫我們的「零件設計圖」 好了，理論武裝完畢！讓我們進入 gemini chat 模式，指揮 AI 為我們撰寫這份至關重要的規格書。
【魔法詠唱：設計圖表規格】 # 角色 (Role) 你是一位頂尖的數據產品設計師與資深前端架構師，精通數據視覺化、元件化開發與無障礙網頁設計 (a11y)。你最擅長的工作是將高階的商業需求，轉化為一份清晰、穩固、可執行、且具備卓越使用者體驗的前端元件技術規格書。 # 目標 (Objective) 請根據我提供的專案上下文，為我們的核心功能「關聯性洞察圖表」，設計一份專業、完整、且可直接交付給開發者執行的**「圖表元件技術規格書 (Chart Component Technical Specification)」**。這份文件將成為該元件開發的唯一真理來源。 # 上下文與關鍵資訊 (Context &amp;amp; Key Information) * **核心價值主張**: 我們的 App 旨在「揭示個人行為與內在感受之間的微妙聯繫」(`@docs/PROJECT_CHARTER.</description></item><item><title>Day 28: 【前端 #8】兌現承諾：根據規格書 Vibe Coding 關聯性洞察圖表</title><link>/ChiYu-Blob/posts/2025ithomeironmanday28/</link><pubDate>Tue, 16 Sep 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday28/</guid><description>安安，我是 ChiYu！
昨天，我們再次實踐了「文件驅動開發」的核心精神。我們沒有直接衝進複雜的圖表程式碼中，而是先退一步，將一個模糊的「想法」，轉化為了一份清晰、具體、可執行的「技術規格」。
我們手上現在握著一份像素級精密的「零件設計圖」。有了它，我們接下來的開發工作將會變得無比順暢，因為所有關於「如何設計」的燒腦問題，都已經被解決了。我們的任務只剩下一個——專注於「如何實現」。
今天，我們將正式拿起工具，嚴格依據昨天的這份《圖表元件規格書》，指揮 AI 和 Chart.js，將這幅數據的畫布，變成真實、可互動的前端程式碼！
Part 1：前端心法：為什麼專業團隊痴迷於「規格書」？ 在開始之前，讓我們再次鞏固一下心法。為什麼像我們昨天產出的那份規格書，在專業團隊中如此重要？
消除模糊地帶：規格書用技術語言，將所有「可能」、「大概」、「我覺得」都變成了「必須」。前端工程師不再需要去猜測產品經理的心思，所有人都對著同一份文件工作。 實現並行開發：有了這份規格書，前端和後端甚至可以同時開工！後端工程師知道要提供什麼格式的 API，前端工程師知道要接收什麼格式的數據，雙方可以獨立開發，最後完美對接。 Vibe Coding 的「護欄」：這對我們至關重要。當我們指揮 AI 時，這份規格書就是最強大的「護欄」。我們可以非常精準地告訴 AI：「嘿，嚴格按照這份文件的 Props 定義來接收數據，嚴格按照這份文件的『互動行為』來寫 JS 邏輯。」這能確保 AI 的強大創造力，永遠在我們設定好的軌道上馳騁。 Part 2：Vibe Coding 實戰：將藍圖轉化為現實 好了，理論不再贅述，讓我們進入 gemini chat 模式，開始我們今天精彩的 Vibe Coding 之旅！
Step 1: 安裝我們的「畫筆」- Chart.js 首先，我們要為專案引入一個強大且易用的圖表函式庫。
【魔法詠唱：引入 Chart.js】 # 角色 你是一位熟悉前端生態系的前端工程師。 **# 任務** 請修改 `@frontend/index.html`，為專案引入 Chart.js 函式庫。 **# 產出要求** 請在 `&amp;lt;head&amp;gt;` 區塊中，加入 Chart.js 的 CDN 連結。請使用最新穩定版本。 AI 會為我們找到 Chart.js 的 CDN，並將 &amp;lt;script&amp;gt; 標籤加入到我們的 HTML 中。</description></item><item><title>Day 29: 【文件 #9】專案的守衛：用 Gemini 規劃「前端認證流程」</title><link>/ChiYu-Blob/posts/2025ithomeironmanday29/</link><pubDate>Wed, 17 Sep 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday29/</guid><description>安安，我是 ChiYu！
昨天，我們成功地兌現了對使用者的最終承諾，將冰冷的數據轉化為了富有情感的、能啟發洞察的視覺化故事。我們的 App 核心價值已然確立。
但是，我們的 App 現在還像是一個 沒有門鎖的豪宅。雖然內部裝潢精美、功能強大，但任何人都可以隨意進出，這對於一個旨在儲存使用者私密心情與習慣數據的應用來說，是絕對不可接受的。
使用者認證 (Authentication) 流程，是任何嚴肅 Web 應用的基石。它複雜、涉及安全性、且牽一髮而動全身。因此，我們 絕對不能憑感覺去寫！
今天，我們將進行第二個前端的 DDD 循環！我們將扮演一位「資安架構師」，與 Gemini 一同腦力激盪，為這個最關鍵的功能，撰寫一份清晰、專業的**「前端認證流程規格書」**。
Part 1：前端心法：在寫 Code 前，先成為半個資安專家 在我們觸碰任何跟認證相關的程式碼之前，我們必須先在腦中建立起清晰的資安模型。這不僅僅是「使用者體驗」的問題，更是「使用者信任」的基石。
1.1 核心觀念：認證 (Authentication) vs. 授權 (Authorization) 首先，要釐清兩個最常被搞混的概念：
認證 (Authentication - 你是誰？)：這個過程是在 驗證你的身份。就像你進入一棟大樓，需要出示你的身份證或門禁卡，向保全證明「我就是住戶 ChiYu」。 登入這個動作，就是最典型的認證。 授權 (Authorization - 你能做什麼？)：這個過程是在你 通過認證後， 決定你有哪些權限。保全確認了你是 ChiYu 後，他還需要知道，你的門禁卡只能打開你家的門，不能打開別人家或頂樓機房的門。在 App 中，這可能意味著普通使用者只能讀取自己的資料，而管理員 (Admin) 則可以讀取所有人的資料。 1.2 現代 Web 的通行證：JWT (JSON Web Token) 在現代 Web App 中，我們如何實現無狀態 (Stateless) 的認證呢？答案就是 JWT。
你可以把 JWT 想像成一張 蓋了章的「數位通行證」。當你用帳號密碼成功登入後，伺服器會發給你一張 JWT。這張通行證本身包含了一些資訊（例如你是誰、你的權限是什麼），並且經過伺服器的 數位簽章，確保它沒有被偽造。</description></item><item><title>Day 30: 【前端 #9】建立大門與鑰匙：根據流程圖實現前端使用者認證</title><link>/ChiYu-Blob/posts/2025ithomeironmanday30/</link><pubDate>Thu, 18 Sep 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday30/</guid><description>說在前頭！！！ 有些部分多花費了些時間在講，所以雖然今天已經滿30天了， 但我還沒有正式完成這次鐵人賽系列文！！！ 我後面還是會繼續更新到正式完結。畢竟還是要有頭有尾有始有終！
以下正文開始！ 安安，我是 ChiYu！
昨天，我們為 App 的安全性，打下了最堅實的理論基礎。我們沒有憑感覺去處理這個複雜的流程，而是再次透過 「文件驅動」，將所有可能的路徑與邏輯，都預先規劃得一清二楚。
我們手上現在握著一份精密的「安全白皮書」。有了它，我們接下來的開發工作將會變得無比順暢，因為所有關於「如何設計」的燒腦問題，都已經被解決了。我們的任務只剩下一個—— 專注於「如何實現」。
今天，我們將迎來前端整合的最終章！我們將 嚴格依據昨天的這份流程圖，指揮 AI，將這套堅不可摧的認證系統，變成真實、可運行的前端程式碼，為我們的 App 裝上大門與門鎖！
Part 1：前端心法：為我們的單頁應用模擬「多個頁面」 在開始之前，我們需要先解決一個結構性問題。我們的 App 目前是一個嚴格意義上的「單頁應用」——所有的 UI 都在同一個 index.html 裡。但現在，我們需要一個獨立的「登入/註冊」頁面。
在不引入複雜前端框架的情況下，最聰明、最簡單的作法，就是 「用 &amp;lt;div&amp;gt; 模擬頁面」。
我們的策略是：
將我們現有的主應用程式介面，用一個 &amp;lt;div id=&amp;quot;app-page&amp;quot;&amp;gt; 包起來。 再建立一個新的 &amp;lt;div id=&amp;quot;auth-page&amp;quot;&amp;gt;，用來放置登入和註冊的表單。 這兩個 &amp;lt;div&amp;gt; 永遠只會有一個顯示在畫面上。 我們將用 JavaScript 來控制，根據使用者的登入狀態，決定要顯示哪一個「頁面」。 這是一個輕量級且高效的前端路由 (Routing) 模擬方法。
Part 2：Vibe Coding 實戰：詠唱「認證系統創生」的超級咒語 好了，作戰計畫擬定，讓我們進入 gemini chat 模式，用一個全面的「超級 Prompt」，指揮 AI 為我們完成這次複雜的手術。
【魔法詠唱：注入認證靈魂】 # 角色 (Role) 你是一位頂尖的資安前端架構師 (Principal Frontend Engineer &amp;amp; Security Advocate)，精通 JWT 認證機制、狀態管理、API 客戶端設計與單頁應用程式 (SPA) 的路由管理。你擅長將複雜的認證規格，轉化為一個安全、穩固、可擴展且具備卓越使用者體驗的完整前端架構。 # 目標 (Objective) 請**嚴格依據**《前端認證架構藍圖》，對我現有的前端專案進行一次全面的**架構性重構與功能實作**，為其注入一個完整的「使用者認證」系統。 # 上下文與關鍵資訊 (Context &amp;amp; Key Information) * **唯一真理來源**: `@docs/AUTH_FLOW.</description></item><item><title>Day 31: 【優化篇】代碼的整形外科：JavaScript 模組化與代碼重構</title><link>/ChiYu-Blob/posts/2025ithomeironmanday31/</link><pubDate>Fri, 19 Sep 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday31/</guid><description>說在前頭～ 既然已經達成30天了，乾脆把庫存一次全部PO完好了～
安安，我是 ChiYu！
昨天，我們為 App 裝上了堅固的大門與門鎖，成功地實現了完整的使用者認證流程。至此，我們 MVP (最小可行產品) 的所有核心功能，已全部開發完成！這是一個巨大的里程碑，再次為堅持到這裡的你，獻上最熱烈的掌聲！
但是，我們的旅程還沒結束。一個專業的專案，不僅僅是功能的堆砌。回頭看看我們的 frontend/script.js 檔案，它現在已經變成一個包含了狀態管理、UI 渲染、API 請求、認證邏輯、事件監聽&amp;hellip; 的巨大怪獸。它雖然能跑，但已經變得難以閱讀和維護。
今天，我們將進行系列文的最後一次程式碼實作，也是從「開發者」邁向「架構師」的關鍵一步。我們將扮演一位「程式碼整形醫師」，為我們臃腫的 script.js 進行一次徹底的「整形手術」，引入專業的 JavaScript 模組化，讓我們的專案達到生產級別的清晰度。
Part 1：前端心法：為什麼說「高內聚，低耦合」是程式碼的最高境界？ 在我們動刀之前，先來理解一下我們手術的指導原則—— 「高內聚，低耦合 (High Cohesion, Low Coupling)」。這聽起來很玄，但卻是衡量所有軟體架構好壞的黃金標準。
高內聚 (High Cohesion)：就像一個專業的「工具箱」。一個好的工具箱裡，所有放鑿子的抽屜裡，只會有各式各樣的鑿子；放螺絲起子的抽屜裡，只會有螺絲起子。 相關的功能，應該被集中在同一個模組裡。 低耦合 (Low Coupling)：代表工具箱裡的每個抽屜，都是獨立的。你拿出鑿子抽屜時，完全不需要擔心會動到螺絲起子的抽屜。 模組與模組之間，應該盡量減少依賴，保持獨立。 我們現在的 script.js，就是一個典型的「低內聚、高耦合」的壞例子：它什麼都做（低內聚），而且裡面所有功能都互相糾纏在一起（高耦合）。
而我們的解決方案，就是使用現代 JavaScript 內建的 ES6 Module (import/export)。它能讓我們像整理工具箱一樣，將不同功能的程式碼，放進各自專屬的 .js 檔案中，然後在需要的時候，精準地「進口 (import)」我們需要的工具即可。
Part 2：Vibe Coding 實戰：詠唱「程式碼重構」的終極咒語 好了，理論武裝完畢！讓我們進入 gemini chat 模式，開始這場重構手術。
【重構後的專案結構】 frontend/ ├── assets/ │ └── logo.png ├── api.js # 只負責跟後端說話 ├── auth.js # 只負責登入登出 ├── state.</description></item><item><title>【完賽感言】左手藍圖，右手魔法：一趟旅程的結束與反思</title><link>/ChiYu-Blob/posts/2025ithomeironmanday32/</link><pubDate>Sat, 20 Sep 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday32/</guid><description>安安！我是 ChiYu！
三十天竟然就這樣過去了耶！回想一開始，真的只有一個超模糊的想法，就憑著一股傻勁跟對 AI 的好奇心與信任，直接衝了，開始了這趟「左手藍圖，右手魔法」的冒險。今天，我們總算成功達陣啦！
說真的，我必須要跟每一個從 Day 1 就有在看文章的夥伴，說聲「感謝！」，也謝謝身旁好友們天天提醒我發文，不要像去年一樣中斷文章。也真心恭喜大家！雖然點閱數不敢說多少，但有人看就讓我很感激了。
OK！最後一天不寫 code，放輕鬆。咱們來幹最後一件，也是最重要的一件事：好好來回顧一下這趟旅程，看看我們到底搞了些什麼。
Part 1：我們的協奏曲：從「空想」到「成品」的過程 這趟旅程，就像一首超 high 的五樂章協奏曲：
第一樂章：蹲馬步！(心法與基礎) 一開始，我們沒急著寫 code。反而是先坐下來，把內功練好。我們確立了「文件驅動開發」的遊戲規則，並學會了用 Git 這台「時光機」。
第二樂章：畫地圖！(前後端大規劃) 我們產出了從《專案章程》到《API 規格書》的全套藍圖，把地基打得超穩。
第三樂章：開秀啦！(AI 高速開發) 地圖畫好了，換「右手」上場施展魔法！我們指揮 AI 把後端的伺服器、資料庫模型，以及前端的網頁介面、按鈕互動通通變出來。
第四樂章：求個穩！(品質與體驗) 我們請來了 GitHub Actions 作為自動化「品管大師」，跑自動化測試。同時也幫我們的 App 裝上「同理心」，優雅處理非同步與錯誤狀態。
第五樂章：收尾！(打磨與升級) 最後，我們像個「程式碼醫生」，把 code 整理得乾乾淨淨（模組化），讓它以後更好照顧。
Part 2：聊聊這套方法：「左手藍圖，右手魔法」的好與壞 「好」：我們賺到了什麼？ 心裡超有底 (Certainty)：先寫文件讓我們在動手前就想清楚了變化，實作時方向感超明確。 又快又好 (Velocity &amp;amp; Quality)：規劃就像是給 AI 這匹脫韁野馬裝上了「護欄」，確保產出品質。 一份「活歷史」 (A Living History)：docs 資料夾記錄了專案從 0 到 1 的完整心路歷程。 「壞」：有什麼地方可以做得更好？ 測試可以玩得更 hardcore：下次可以嘗試結合 DDD 與 TDD，先讓 AI 根據規格書寫測試，再寫程式碼。 文件與文章的扣合：如果能更細緻地解釋文件中每一句話如何影響後面的 code， DDD 的威力會更鮮明。 Part 3：AI 時代，我們人類開發者還能幹嘛？ AI 是超強的副駕駛，但方向盤永遠握在我們手上。我們的價值在於：</description></item></channel></rss>