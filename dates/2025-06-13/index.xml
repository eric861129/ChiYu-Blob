<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>2025-06-13 on ChiYu Code Journey</title><link>/ChiYu-Blob/dates/2025-06-13/</link><description>Recent content in 2025-06-13 on ChiYu Code Journey</description><generator>Hugo -- gohugo.io</generator><language>zh-TW</language><lastBuildDate>Fri, 13 Jun 2025 00:00:00 +0800</lastBuildDate><atom:link href="/ChiYu-Blob/dates/2025-06-13/index.xml" rel="self" type="application/rss+xml"/><item><title>迭代器模式：輕鬆遍歷集合元素</title><link>/ChiYu-Blob/posts/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%BC%95%E9%AC%86%E9%81%8D%E6%AD%B7%E9%9B%86%E5%90%88%E5%85%83%E7%B4%A0/</link><pubDate>Fri, 13 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%BC%95%E9%AC%86%E9%81%8D%E6%AD%B7%E9%9B%86%E5%90%88%E5%85%83%E7%B4%A0/</guid><description>哈囉朋友們～今天來聊聊迭代器模式（Iterator），這個設計模式能幫你輕鬆管理和操作集合中的元素。
🌟 什麼是迭代器模式？ 迭代器模式讓你可以逐一瀏覽集合中的每個元素，而不需知道集合的內部結構。 就像你用音樂 App 播放音樂時，播放清單會自動幫你一首一首播放下一首歌曲，你不需要知道歌曲是怎麼儲存的。這就是迭代器模式的精髓啦！
🤔 什麼情況適合使用迭代器模式？ 以下情況很適合使用迭代器模式：
當你需要循序瀏覽集合中的元素，但不想暴露集合的內部結構。 你希望使用相同的方式來遍歷不同類型的集合。 想要讓集合的操作更加直觀與易用。 🎧 C# 迭代器模式範例：音樂播放清單 我們以「音樂播放清單」為範例，讓你輕鬆理解迭代器模式的應用。
🎵 定義抽象迭代器介面 /// &amp;lt;summary&amp;gt; /// 迭代器介面 /// &amp;lt;/summary&amp;gt; public interface IIterator { /// &amp;lt;summary&amp;gt; /// 是否還有下一首 /// &amp;lt;/summary&amp;gt; bool HasNext(); /// &amp;lt;summary&amp;gt; /// 取得下一首歌曲 /// &amp;lt;/summary&amp;gt; string Next(); } 🎶 建立集合類別（播放清單） using System.Collections.Generic; /// &amp;lt;summary&amp;gt; /// 音樂播放清單 /// &amp;lt;/summary&amp;gt; public class Playlist { private readonly List&amp;lt;string&amp;gt; _songs = new(); // 儲存歌曲 /// &amp;lt;summary&amp;gt; /// 歌曲清單(唯讀) /// &amp;lt;/summary&amp;gt; public IReadOnlyList&amp;lt;string&amp;gt; Songs =&amp;gt; _songs; /// &amp;lt;summary&amp;gt; /// 新增歌曲 /// &amp;lt;/summary&amp;gt; public void AddSong(string song) { _songs.</description></item><item><title>中介者模式：管理複雜溝通的好幫手</title><link>/ChiYu-Blob/posts/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%E7%AE%A1%E7%90%86%E8%A4%87%E9%9B%9C%E6%BA%9D%E9%80%9A%E7%9A%84%E5%A5%BD%E5%B9%AB%E6%89%8B/</link><pubDate>Fri, 13 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%E7%AE%A1%E7%90%86%E8%A4%87%E9%9B%9C%E6%BA%9D%E9%80%9A%E7%9A%84%E5%A5%BD%E5%B9%AB%E6%89%8B/</guid><description>哈囉朋友們～今天要聊的設計模式是中介者模式（Mediator），這個模式能讓你的程式輕鬆管理物件之間複雜的溝通關係。
🌟 中介者模式是什麼？ 中介者模式透過一個中介者物件來協調其他物件之間的互動，避免物件間的直接聯繫導致的混亂。
想像你使用聊天室時，你並不直接跟每個使用者對話，而是透過聊天室作為中介，幫你發送訊息給其他使用者，這樣每個人只要與聊天室溝通即可，簡單明瞭。
🤔 什麼情況適合使用中介者模式？ 以下情況適合使用中介者模式：
當系統內有許多物件需要彼此溝通，關係變得複雜難以管理。 想降低物件間的耦合度，讓系統容易維護與擴充。 想集中管理物件之間的溝通邏輯。 💬 C# 中介者模式範例：聊天室應用程式 我們透過「聊天室」範例來實際展示中介者模式。
💻 定義中介者介面 /// &amp;lt;summary&amp;gt; /// 中介者介面 /// &amp;lt;/summary&amp;gt; public interface IChatMediator { /// &amp;lt;summary&amp;gt; /// 傳送訊息給其他使用者 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;message&amp;#34;&amp;gt;訊息內容&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;user&amp;#34;&amp;gt;發送者&amp;lt;/param&amp;gt; void SendMessage(string message, User user); /// &amp;lt;summary&amp;gt; /// 註冊使用者到聊天室 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;user&amp;#34;&amp;gt;新使用者&amp;lt;/param&amp;gt; void RegisterUser(User user); } 👥 建立具體中介者（聊天室） using System; using System.Collections.Generic; /// &amp;lt;summary&amp;gt; /// 聊天室中介者，負責轉發訊息 /// &amp;lt;/summary&amp;gt; public class ChatMediator : IChatMediator { private readonly List&amp;lt;User&amp;gt; _users = new(); // 聊天室中的使用者名單 /// &amp;lt;inheritdoc /&amp;gt; public void RegisterUser(User user) { _users.</description></item><item><title>備忘錄模式：保存與恢復物件狀態</title><link>/ChiYu-Blob/posts/%E5%82%99%E5%BF%98%E9%8C%84%E6%A8%A1%E5%BC%8F%E4%BF%9D%E5%AD%98%E8%88%87%E6%81%A2%E5%BE%A9%E7%89%A9%E4%BB%B6%E7%8B%80%E6%85%8B/</link><pubDate>Fri, 13 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E5%82%99%E5%BF%98%E9%8C%84%E6%A8%A1%E5%BC%8F%E4%BF%9D%E5%AD%98%E8%88%87%E6%81%A2%E5%BE%A9%E7%89%A9%E4%BB%B6%E7%8B%80%E6%85%8B/</guid><description>哈囉朋友們！今天我們要介紹的是一個超實用的設計模式：備忘錄模式（Memento），透過它，我們可以輕鬆儲存並回復物件的狀態！
🌟 備忘錄模式是什麼？ 備忘錄模式允許你捕捉一個物件的內部狀態，並且在未來需要時，能夠將物件回復到原先的狀態。
就像玩遊戲時的「存檔」和「讀取進度」功能一樣，當你不小心走錯路或失敗時，可以輕鬆回到之前的狀態重新來過。
🤔 什麼情況適合使用備忘錄模式？ 當你有以下情境時，很適合使用備忘錄模式：
需要提供撤銷（undo）或回復（redo）操作。 物件狀態可能頻繁改變，且希望能隨時回到某個特定的狀態。 不想暴露物件內部狀態的細節給外部使用者。 🎮 C# 備忘錄模式範例：遊戲存檔系統 我們透過「遊戲角色存檔」來說明備忘錄模式的應用。
🎲 建立備忘錄（Memento） /// &amp;lt;summary&amp;gt; /// 遊戲狀態備忘錄 /// &amp;lt;/summary&amp;gt; public class GameMemento { /// &amp;lt;summary&amp;gt; /// 等級 /// &amp;lt;/summary&amp;gt; public int Level { get; } /// &amp;lt;summary&amp;gt; /// 生命值 /// &amp;lt;/summary&amp;gt; public int Health { get; } public GameMemento(int level, int health) { Level = level; Health = health; } } 🧙 遊戲角色（Originator） using System; /// &amp;lt;summary&amp;gt; /// 遊戲角色 /// &amp;lt;/summary&amp;gt; public class GameCharacter { /// &amp;lt;summary&amp;gt; /// 等級 /// &amp;lt;/summary&amp;gt; public int Level { get; set; } /// &amp;lt;summary&amp;gt; /// 生命值 /// &amp;lt;/summary&amp;gt; public int Health { get; set; } /// &amp;lt;summary&amp;gt; /// 顯示目前狀態 /// &amp;lt;/summary&amp;gt; public void DisplayStatus() { Console.</description></item><item><title>觀察者模式：即時通知的好幫手</title><link>/ChiYu-Blob/posts/%E8%A7%80%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%8D%B3%E6%99%82%E9%80%9A%E7%9F%A5%E7%9A%84%E5%A5%BD%E5%B9%AB%E6%89%8B/</link><pubDate>Fri, 13 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E8%A7%80%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%8D%B3%E6%99%82%E9%80%9A%E7%9F%A5%E7%9A%84%E5%A5%BD%E5%B9%AB%E6%89%8B/</guid><description>哈囉朋友們～今天我們要聊的是觀察者模式（Observer），這個模式在現實生活中非常常見，讓我們輕鬆理解並學會如何運用它！
🌟 觀察者模式是什麼？ 觀察者模式定義了物件之間一對多的依賴關係，當一個物件的狀態發生變化時，所有依賴它的物件都能立即收到通知。
就像你在追蹤 YouTuber 的頻道一樣，當他們有新影片上傳，你就會收到通知，立刻去觀看新內容。這個頻道就像被觀察的物件（Subject），而你就像是觀察者（Observer）。
🤔 什麼時候適合使用觀察者模式？ 以下情況很適合使用觀察者模式：
當你想要在物件的狀態改變時，自動通知其他相關物件。 希望實現鬆散耦合，提升系統彈性。 當系統的變更可能會影響多個物件時。 🔔 C# 觀察者模式範例：YouTube 頻道通知系統 這次我們以 YouTube 頻道訂閱通知為例，來實作觀察者模式。
📺 建立主題介面（Subject） using System.Collections.Generic; /// &amp;lt;summary&amp;gt; /// 主題介面，負責管理訂閱者 /// &amp;lt;/summary&amp;gt; public interface IChannel { /// &amp;lt;summary&amp;gt; /// 訂閱頻道 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;subscriber&amp;#34;&amp;gt;訂閱者&amp;lt;/param&amp;gt; void Subscribe(ISubscriber subscriber); /// &amp;lt;summary&amp;gt; /// 取消訂閱 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;subscriber&amp;#34;&amp;gt;訂閱者&amp;lt;/param&amp;gt; void Unsubscribe(ISubscriber subscriber); /// &amp;lt;summary&amp;gt; /// 通知所有訂閱者 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;videoTitle&amp;#34;&amp;gt;影片標題&amp;lt;/param&amp;gt; void NotifySubscribers(string videoTitle); } 🎥 具體主題類別（頻道） using System; using System.</description></item><item><title>狀態模式：依狀態改變行為的祕訣</title><link>/ChiYu-Blob/posts/%E7%8B%80%E6%85%8B%E6%A8%A1%E5%BC%8F%E4%BE%9D%E7%8B%80%E6%85%8B%E6%94%B9%E8%AE%8A%E8%A1%8C%E7%82%BA%E7%9A%84%E7%A5%95%E8%A8%A3/</link><pubDate>Fri, 13 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E7%8B%80%E6%85%8B%E6%A8%A1%E5%BC%8F%E4%BE%9D%E7%8B%80%E6%85%8B%E6%94%B9%E8%AE%8A%E8%A1%8C%E7%82%BA%E7%9A%84%E7%A5%95%E8%A8%A3/</guid><description>哈囉朋友們～今天我們要聊的是非常實用且有趣的狀態模式（State），這個模式讓你的物件能夠根據內部狀態的變化而自動改變行為。
🌟 狀態模式是什麼？ 狀態模式允許一個物件在內部狀態改變時改變它的行為，就像換了一個角色一樣。
舉個實際例子，就像是手機的鈴聲狀態，手機在「靜音」模式時，不會響鈴；切換到「響鈴」模式後，就會有聲音通知你。這就是狀態模式的基本概念，透過改變狀態讓物件呈現不同的行為。
🤔 什麼時候適合使用狀態模式？ 以下情況很適合使用狀態模式：
物件的行為會根據內部狀態不同而有所改變。 當有大量條件判斷，且這些條件判斷取決於物件的狀態時。 希望避免使用大量的條件語句（if-else或switch），讓程式更清晰、更易於維護。 📱 C# 狀態模式範例：手機鈴聲模式 我們以手機鈴聲模式為範例來示範狀態模式。
🔕 定義狀態介面 /// &amp;lt;summary&amp;gt; /// 狀態介面 /// &amp;lt;/summary&amp;gt; public interface IMobileState { /// &amp;lt;summary&amp;gt; /// 依目前狀態執行提醒 /// &amp;lt;/summary&amp;gt; void Alert(); } 📳 建立具體狀態類別 using System; /// &amp;lt;summary&amp;gt; /// 響鈴模式 /// &amp;lt;/summary&amp;gt; public class RingingState : IMobileState { /// &amp;lt;inheritdoc /&amp;gt; public void Alert() { Console.WriteLine(&amp;#34;手機正在響鈴...&amp;#34;); } } /// &amp;lt;summary&amp;gt; /// 靜音模式 /// &amp;lt;/summary&amp;gt; public class SilentState : IMobileState { /// &amp;lt;inheritdoc /&amp;gt; public void Alert() { Console.</description></item><item><title>策略模式：靈活切換行為的好幫手</title><link>/ChiYu-Blob/posts/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E9%9D%88%E6%B4%BB%E5%88%87%E6%8F%9B%E8%A1%8C%E7%82%BA%E7%9A%84%E5%A5%BD%E5%B9%AB%E6%89%8B/</link><pubDate>Fri, 13 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E9%9D%88%E6%B4%BB%E5%88%87%E6%8F%9B%E8%A1%8C%E7%82%BA%E7%9A%84%E5%A5%BD%E5%B9%AB%E6%89%8B/</guid><description>哈囉朋友們～今天我們要介紹的設計模式是非常靈活好用的策略模式（Strategy），透過它，你可以輕鬆替換不同的行為，讓你的程式更有彈性！
🌟 策略模式是什麼？ 策略模式允許你定義一系列的演算法，並讓這些演算法可以互相替換，且獨立於使用它們的客戶端。
想像一下，你去旅行時可以選擇不同的交通方式，比如搭飛機、搭高鐵或開車。你根據不同的需求（時間、成本、舒適度）選擇不同的策略，這就是策略模式的核心概念！
🤔 什麼情況適合使用策略模式？ 以下情況很適合使用策略模式：
需要動態地切換不同的演算法或行為。 想避免使用大量的條件判斷語句（if-else 或 switch）。 希望使系統容易擴充，能輕鬆增加新的演算法或行為。 🚗 C# 策略模式範例：旅遊交通工具選擇 這次我們以旅遊時選擇交通工具作為範例。
🚅 定義策略介面 /// &amp;lt;summary&amp;gt; /// 交通策略介面 /// &amp;lt;/summary&amp;gt; public interface ITravelStrategy { /// &amp;lt;summary&amp;gt; /// 前往指定目的地 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;destination&amp;#34;&amp;gt;目的地&amp;lt;/param&amp;gt; void Travel(string destination); } ✈️ 建立具體策略類別 using System; /// &amp;lt;summary&amp;gt; /// 飛機策略 /// &amp;lt;/summary&amp;gt; public class PlaneStrategy : ITravelStrategy { public void Travel(string destination) { Console.WriteLine($&amp;#34;搭飛機前往 {destination}&amp;#34;); } } /// &amp;lt;summary&amp;gt; /// 高鐵策略 /// &amp;lt;/summary&amp;gt; public class HighSpeedRailStrategy : ITravelStrategy { public void Travel(string destination) { Console.</description></item><item><title>模板方法模式：固定流程靈活實作</title><link>/ChiYu-Blob/posts/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%9B%BA%E5%AE%9A%E6%B5%81%E7%A8%8B%E9%9D%88%E6%B4%BB%E5%AF%A6%E4%BD%9C/</link><pubDate>Fri, 13 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%9B%BA%E5%AE%9A%E6%B5%81%E7%A8%8B%E9%9D%88%E6%B4%BB%E5%AF%A6%E4%BD%9C/</guid><description>哈囉朋友們～今天我們要介紹的是非常實用且常見的模板方法模式（Template Method），透過它你可以固定一系列的步驟，讓子類別靈活地去實現細節。
🌟 模板方法模式是什麼？ 模板方法模式定義了一個演算法的骨架，並將一些步驟延遲到子類別去實現。這樣的設計可以確保演算法的結構保持一致，但又能靈活地調整細節。
例如，你在製作各種口味的披薩時，無論是海鮮披薩還是夏威夷披薩，都有一個基本的製作步驟（揉麵團、加醬料、放餡料、烤披薩）。模板方法模式就是把這個固定步驟封裝起來，讓子類別專注於實現每個細節。
🤔 什麼時候適合使用模板方法模式？ 以下情況很適合使用模板方法模式：
當你有一系列步驟，但每個步驟的具體實現可能會有所不同。 想確保演算法的結構不被子類別改變，保證流程的統一性。 希望提供一個明確的框架，讓開發者能快速實現不同的具體步驟。 🍕 C# 模板方法模式範例：披薩製作流程 這次我們以製作披薩的流程作為範例。
🍅 建立抽象類別 using System; /// &amp;lt;summary&amp;gt; /// 披薩製作抽象類別 /// &amp;lt;/summary&amp;gt; public abstract class PizzaMaker { /// &amp;lt;summary&amp;gt; /// 製作披薩的流程 /// &amp;lt;/summary&amp;gt; public void MakePizza() { PrepareDough(); AddSauce(); AddToppings(); BakePizza(); } /// &amp;lt;summary&amp;gt; /// 準備麵團 /// &amp;lt;/summary&amp;gt; protected void PrepareDough() { Console.WriteLine(&amp;#34;揉製麵團...&amp;#34;); } /// &amp;lt;summary&amp;gt; /// 加入醬料 /// &amp;lt;/summary&amp;gt; protected void AddSauce() { Console.WriteLine(&amp;#34;加入醬料...&amp;#34;); } /// &amp;lt;summary&amp;gt; /// 加入配料，由子類別實作 /// &amp;lt;/summary&amp;gt; protected abstract void AddToppings(); /// &amp;lt;summary&amp;gt; /// 烘烤披薩 /// &amp;lt;/summary&amp;gt; protected void BakePizza() { Console.</description></item><item><title>訪問者模式：新增功能不動既有架構</title><link>/ChiYu-Blob/posts/%E8%A8%AA%E5%95%8F%E8%80%85%E6%A8%A1%E5%BC%8F%E6%96%B0%E5%A2%9E%E5%8A%9F%E8%83%BD%E4%B8%8D%E5%8B%95%E6%97%A2%E6%9C%89%E6%9E%B6%E6%A7%8B/</link><pubDate>Fri, 13 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E8%A8%AA%E5%95%8F%E8%80%85%E6%A8%A1%E5%BC%8F%E6%96%B0%E5%A2%9E%E5%8A%9F%E8%83%BD%E4%B8%8D%E5%8B%95%E6%97%A2%E6%9C%89%E6%9E%B6%E6%A7%8B/</guid><description>哈囉朋友們～今天要介紹的是比較特殊但十分強大的訪問者模式（Visitor），透過這個模式，你可以在不修改物件結構的情況下輕鬆新增功能！
🌟 訪問者模式是什麼？ 訪問者模式允許你在不改變現有類別結構的情況下，為類別增加新的操作。
舉個例子，就像遊樂園的各種設施，每個訪客來到遊樂園會玩不同的設施。設施本身不會改變，但每位訪客的行為和感受可能不同，訪客們就是訪問者（Visitor），設施則是被訪問的元素（Element）。
🤔 什麼情況適合使用訪問者模式？ 以下情況很適合使用訪問者模式：
當你需要對一個物件結構新增許多不同且不相關的操作。 希望在不修改現有結構的情況下，能輕鬆增加新功能。 當物件結構相對穩定，但操作或功能可能經常變動時。 🎢 C# 訪問者模式範例：遊樂園設施與訪客 這次我們以遊樂園的訪客與設施為例。
🎠 定義元素介面（設施） /// &amp;lt;summary&amp;gt; /// 設施介面 /// &amp;lt;/summary&amp;gt; public interface IAmusementFacility { /// &amp;lt;summary&amp;gt; /// 接受訪問者 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;visitor&amp;#34;&amp;gt;訪問者&amp;lt;/param&amp;gt; void Accept(IVisitor visitor); } 🎡 具體設施類別 /// &amp;lt;summary&amp;gt; /// 雲霄飛車 /// &amp;lt;/summary&amp;gt; public class RollerCoaster : IAmusementFacility { public void Accept(IVisitor visitor) { visitor.Visit(this); } } /// &amp;lt;summary&amp;gt; /// 摩天輪 /// &amp;lt;/summary&amp;gt; public class FerrisWheel : IAmusementFacility { public void Accept(IVisitor visitor) { visitor.</description></item></channel></rss>