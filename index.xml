<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ChiYu's Blob on ChiYu Code Journey</title><link>/ChiYu-Blob/</link><description>Recent content in ChiYu's Blob on ChiYu Code Journey</description><generator>Hugo -- gohugo.io</generator><language>zh-TW</language><lastBuildDate>Mon, 29 Dec 2025 00:00:00 +0800</lastBuildDate><atom:link href="/ChiYu-Blob/index.xml" rel="self" type="application/rss+xml"/><item><title>【撰寫指南】Hugo 文章 Front Matter 參數詳解</title><link>/ChiYu-Blob/posts/hugo-front-matter-guide/</link><pubDate>Wed, 17 Dec 2025 16:50:00 +0800</pubDate><guid>/ChiYu-Blob/posts/hugo-front-matter-guide/</guid><description>這篇文章是為了快速查閱 Front Matter (文章開頭的設定區塊) 而建立的範本。
完整範本 (可以直接複製) +++ title = &amp;#34;文章標題&amp;#34; date = 2025-12-17T16:00:00+08:00 slug = &amp;#34;自訂文章網址-Slug&amp;#34; # 顯示於側邊欄日曆的日期 (通常與 date 相同) dates = [&amp;#34;2025-12-17&amp;#34;] # 標籤與系列 tags = [&amp;#34;Tag1&amp;#34;, &amp;#34;Tag2&amp;#34;] series = [&amp;#34;系列名稱&amp;#34;] categories = [&amp;#34;分類名稱&amp;#34;] # 系列文章排序 (數字越小越前面) weight = 10 # 手動指定上下篇 (選填，若不填則依時間自動排序) # 填寫對應文章的 Slug 或 檔名 (不含副檔名) prev_post_slug = &amp;#34;&amp;#34; next_post_slug = &amp;#34;&amp;#34; # 是否為草稿 (true 則不會被發布) draft = true +++ 參數詳細說明 基礎設定 title: 文章的主標題。 date: 發布日期。Hugo 會根據這個日期進行排序。 slug: 自定義網址的尾端。例如設為 my-post，文章網址就會是 .</description></item><item><title>Day 1: 【啟程】嘿，AI！我們來做個網站，但這次，我們約法三章</title><link>/ChiYu-Blob/posts/2025ithomeironmanday1/</link><pubDate>Wed, 20 Aug 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday1/</guid><description>Day 0: 【啟程】嘿，AI！我們來做個網站，但這次，我們約法三章 嘿，大家好啊！我是 ChiYu，也可以叫我 Eric。
寫了五年的 Code，平常都在跟 .Net 還有 Azure 打交道。簡單說，就是個靠鍵盤吃飯的工程師啦。去年有參賽，但中途忘記發文中斷!!! 希望今年能培養好習慣每天準時一篇不斷更!!!
這趟旅程，是為誰準備的？ 在開始之前，我想先說說，這系列文章是為誰而寫的。
你可能完全沒有程式背景，但對現在最紅的 Vibe Coding 充滿好奇嗎？你是不是也想跟上這波 AI 浪潮，試著自己動手做點東西，甚至想成為一名開發者呢？
如果答案是「YES」，那這系列文章就是為你量身打造的！
我們不只玩 Vibe Coding，我更希望在過程中，帶你認識一些重要的「開發觀念」。像是什麼是「前端」、「後端」？什麼是「API」？版本要怎麼控制？這些在專業開發中一定會用到的術語和工作流程，我會用最白話的方式，融入到我們的實作裡。
所以，別擔心自己是「程式小白」。跟著我，我們一步一步來，不只做出一個酷專案，更要幫你打下成為開發者的堅實基礎。
那個…我只是想要一台腳踏車，你給我一艘航空母艦幹嘛？ 身為工程師，有新玩具當然會想要跟著玩看看，但純粹的 Vibe Coding 下去，到底會得到什麼？
我的故事是這樣的：我想說來做個最經典最常見的「待辦事項清單 (Todo List)」練練手感。就對 AI 下了一個超簡單的指令：「幫我做個 Todo List 網站，要有CRUD的功能，並且想要一個簡約的UI，我希望專案要越完整越好。」
那時候我心裡想的超單純：啊不就一個 HTML，裡面塞一點點 JavaScript 就搞定了嗎？簡單、好懂、我自己要改也方便。
結果呢？AI 老兄一頓操作猛如虎，給我生出了一整個專案包。我點開資料夾，下巴直接掉下來。哇靠，這是怎樣？React、Node.js、Express、MongoDB……全家餐都來了！
老實說，這 App 能跑，但感覺完全歪掉了。我只是想要一台腳踏車，結果 AI 給了我一艘航空母艦。這要我怎麼騎……啊不是，這已經超出我所了解與熟悉的範圍，且專案規模整個失控！會導致這樣的原因有各種可能，可能是我的Prompt太過鬆散，但又出現了這個「專案要越完整越好」這個關鍵字，也可能是AI自己異想天開等等。出現這種「技術奇觀」讓我意識到，完全放任的 Vibe Coding 真的很容易失控，變成一個你根本不想碰的燙手山芋。
而且老實說，有時候在社群上看到一些分享，真的會替他們頭痛，曾看到有人在分享，他的朋友VibeCoding出了一個購物網站，但登入系統不論怎麼打密碼都可以登入，或是開發出的網站把所有應加密資訊顯露出去。
我完全懂拿到新玩具那種興奮感，AI 工具也確實是開發上的一大福音，而且也讓許多程式小白能體會成為一名工程師的感覺!! 但問題出在「盲目相信」。當專案一搞大，你很快會發現：東西越來越難改、AI 給的專案根本跑不起來、就算跑起來了，噴出來的 BUG 你也看不懂。更慘的是，你叫 AI 修，它修完又生出新的 BUG，最後就卡在一個無限迴圈裡動彈不得。這對沒有太多開發經驗的人來說，真的是個超級大坑。
為魔法裝上韁繩：左手藍圖，右手魔法 所以咧？難道就要這樣放棄 AI 這個神隊友嗎？當然不行！
這就像拿到一把絕世神兵，你不能因為它太利就把它丟掉，而是要學會怎麼駕馭它。所以我就開始找方法，到底要怎麼做才能讓 AI 乖乖聽話，然後我找到了這個說新不新說舊不舊的開發法則：</description></item><item><title>Day 2: 【心法篇】開發者的航海圖：什麼是文件驅動開發 (DDD)？</title><link>/ChiYu-Blob/posts/2025ithomeironmanday2/</link><pubDate>Thu, 21 Aug 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday2/</guid><description>嘿，大家好啊！我是 ChiYu。
昨天聊到 AI 開發，一不小心就把小小的「腳踏車」專案搞成一艘「航空母艦」，超頭痛的對吧？這種「AI 太能幹」造成的失控，在 Vibe Coding 的浪潮下，只會越來越常見。這不只是個笑話，它反映了一個深刻的問題：當我們擁有無窮的力量（AI），卻沒有明確的方向時，混亂是必然的結果。
那到底要怎麼辦，才能讓 AI 乖乖聽話，不要自己亂加戲？我們該如何從一個被 AI 牽著鼻子走的「使用者」，蛻變成一個能駕馭 AI 的「指揮家」？
今天就要來分享我的秘密武器，一個能讓你從「玩票」變「專業」的酷東西：文件驅動開發 (Document-Driven Development, DDD)！
我知道，一聽到「文件」兩個字，你可能就想關掉了，感覺超無聊，對吧？先別走！相信我，這東西比你想的有趣多了，它就是我們駕馭 Vibe Coding 這匹野馬最重要的「韁繩」！這不是要你回到寫八股文的老路，而是要教你一種用「文字」來駕馭「程式碼」的現代魔法。
核心精神：「左移」你的思考 (Shift-Left) 在蓋房子前，你會先畫好藍圖，還是直接叫工人來亂蓋一通？當然是先畫藍圖嘛！這個簡單的道理，在軟體開發中卻常常被遺忘。
這在我們寫程式的世界裡，有個很潮的說法叫 「左移」(Shift-Left)。意思就是，把所有燒腦的規劃、設計工作，全部往前挪。這就像規劃一場環島旅行，你不會等到出發當天才在想要去哪裡、住哪裡，對吧？你肯定會提前好幾個禮拜，就把路線、住宿、景點都研究得一清二楚。
為什麼？因為一開始在紙上改個設計，頂多花幾分鐘；等到牆都蓋好了才說要改，那可就得花好幾天敲掉重來，不只工人想罷工，連設計師都會想掐死你！修改的成本，隨著時間往右，是呈指數級暴增的，這不只是時間成本，更是團隊士氣的巨大耗損。一個小小的早期決策失誤，到後期可能會演變成需要數週才能修復的**「技術債」**，那種感覺真的糟透了。
DDD 就是這個概念的最佳實踐，先想清楚，再動手！
所以，DDD 到底在幹嘛？ 所以說，DDD 到底是在幹嘛？超簡單，就是一個規矩：
沒文件，就沒有 Code！
這聽起來可能有點極端，但它的核心是一種紀律，一種能帶來巨大回報的紀律。整個開發流程大概是這樣：
先動腦，再動手：有任何新想法？第一步絕對不是打開 VS Code，而是先把它跟 AI「聊」成一份具體的規格文件。這個「聊」的過程，其實就是在強迫我們把腦中模糊不清的想法，具象化成有邏輯、有結構的文字。很多時候，光是在這個階段，你就會發現自己想法中的矛盾與漏洞。 在文件上吵架：所有的討論、修改，都在文件上搞定。這是一種健康的吵架！把所有可能的誤解、模糊地帶，在程式碼誕生前就全部解決掉。在文件上吵架，成本是零；但在程式碼上吵架，成本可能就是好幾個工程師好幾天的工時，改文字總比改程式碼便宜吧？ 文件就是聖旨：文件一旦定稿，就是不能亂改的「施工命令單」。它成為了我們後續所有開發工作的唯一依據。這份文件就像是我們與「未來的自己」以及「AI」之間簽訂的一份契約，確保大家永遠在同一個頻道上。 寫 Code 只是翻譯：這時候，寫程式就變得很單純，不再是天馬行空的創作，而是把文件上的東西，有效率地「翻譯」成程式碼而已。開發者的認知負擔被大幅降低，我們可以更專注在如何把程式碼寫得更乾淨、更有效率，而不是一邊寫一邊想「我到底要做什麼來著？」。 面對現實：我知道，你討厭寫文件 好啦，我知道你在想什麼。講到「寫文件」，大概九成的工程師（包括我！）都會翻白眼。心裡想著：
「唉，又來了」「敏捷開發不是說不用寫文件嗎？」「我有這時間不如多寫幾行 Code」。
這真的不是我們的錯！很多人誤解了「敏捷開發」的精神，它強調的是「可工作的軟體 勝於 詳盡的文件」，而不是「不要文件」。一份沒人看的、過時的文件確實是垃圾；但一份能指引方向、建立共識的「活文件」，卻是專案成功的基石。以前寫文件又痛苦又沒用，誰想寫啊？我們都經歷過那種「文件是個謊言」的專案，規格書上寫 A，但程式碼早就改成 B 了，這種文件不如不要有。
但這次，我們不自己動手寫 但！這次完全不一樣了！
我們不用自己一個字一個字地敲文件！
我們要讓 AI 當我們的專屬寫手。我們的工作，從苦哈哈的打字員，升級成動動嘴巴的決策者。開發的瓶頸，不再是我們的打字速度，而是我們思想的清晰度。
說白了，「下指令 (Prompt)」本身，就是一種新時代的「規格設計」啦！ 我們的價值，從「如何實現」，轉變成了「如何清晰地定義問題」。這是一種更高層次的抽象能力，也是未來開發者的核心競爭力。
「好文件」不是廢話文學，而是唯一的真理 既然有 AI 幫忙，我們更應該專注在做出「有用的」文件。這份文件就是我們專案的 「單一真理來源 (Single Source of Truth, SSoT)」，所有人都得聽它的！</description></item><item><title>Day 3: 【工具篇 #1】萬丈高樓平地起：建置本地開發環境</title><link>/ChiYu-Blob/posts/2025ithomeironmanday3/</link><pubDate>Fri, 22 Aug 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday3/</guid><description>安安，我是 ChiYu！
昨天，我們在腦中畫好了宏偉的建築藍圖 (DDD)，確立了「文件驅動開發」這個核心心法。今天，理論課結束，我們要開始動手了！我們將扮演「技師與軍火官」的角色，為接下來的開發大戰，準備好我們最精良的「施工機具」與「建材」。
「工欲善其事，必先利其器」。一個乾淨、強大、順手的開發環境，是所有偉大專案的起點。今天的目標非常明確：手把手帶你完成所有必要的環境安裝，包括 Python、Node.js，以及我們的開發神器 VS Code。
Part 1：我們的「總工具箱」：安裝 Visual Studio Code (VS Code) 在無數的程式碼編輯器中，VS Code 已經成為了現代開發的絕對主流。為什麼？原因很簡單：它免費、開源、速度快、功能強大，而且擁有全世界最豐富的「擴充功能」生態系，可以讓我們把它打造成任何我們想要的樣子。
Step 1：安裝 VS Code
VS Code 官網下載連結：https://code.visualstudio.com/ 請直接前往官網，網站會自動偵測你的作業系統（Windows, Mac, Linux），下載對應的版本，然後像安裝普通軟體一樣，無腦下一步到底就對了。
Step 2：初次見面！認識 VS Code 的介面
當你第一次打開 VS Code，可能會看到一個歡迎畫面。別怕，我們先來認識一下它的幾個主要區域，未來它們會成為你最熟悉的朋友：
左側活動列 (Activity Bar)：最左邊那一排圖示，是你切換不同功能的入口，例如檔案總管、搜尋、原始碼管理（就是 Git）、以及我們待會要安裝的擴充功能。 側邊欄 (Side Bar)：點擊活動列的圖示後，左邊展開的區域就是側邊欄。最常用到的就是「檔案總管」，我們專案的所有資料夾和檔案都會顯示在這裡。 編輯區 (Editor)：中間最大塊的區域，就是我們主要編寫程式碼與文件的地方。 底部面板 (Panel)：下方可以拉開的區域，這裡非常重要，因為它包含了「終端機 (Terminal)」。我們之後所有的魔法指令，都會在這裡詠唱！ Part 2：VS Code 威力升級：必備擴充功能 (Extensions) 如果說 VS Code 是一個功能強大的手機，那「擴充功能」就是上面的 App，能讓你的手機擁有各種超能力。
請在左側活動列找到像「俄羅斯方塊」一樣的圖示，那就是擴充功能的市集。點擊它，然後在搜尋框裡，找到並全部安裝以下幾個我們這次旅程必備的神級外掛：
Python (Microsoft) 這是什麼：微軟官方出品的 Python 語言支援包。 為什麼必裝：裝上它，你的 VS Code 才會真正「看懂」Python。它提供了智慧程式碼提示、自動補全、語法錯誤檢查、除錯等所有核心功能，直接將 VS Code 變身為一個頂級的 Python IDE。 Prettier - Code formatter 這是什麼：你的程式碼專屬造型師。 為什麼必裝：它會在每次存檔時，自動把你的程式碼整理成一個統一、乾淨、漂亮的風格。從此告別為了「兩個空格還是四個空格」而引發的聖戰！ GitLens — Git supercharged 這是什麼：Git 的透視眼鏡。 為什麼必裝：它能讓你直接在程式碼的每一行旁邊，看到這行是誰、在什麼時候修改的，極大地增強了 VS Code 的版本控制能力。 Thunder Client 這是什麼：內建在 VS Code 裡的 API 測試神器。 為什麼必裝：我們之後會用它來測試我們寫好的後端 API，不用再開別的軟體，非常方便。先裝起來放！ Markdown Preview Mermaid Support 這是什麼：讓你的文件活起來的魔法。 為什麼必裝：我們之後會用 Mermaid.</description></item><item><title>想快速打造個人部落格？試試 HugoBlobTemplate，極簡、開源，讓你專注寫作！</title><link>/ChiYu-Blob/posts/%E6%83%B3%E5%BF%AB%E9%80%9F%E6%89%93%E9%80%A0%E5%80%8B%E4%BA%BA%E9%83%A8%E8%90%BD%E6%A0%BC%E8%A9%A6%E8%A9%A6-hugoblobtemplate%E6%A5%B5%E7%B0%A1%E9%96%8B%E6%BA%90%E8%AE%93%E4%BD%A0%E5%B0%88%E6%B3%A8%E5%AF%AB%E4%BD%9C/</link><pubDate>Wed, 11 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E6%83%B3%E5%BF%AB%E9%80%9F%E6%89%93%E9%80%A0%E5%80%8B%E4%BA%BA%E9%83%A8%E8%90%BD%E6%A0%BC%E8%A9%A6%E8%A9%A6-hugoblobtemplate%E6%A5%B5%E7%B0%A1%E9%96%8B%E6%BA%90%E8%AE%93%E4%BD%A0%E5%B0%88%E6%B3%A8%E5%AF%AB%E4%BD%9C/</guid><description>【文章最終整合版】 想快速打造個人部落格？試試 HugoBlobTemplate，極簡、開源，讓你專注寫作！ 你是不是也曾想過，要建立一個屬於自己的小天地，放些技術筆記、生活隨筆，或是作品集？但一想到要租主機、搞定複雜的後台設定、擔心網站速度，頭就開始痛了？
別擔心！今天就是要來跟你介紹一個我完成的開源專案：HugoBlobTemplate，它能讓你幾乎零成本、超快速地建立一個美觀又實用的個人部落格。
點我前往 HugoBlobTemplate 的 GitHub 專案頁面 這到底是什麼？適合誰用？ 簡單來說，HugoBlobTemplate 是一個基於 Hugo 這個靜態網站生成器所打造的「部落格模板」。
你可能聽過 WordPress，但 Hugo 不一樣。它不會動態去讀取資料庫，而是在你寫完文章後，直接「生成」一整個網站的 HTML 靜態檔案。這樣做有幾個超強的優點：
快！快到飛起！ 因為使用者瀏覽的都只是純粹的 HTML，沒有後端處理、沒有資料庫查詢，載入速度幾乎是瞬間完成。 安全！ 沒有後台登入頁面、沒有資料庫，自然就少了很多被攻擊的風險。 便宜（甚至免費）！ 你可以把生成好的網站檔案，輕鬆部署到像是 GitHub Pages、Netlify 或 Vercel 這些提供免費託管服務的平台上。 所以，HugoBlobTemplate 就是幫你把 Hugo 的環境都設定好，給你一個「開箱即用」的部落格樣式。它特別適合：
工程師/學生：想記錄技術筆記、學習心得，需要一個簡潔、支援程式碼高亮的平台。 文字創作者：不想被複雜的編輯器綁架，希望專注在內容本身。 任何人：想擁有一個「自己的」網站，不想付月費，也不想花大把時間在維護上。 HugoBlobTemplate 有哪些貼心的功能？ 這個專案雖然主打極簡，但在基礎功能上一點也不馬虎。我已經幫你內建了許多實用的功能：
內建亮色/暗色模式：自動偵測使用者系統的偏好設定，也可以讓訪客手動切換，非常貼心。 社群連結整合：想放你的 GitHub、LinkedIn 等連結？只要在設定檔裡填上你的帳號，就會自動出現在個人介紹區塊。 SEO 友善：專案已經幫你處理好基礎的搜尋引擎優化（SEO），讓你的內容更容易被 Google 等搜尋引擎找到。 響應式設計 (RWD)：無論你的訪客用的是電腦、平板還是手機，網站版面都能自動適應，提供最佳的閱讀體驗。 好！我想用！該如何開始？ 整個過程比你想像的還要簡單，大概可以分成以下幾步：
第 1 步：準備環境 (若想在本機預覽) 如果你想在自己的電腦上看到網站的即時變化，需要先安裝兩樣東西：
Git：用來抓取專案程式碼。 Hugo：用來產生網站的核心工具。（ 官方安裝說明 ） 第 2 步：把專案抓下來 打開你的終端機，輸入以下指令：
git clone https://github.</description></item><item><title>Day 4: 【工具篇 #2】程式碼的時光機：Git 與 GitHub 版本控制</title><link>/ChiYu-Blob/posts/2025ithomeironmanday4/</link><pubDate>Sat, 23 Aug 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday4/</guid><description>安安，我是 ChiYu！
昨天，我們扮演了「技師與軍火官」的角色，把我們的駕駛艙 (VS Code) 從毛胚屋打造成了精裝房，並備妥了所有核心的建材與燃料 (Python &amp;amp; Node.js)。
我們的開發環境已經準備就緒，但在我們正式動工、蓋起萬丈高樓之前，還有一件至關重要的事要做：我們需要為我們的建築工地，安裝一套最頂級的「安全監控系統」與「時光倒流機器」。
今天，我們就要來深入軟體開發中最最最重要的觀念——版本控制，並親手設定我們專案的「雲端保險庫」與「時光機總部」：Git 與 GitHub。
Part 1：核心觀念：什麼是「版本控制」？ 在開始操作前，我們先用白話文搞懂什麼是「版控 (版本控制)」。你可以把它想像成玩遊戲時的「存檔」機制。
你在寫報告時，是不是常常會這樣做：企劃書_v1.docx、企劃書_v2_改了標題.docx、企劃書_最終版.docx、企劃書_最終版真的啦.docx？這就是最原始、最土炮的「手動版本控制」。你害怕把東西改壞，所以存了一大堆備份，最後連自己都搞不清楚哪個才是最新的。
而「版本控制系統」就是一個專業、自動化的工具，來幫你優雅地做這件事。它的好處有：
追蹤歷史紀錄：系統會幫你記錄每一次的「存檔」，你可以清楚看到何時、何人、修改了什麼內容。 隨時回到過去：如果不小心把專案改爛了、功能寫壞了，你可以像讀取遊戲存檔一樣，輕鬆回到任何一個過去的版本。 方便多人協作：當很多人一起開發同一個專案時，版控系統能聰明地幫大家整合程式碼，避免互相覆蓋的慘劇。 鼓勵大膽實驗：這是最棒的一點！它讓你可以隨時開一個「平行時空」，在裡面隨便亂搞、嘗試新功能，而完全不用擔心會把主線劇情（主要程式碼）搞砸。 Part 2：釐清工具：Git 與 GitHub 的關係 很多新手會把這兩個搞混，我們用一個簡單的比喻來拆解：
Git - 你的程式碼時光機 它是什麼：Git 是一個「版本控制系統」，是你電腦裡的工具，用來建立「存檔點 (commit)」。 Git 官網：https://git-scm.com/ (建議先下載安裝) GitHub - 你的雲端程式碼基地 它是什麼：GitHub 是一個「提供 Git 託管服務的網站平台」。如果說 Git 是 Word 軟體，那 GitHub 就是 Google Docs。你可以在 GitHub 上建立一個專案倉庫 (Repository)，然後把你用 Git 管理的本地專案，同步一份到這個雲端倉庫裡。 GitHub 官網：https://github.com/ Part 3：最重要的觀念：分支 (Branching) - 你的平行時空 在我們建立倉庫之前，你必須先理解「分支 (Branching)」這個專業開發中最重要的概念。
你可以把你的專案想像成一部電影的「主線劇情」，這條主線就是所謂的 main 分支。main 分支上的程式碼，永遠都必須是最穩定、可以正常運作的版本。</description></item><item><title>讓部落格成為你的形狀：Hugo 個人化設定終極指南</title><link>/ChiYu-Blob/posts/%E8%AE%93%E9%83%A8%E8%90%BD%E6%A0%BC%E6%88%90%E7%82%BA%E4%BD%A0%E7%9A%84%E5%BD%A2%E7%8B%80hugo-%E5%80%8B%E4%BA%BA%E5%8C%96%E8%A8%AD%E5%AE%9A%E7%B5%82%E6%A5%B5%E6%8C%87%E5%8D%97/</link><pubDate>Wed, 11 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E8%AE%93%E9%83%A8%E8%90%BD%E6%A0%BC%E6%88%90%E7%82%BA%E4%BD%A0%E7%9A%84%E5%BD%A2%E7%8B%80hugo-%E5%80%8B%E4%BA%BA%E5%8C%96%E8%A8%AD%E5%AE%9A%E7%B5%82%E6%A5%B5%E6%8C%87%E5%8D%97/</guid><description>讓部落格成為你的形狀：Hugo 個人化設定終極指南 當你成功部署了這個部落格模板，恭喜你完成了第一步！但真正的樂趣現在才開始：將這個公版的部落格，徹底改造成專屬於你的樣子。
這篇文章是一份完整的個人化指南，將帶你從裡到外，一步步設定與調整，打造出獨一無二的個人網站。
第一站：核心設定 (hugo.toml) hugo.toml 是你部落格的「大腦」與「指揮中心」，幾乎所有基本資訊都在這裡設定。
1. 網站基本資訊 首先，打開 hugo.toml 檔案，找到並修改以下幾個關鍵欄位：
baseURL: (最重要!) 這裡必須換成你未來部署網站的最終網址。如果是使用 GitHub Pages，通常會是 https://&amp;lt;你的GitHub帳號&amp;gt;.github.io/&amp;lt;你的專案名稱&amp;gt;/。 title: 你部落格的主要名稱，會顯示在瀏覽器分頁和網站標頭上。 [params] description: 網站的副標題或描述，會顯示在首頁的大標題下方。 [params.author] name: 你的名字或暱稱。 2. 你的社交連結 在 hugo.toml 中，有一個 [params.social] 區塊，你可以在這裡新增、刪除或修改你的社群媒體連結。
# hugo.toml [params.social] GitHub = &amp;#34;https://github.com/eric861129&amp;#34; LinkedIn = &amp;#34;https://www.linkedin.com/in/chiyu-huang/&amp;#34; Threads = &amp;#34;https://www.threads.com/@chiyuisme&amp;#34; # 你也可以新增自己的，例如： # Twitter = &amp;#34;https://twitter.com/your_account&amp;#34; 3. 啟用你自己的留言區 (Giscus) 這個部落格模板整合了 Giscus 留言系統。為了讓讀者能在你的部落格留言，而不是在我的模板專案上，你必須進行設定：
跟隨 Giscus 官網的教學，為你自己的 GitHub 專案啟用 Giscus。 將 hugo.toml 檔案中 [params.giscus] 的設定值，換成你在 Giscus 官網上取得的你自己的設定。 這些設定會被 layouts/_default/baseof.</description></item><item><title>Day 5: 【工具篇 #3】終端機裡的魔法：什麼是 Vibe Coding 與 Gemini CLI？</title><link>/ChiYu-Blob/posts/2025ithomeironmanday5/</link><pubDate>Sun, 24 Aug 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday5/</guid><description>安安，我是 ChiYu！
昨天，我們完成了技師的工作，為我們的專案蓋好了雲端機棚 (GitHub)，也把駕駛艙 (VS Code) 裝潢得舒適又專業。硬體設施全部到位，現在，是時候為我們的專案注入真正的「靈魂」了。
今天，我們將迎來本系列第一個令人心跳加速的轉捩點。我們不只要安裝「引擎」，我們還要學會詠唱「魔法的咒語」，真正地與 AI 對話，把我們的意念灌注到終端機之中！準備好迎接你的「魔法覺醒」了嗎？
Part 1：到底什麼是「Vibe Coding」？ 最近你可能常常聽到 Vibe Coding 這個詞，但它到底是什麼意思？
它不是什麼艱深的技術或框架，而是一種徹底顛覆傳統的開發風格或心態。
這徹底顛覆了我們過去學習程式的模式。以前我們學的是機器的**「語法 (Syntax)」，現在我們學的是如何更精準地「表達意圖 (Intent)」**。你的中文能力，從未像此刻一樣，直接與你的生產力掛鉤。
這就像你從一個樂手，變成了一個指揮家。你不用親自演奏每個樂器，你只需要揮舞你的指揮法杖，告訴整個樂團（AI），這一段要「雄壯激昂」、那一段要「溫柔婉約」。你負責定義**「氛圍 (Vibe)」**，AI 負責實現它。
而我們今天要安裝的 Gemini CLI，就是我們的第一支客製化指揮法杖。
Part 2：我們的魔法法杖：Gemini CLI，你的開源 AI 代理人 CLI 的全名是 Command Line Interface (命令列介面)。你不用害怕這個詞，它指的就是我們在 VS Code 裡打開的那個黑黑的、看起來很像駭客電影的「終端機」視窗。
我們要介紹的 gemini-cli，根據 Google 官方的說法，它不只是一個工具，更是一個**「開源的 AI 代理人 (Open Source AI Agent)」**。這代表它是一個住在你終端機裡的智慧夥伴，可以幫你讀取檔案、存取網路、甚至與其他工具串接，來完成更複雜的任務。
官方參考資料 對 gemini-cli 有興趣的讀者，可以直接參考它的官方 GitHub 倉庫與 Google 官方部落格文章：
GitHub: https://github.com/google-gemini/gemini-cli Google Blog: https://blog.google/intl/zh-tw/products/cloud/gemini-cli-your-open-source-ai-agent/ Part 3：安裝與授權：法杖的鑄造與認主 好的，讓我們開始進行法杖的「鑄造與附魔」！
Step 1：前置作業 - 準備 Node.</description></item><item><title>搞懂設計模式到底是什麼？</title><link>/ChiYu-Blob/posts/%E6%90%9E%E6%87%82%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E9%BA%BC/</link><pubDate>Wed, 11 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E6%90%9E%E6%87%82%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E9%BA%BC/</guid><description>哈囉！最近我決定開始一個新的 Side Project，要來用比較輕鬆的方式跟大家分享一下什麼是「設計模式（Design Patterns）」。
等等先別跑！雖然聽起來很硬，但設計模式其實就是一些「前輩工程師們」留下來的解決問題的好方法。懂了這些，你的程式碼會變得更容易維護，更容易擴充，甚至看起來更專業！（聽起來是不是有點心動了？）
這篇先帶你入個門，我們會聊聊設計模式的概念、分類，最後也會簡單列出一些常見好用的模式，讓你一次搞懂設計模式到底在幹嘛。
🧐 所以，到底什麼是設計模式啊？ 簡單說，設計模式就像是程式設計師之間的「共通語言」。
你一定有過這種經驗：
「欸，我怎麼又寫出這種一團亂的程式碼？」 「這個功能之前不是做過了嗎？為什麼還要再寫一次？」 這時候，如果你腦袋裡裝著幾種設計模式，就像工具箱一樣，你就能更快速地解決這些問題。
設計模式其實就是經過無數開發者實踐後得出的好用解決方案，就像老前輩的私房武功，學起來絕對讓你的程式碼更整齊、更有架構，也比較不容易踩坑。
設計模式可以怎麼分？ 一般來說，設計模式分成三大類：
建立型模式（Creational Patterns）
重點在教你怎麼更聰明地「建立」物件，避免程式碼越寫越複雜。
結構型模式（Structural Patterns）
教你怎麼把物件組合在一起，像拼樂高一樣，輕鬆擴充或調整程式的架構。
行為型模式（Behavioral Patterns）
教你搞定物件之間複雜的「溝通與互動」，讓你的程式碼彼此合作起來更加順暢。
是不是聽起來越來越清楚了？接下來我們更進一步，列出每個分類下的常見模式，讓你一眼看懂設計模式家族有什麼好貨！
常見設計模式大集合 這邊先條列式介紹，未來我會用獨立的文章、一個一個講清楚：
🚀 建立型模式（Creational） 單例模式（Singleton） 工廠方法模式（Factory Method） 抽象工廠模式（Abstract Factory） 原型模式（Prototype） 建造者模式（Builder） 📌 特點： 這一類幫你搞定物件的建立，讓你不用一直煩惱物件從哪裡來，要怎麼產生之類的問題。
2. 結構型模式（Structural） 介面卡模式（Adapter） 橋接模式（Bridge） 組合模式（Composite） 裝飾者模式（Decorator） 外觀模式（Facade） 享元模式（Flyweight） 代理模式（Proxy） 📌 特點： 這些模式專門解決如何「拼裝」不同物件，讓你的程式更容易擴充、更有彈性。
想像成在玩樂高，一個一個小零件組裝起來，最後變成超酷的東西！
🚦 行為型模式（Behavioral） 責任鏈模式（Chain of Responsibility） 命令模式（Command） 解譯器模式（Interpreter） 迭代器模式（Iterator） 中介者模式（Mediator） 備忘錄模式（Memento） 觀察者模式（Observer） 狀態模式（State） 策略模式（Strategy） 模板方法模式（Template Method） 訪問者模式（Visitor） 📌 特點： 處理物件之間的「互動」。如果你常常覺得你的物件們關係很亂，溝通起來像在吵架，那這些模式就是你的救星！</description></item><item><title>Day 6: 【文件 #1】專案的靈魂：用 Gemini CLI 生成「專案章程」</title><link>/ChiYu-Blob/posts/2025ithomeironmanday6/</link><pubDate>Mon, 25 Aug 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday6/</guid><description>安安，我是 ChiYu！
經過了五天的「前置作業」，我們的駕駛艙 (VS Code)、引擎 (Python)、魔法法杖 (Gemini CLI) 全都準備就緒了。是不是已經手癢難耐，準備大展身手了？
別急！還記得我們的核心心法嗎？先有藍圖，再有魔法。
今天，我們就要正式啟動專案，打響「左手藍圖」的第一槍！我們將完全在 VS Code 終端機內，為我們的太空船，設定好最初也最重要的航行座標。我們要來產出整個專案中，位階最高、最重要的一份文件——專案章程 (Project Charter)。
Part 1：什麼是「專案章程」？它到底有多重要？ 「專案章程」…這名字聽起來好像很厲害、很嚴肅，但你別被它嚇到。
你可以把它想像成這個專案的「出生證明」或「身分證」。它用最精簡的方式，回答了幾個最根本的問題：我們是誰？我們要去哪裡？我們要做什麼？以及，我們「不做」什麼？
在團隊開發中，這份文件至關重要，因為它是：
建立共識的基石：專案最怕的就是「我以為我們是要做A，結果你做的是B」。專案章程是第一份讓所有人（老闆、PM、工程師）都點頭同意的文件，確保大家從第一天起，對專案的想像就是一致的。 正式啟動的號角：在企業裡，一份被簽核的專案章程，代表著這個專案被「正式授權」。對我們來說，完成這份文件，就像是為自己舉辦一個開工儀式，代表我們對這個專案的承諾，從此刻起，它不再只是個空想。 未來決策的北極星：開發過程中，我們肯定會冒出各種新點子。這時候，我們就可以拿出專案章程來檢視：「這個新點子，符合我們的『願景』和『範圍』嗎？」它能幫助我們抵抗「範圍潛變 (Scope Creep)」這個專案的無聲殺手，確保我們能聚焦在核心價值上。 總之，在一頭熱地栽進去開發前，先把這份文件定義清楚，就像開車前先在 Google Maps 設定好目的地。它就是我們後續所有文件的最高指導原則。
Part 2：實戰開始：在終端機中從無到有 接下來，就是見證奇蹟的時刻。我們將把腦中那個非常模糊的想法，透過與 Gemini CLI 的對話，直接在我們的專案中，生成一份專業文件。
魔法的基礎：什麼是提示工程 (Prompt Engineering)？ 在我們詠唱第一個咒語之前，我們先來學習「咒語的文法」。與 AI 溝通，是一門藝術，也是一門科學，這就是所謂的「提示工程 (Prompt Engineering)」。
你可以把它想像成你在對一個法力無邊的「許願精靈」下指令。
糟糕的許願：「我想要變有錢！」 -&amp;gt; 精靈可能會給你一張樂透彩券，或是讓你家地下冒出處理起來很麻煩的石油。 優秀的許願：「請在今天下午三點前，將一百萬新台幣，以合法的銀行轉帳方式，存入我指定的銀行帳戶。」 看到了嗎？一個好的 Prompt，就像一個好的許願，它清晰、具體、有邊界、有上下文。這能大幅降低 AI「理解錯誤」或「自由發揮」的機率。
根據業界的最佳實踐（例如 OpenAI 的官方文件），一個高品質的 Prompt 通常包含幾個關鍵要素，而這也正是我們接下來所有咒語的設計核心：
1. 角色扮演 (Role-playing)：為 AI 賦予專家身份 這是最重要，也最容易被忽略的一點。在指令的開頭，先告訴 AI 他「是誰」。這會讓模型進入一個特定的知識領域與思考模式，產出的內容會更專業、更貼近你的需求。
不好的指令: 幫我寫一個 Python 函式來驗證電子郵件。 好的指令: 你是一位資深的 Python 開發者，專長是後端開發與資料驗證。請幫我寫一個符合 RFC 5322 標準的 Python 函式來驗證電子郵件.</description></item><item><title>單例模式：只要一個就夠！</title><link>/ChiYu-Blob/posts/%E5%96%AE%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%8F%AA%E8%A6%81%E4%B8%80%E5%80%8B%E5%B0%B1%E5%A4%A0/</link><pubDate>Thu, 12 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E5%96%AE%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%8F%AA%E8%A6%81%E4%B8%80%E5%80%8B%E5%B0%B1%E5%A4%A0/</guid><description>在上一篇文章中，我們簡單認識了什麼是「設計模式」。這次，就讓我們從最經典的「單例模式（Singleton）」開始，看看它究竟能為開發帶來什麼幫助吧！
☕ 小故事：世界上只此一家 想像你開了一間只允許存在一個分店的咖啡廳，無論客人怎麼找，都只能到這家。單例模式的精神也差不多：確保整個應用程式裡只有同一個實例存在。
🤔 什麼情境適合用 Singleton？ 系統設定：確保設定檔只有一份，避免各模組各自讀取產生混亂。 日誌記錄：統一紀錄進入點，不會讓檔案四散。 資料庫連線：集中管理連線、節省資源。 接下來的範例將以「系統設定」為主角，用 C# 程式碼示範 Singleton 的實作。
💻 Singleton 類別 using System; /// &amp;lt;summary&amp;gt; /// 系統設定管理器，只允許產生一個實例 /// &amp;lt;/summary&amp;gt; public sealed class ConfigurationManager { // 保留唯一實例 private static ConfigurationManager _instance; // 執行緒鎖定物件，確保多執行緒環境下仍只會建立一次 private static readonly object _lock = new object(); /// &amp;lt;summary&amp;gt; /// 連線字串設定 /// &amp;lt;/summary&amp;gt; public string ConnectionString { get; private set; } // 建構子設為私有，阻止外部直接建立 private ConfigurationManager() { Console.WriteLine(&amp;#34;建立 ConfigurationManager 唯一實例&amp;#34;); // 模擬載入設定值 ConnectionString = &amp;#34;Server=myServer;Database=myDB;User Id=myUser;&amp;#34;; } /// &amp;lt;summary&amp;gt; /// 取得唯一實例的存取點 /// &amp;lt;/summary&amp;gt; public static ConfigurationManager Instance { get { if (_instance == null) { lock (_lock) { if (_instance == null) { _instance = new ConfigurationManager(); } } } return _instance; } } } 🚀 實際使用範例 using System; class Program { static void Main(string[] args) { // 第一次取得實例 ConfigurationManager config1 = ConfigurationManager.</description></item><item><title>Day 7: 【文件 #2】使用者的旅程：用 Gemini CLI 描繪「使用者故事」</title><link>/ChiYu-Blob/posts/2025ithomeironmanday7/</link><pubDate>Tue, 26 Aug 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday7/</guid><description>安安，我是 ChiYu！
昨天，我們確立了專案的「北極星」——專案章程，並在 GitHub 上留下了第一個不可磨滅的印記。如果說昨天的「專案章程」是我們的**「戰略地圖」，告訴我們為何而戰、要攻下哪座城池。那今天，我們就要化身為「戰場指揮官」，繪製出士兵（使用者）在戰場上的具體「戰術路線圖」**。
今天，我們將完全在終端機內，描繪這張地圖，產出兩份從「使用者視角」出發的關鍵文件：使用者故事 (User Stories) 與 使用者流程圖 (User Flowchart)。
Part 1：什麼是「使用者故事」？ 別被「故事」這兩個字嚇到，我們不是要寫小說。使用者故事其實是一種在敏捷開發中，用來描述需求的強大工具。
你可以把它想像成你在跟咖啡師點餐。你不會直接跟他說「給我咖啡因、水和牛奶的混合物」，你會說：
身為 一個想提神的顧客 (使用者)，
我想要 一杯大杯的熱拿鐵 (功能)，
以便 讓我有精神撐過下午的會議 (價值)。
看到這個格式的威力了嗎？它強迫我們停止用「工程師的語言」思考，而是用「使用者的語言」思考。一個好的使用者故事，包含了經典的「3C」要素：
Card (卡片)：故事本身簡短扼要，像一張可以貼在牆上的便利貼。 Conversation (對話)：它不是一份冰冷的規格書，而是一個「邀請」，邀請你和 AI 針對這個需求進行對話，釐清細節。 Confirmation (確認)：這是最關鍵的一步！每個故事都應該伴隨著**「驗收條件 (Acceptance Criteria)」**，也就是一個非黑即白、不容狡辯的簡單清單，用來確認「怎樣才算完成了這個故事」。 Part 2：什麼是「使用者流程圖」與 Mermaid.js？ 如果說使用者故事是描述一個個「單點需求」，那「使用者流程圖」就是把這些點串連起來的「路線圖」。它用視覺化的方式，呈現使用者為了完成一個特定目標所需要經過的完整路徑。
一張圖勝過千言萬語，但一張圖配上精闢的文字解說，才能確保所有人對這千言萬語的理解是完全一致的。
而 Mermaid.js 就是一個能讓我們用「文字」來畫流程圖的神奇工具。因為是純文字，所以我們可以輕鬆地用 Git 進行版本控制，這對開發者來說再方便不過了！
Mermaid的語法我暫時不花太多篇幅作介紹，感覺要介紹可以花一天的文章篇幅來完整介紹，在系列文章結束後我再來補充好了(挖坑給自己)！畢竟Mermaid.js 真的有他非常好用的地方，語法簡單直觀、便於版本控制、易於整合與維護而且還跨平台!!!
Part 3：實戰開始：在終端機中扮演我們的產品經理 好了，理論課結束，讓我們再次召喚 Gemini CLI，請它繼續扮演我們的產品經理。
Step 1：詠唱我們的魔法 (Craft the Prompt) 我們要讓 Gemini 直接讀取我們本地的「專案章程」，來確保我們的工作是基於最新、最正確的藍圖。
打開 VS Code 終端機，詠唱我們的第二個「文件生成咒語」：
【魔法詠唱：我們的 Prompt】 # 角色 (Role) 你是一位頂尖的產品經理 (PM)，擁有豐富的敏捷開發經驗，擅長將高階的專案目標，轉化為清晰、可執行的使用者故事與流程。你的產出兼具使用者同理心與技術可行性。 # 目標 (Objective) 我的目標是讓你將一份高階的「專案章程」分解為開發團隊可以立即投入工作的敏捷開發產物 (Agile Artifacts)，包含使用者故事和流程圖。 # 上下文 (Context) - **唯一的真相來源 (Single Source of Truth)**: 請將 @docs/PROJECT_CHARTER.</description></item><item><title>工廠方法模式：點披薩不用親自下廚</title><link>/ChiYu-Blob/posts/%E5%B7%A5%E5%BB%A0%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E9%BB%9E%E6%8A%AB%E8%96%A9%E4%B8%8D%E7%94%A8%E8%A6%AA%E8%87%AA%E4%B8%8B%E5%BB%9A/</link><pubDate>Thu, 12 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E5%B7%A5%E5%BB%A0%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E9%BB%9E%E6%8A%AB%E8%96%A9%E4%B8%8D%E7%94%A8%E8%A6%AA%E8%87%AA%E4%B8%8B%E5%BB%9A/</guid><description>哈囉大家，接續上一次 Singleton 模式，這一次我們要介紹的是另一個超實用的模式：工廠方法模式（Factory Method）。
別看到「工廠」兩個字就開始緊張，其實它超簡單！讓我們先來個輕鬆的比喻吧：
假設你今天去一家披薩店，店員跟你說：「告訴我你想吃什麼披薩，我們後面的廚師就會幫你做出來！」你不用在意披薩到底怎麼做，反正店家會處理好所有製作細節。這樣，你只要說出你想要的東西，剩下的交給專業的工廠就行。
這就是「工廠方法模式」的核心精神啦！
🤔 工廠方法模式什麼時候派得上用場？ 當你遇到以下狀況時，就可以考慮使用工廠方法模式：
你有多種類似的物件需要建立，但你不想每次都自己指定具體的類別。 你想要簡化物件的建立過程，並且統一管理物件的生成邏輯。 你想要未來可以輕鬆新增不同類型的物件，而不需要大幅修改現有的程式碼。 C# 工廠方法模式實作範例 這次我們就以「披薩店」作為具體的案例，示範如何使用工廠方法模式：
🍕 首先，定義產品介面 /// &amp;lt;summary&amp;gt; /// 披薩產品介面 /// &amp;lt;/summary&amp;gt; public interface IPizza { /// &amp;lt;summary&amp;gt; /// 準備食材 /// &amp;lt;/summary&amp;gt; void Prepare(); /// &amp;lt;summary&amp;gt; /// 烘烤披薩 /// &amp;lt;/summary&amp;gt; void Bake(); /// &amp;lt;summary&amp;gt; /// 切割披薩 /// &amp;lt;/summary&amp;gt; void Cut(); /// &amp;lt;summary&amp;gt; /// 裝盒披薩 /// &amp;lt;/summary&amp;gt; void Box(); } 🧑‍🍳 建立具體的產品類別 using System; /// &amp;lt;summary&amp;gt; /// 起司披薩 /// &amp;lt;/summary&amp;gt; public class CheesePizza : IPizza { public void Prepare() =&amp;gt; Console.</description></item><item><title>Day 8: 【文件 #3】系統的心臟：用 Gemini CLI 設計「軟體架構文件」</title><link>/ChiYu-Blob/posts/2025ithomeironmanday8/</link><pubDate>Wed, 27 Aug 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday8/</guid><description>安安，我是 ChiYu！
前兩天，我們完成了專案的「出生證明」(專案章程) 和「使用者地圖」(使用者故事)。我們現在非常清楚「為誰而做」以及「他們想做什麼」。
今天，我們要戴上「工程安全帽」，從使用者的世界暫時抽離，化身為擘劃未來的 「系統架構師」。我們要進行一次視角切換，從關注「人」，轉向關注「系統」，回答一個核心問題：「為了滿足這些使用者故事，我們的系統內部應該長什麼樣子？」
我們今天要畫的，不僅是建築的藍圖，更是未來系統穩定、高效、可擴展的基石。
Part 1：偉大的分工：什麼是「前後端分離」？ 在我們深入探討具體的架構之前，你必須先理解現代網頁開發中最核心的一個思想——前後端分離 (Frontend-Backend Separation)。
讓我們再次回到「經營一家餐廳」的比喻。一家餐廳，最基本的劃分就是「外場」與「內場」。
外場 (前端 Frontend)：這是顧客能直接接觸到的地方。包含了華麗的裝潢、舒適的座位、精美的菜單、以及親切的服務生。它的唯一職責，就是提供給顧客最棒的「用餐體驗」。在我們的專案中，這對應的就是使用者在瀏覽器上看到的所有畫面，由 HTML, CSS, JavaScript 這三劍客負責打造。 內場 (後端 Backend)：這是神秘的廚房，顧客看不見也摸不著。廚師們在這裡處理訂單、烹飪食物、管理食材庫存。它的唯一職責，就是處理所有核心的「商業邏輯」與「數據管理」。在我們的專案中，這對應的就是運行在遠端伺服器上的 Python + Flask 應用程式。 「前後端分離」就是一個嚴格的規定：外場的人不准進内場，內場的人也不准跑去外場。他們之間唯一的溝通管道，就是透過「服務生」來傳遞標準化格式的「點餐單」與「餐點」。
Part 2：溝通的契約：什麼是 API？ 這個至關重要的「服務生」，就是我們常說的 API (Application Programming Interface)。
API 的本質，就是一份前端與後端之間，神聖不可侵犯的「溝通契約」。這份契約詳細地定義了：
前端可以要求後端做哪些事（例如：查詢所有習慣、新增一筆紀錄）。 前端在提出要求時，必須提供哪些資訊（例如：新增習慣時要給習慣名稱）。 後端在完成任務後，承諾會回傳什麼格式的資料給前端。 有了這份契約，前端的「室內設計師」和後端的「大廚」就可以完全獨立、並行地工作，只要最後雙方都遵守契約，就能完美地將各自的成果組合起來。這份詳細的契約（Web API 規格書），將會是我們在 Day 10 的主題。
Part 3：設計我們的廚房：Flask 後端 API 伺服器架構 好了，理解了前後端的分工與 API 的角色後，現在我們可以聚焦在「如何設計我們的廚房 (後端)」了。
隨著我們的餐廳生意越來越好，菜色越來越多（功能越來越複雜）時，如果還把所有廚師都擠在一個廚房裡 (app.py)，肯定會天下大亂。
因此，我們需要升級成「中央廚房」模式。我們會把廚房細分成「冷盤區」、「熱炒區」、「甜點區」，每個區域有專門的師傅負責。這在我們的後端專案中，就是所謂的**「模組化 (Modularity)」**。
在 Flask 框架中，實現模組化的最佳實踐，就是使用**「藍圖 (Blueprints)」**。你可以把一個 Blueprint 想像成一個獨立的「功能模組包」。例如，我們可以規劃一個 habits.py 檔案，裡面專門放所有跟「習慣」相關的 API 路由。</description></item><item><title>抽象工廠模式：系列產品輕鬆生產</title><link>/ChiYu-Blob/posts/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%BB%A0%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E7%94%A2%E5%93%81%E8%BC%95%E9%AC%86%E7%94%9F%E7%94%A2/</link><pubDate>Thu, 12 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%BB%A0%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E7%94%A2%E5%93%81%E8%BC%95%E9%AC%86%E7%94%9F%E7%94%A2/</guid><description>嗨各位朋友～前面我們介紹過了 Singleton 和 Factory Method，今天要繼續往下走，聊一個稍微進階一點點的設計模式：「抽象工廠模式（Abstract Factory）」。
🌟 什麼是抽象工廠模式？ 簡單來說，抽象工廠模式就是提供一個介面，讓你可以建立一整系列相關的產品，而不需要關心產品具體的實作方式。
舉個例子，今天你到 IKEA 買家具，通常會想要一次買齊同一系列的產品，比如椅子、桌子、書架等等。如果這些家具都是同系列，外觀看起來會很搭調，品質和風格也會一致。這樣的一個系列產品，就是抽象工廠想幫你解決的問題！
🧐 抽象工廠模式適合什麼場景？ 以下情境適合用抽象工廠模式解決：
你的產品需要有不同的系列或主題，每個系列內又有多個相關產品。 想要保證同系列產品之間能夠完美兼容。 未來可能需要新增更多產品系列，而希望盡可能避免修改現有程式碼。 🛋️ C# 抽象工廠模式範例 這次，我們就用「家具工廠」作為範例來示範抽象工廠模式的實作吧！
1️⃣ 定義產品介面 /// &amp;lt;summary&amp;gt; /// 椅子介面 /// &amp;lt;/summary&amp;gt; public interface IChair { /// &amp;lt;summary&amp;gt; /// 坐在椅子上 /// &amp;lt;/summary&amp;gt; void SitOn(); } /// &amp;lt;summary&amp;gt; /// 桌子介面 /// &amp;lt;/summary&amp;gt; public interface ITable { /// &amp;lt;summary&amp;gt; /// 使用桌子 /// &amp;lt;/summary&amp;gt; void Use(); } 🛋️ 建立具體產品（現代系列和古典系列） using System; /// &amp;lt;summary&amp;gt; /// 現代風格椅子 /// &amp;lt;/summary&amp;gt; public class ModernChair : IChair { public void SitOn() =&amp;gt; Console.</description></item><item><title>Day 9: 【文件 #4】數據的家：用 Gemini 規劃「資料庫綱要」</title><link>/ChiYu-Blob/posts/2025ithomeironmanday9/</link><pubDate>Thu, 28 Aug 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday9/</guid><description>安安，我是 ChiYu！
昨天，我們化身為架構師，完成了專案的**「系統藍圖」**(軟體架構文件)，釐切了前台、後台、API 與資料庫之間的分工合作關係。
我們的餐廳藍圖畫好了，下一步，就是要來仔細規劃我們儲放所有食材的「食材庫」。在軟體世界裡，這個角色就是由**「資料庫 (Database)」來扮演。今天，我們將化身為「數據的守護者」——資料庫管理員 (DBA)，與 Gemini 一同規劃我們專案的「資料庫綱要 (Database Schema)」**！
Part 1：什麼是「資料庫 (Database)」？ 對於新手來說，你可以把資料庫想像成一個擁有超能力的、極度嚴謹的 Excel 表格。它是一個專門用來「結構化儲存」資訊的系統，有非常明確的規則，來確保我們存進去的資料是乾淨、有組織、且易於查詢的。
要理解資料庫，你只需要知道幾個核心概念：
資料表 (Table)：就像 Excel 裡的一個工作表 (Sheet)。 欄位 (Column/Field)：就像工作表裡的第一行標題。 紀錄 (Row/Record)：工作表裡的一行資料。 綱要 (Schema)：這就是整個資料庫的「設計藍圖」。它不僅定義了有哪些資料表、每張表有哪些欄位，更重要的是，它定義了規則： 資料型態 (Data Types)：規定了每個欄位只能存放哪種類型的資料（數字、文字、日期等）。 約束 (Constraints)：規定了資料必須遵守的規則，例如 email 欄位的內容必須是獨一無二的 (UNIQUE)。 關聯 (Relationships)：定義了表與表之間的連結關係。 我們今天就是要設計這份包含所有規則的「綱要 (Schema)」。
Part 2：資料庫的兩大門派：SQL vs. NoSQL 在選擇具體的資料庫之前，你需要知道，當今的資料庫世界主要有兩大門派：SQL (關聯式資料庫) 和 NoSQL (非關聯式資料庫)。
SQL 像 Excel 表格，結構嚴謹，資料之間關係明確，可靠性強。 NoSQL 像一個自由的資料夾，結構靈活彈性，擴展性極強。 對於我們的「習慣養成日誌」專案來說，要儲存的資料關係非常明確：一個「使用者」可以擁有多個「習慣」，一個「習慣」可以擁有多筆「打卡紀錄」。這種層次分明、井然有序的關係，正是 SQL 資料庫最擅長處理的。因此，選擇 SQL 陣營是我們最穩健的選擇。
Part 3：選擇我們的資料庫：為什麼是 SQLite？ 在 SQL 這個門派裡，有許多知名的武林高手。但對於新手和中小型專案，我們選擇一個更輕巧、更友善的方案：SQLite。
選擇 SQLite 的理由非常充分：零設定、單一檔案、Python 內建支援。它能讓你專注在「資料庫設計」本身，而不用分心去處理複雜的環境設定，是學習資料庫觀念的最佳起點。</description></item><item><title>原型模式：複製的藝術</title><link>/ChiYu-Blob/posts/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E8%A4%87%E8%A3%BD%E7%9A%84%E8%97%9D%E8%A1%93/</link><pubDate>Thu, 12 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E8%A4%87%E8%A3%BD%E7%9A%84%E8%97%9D%E8%A1%93/</guid><description>嗨！繼續設計模式系列，這次要介紹的主角是原型模式（Prototype）。聽到「原型」這個詞是不是有點不太確定這到底是什麼？別擔心，我們還是用輕鬆易懂的方式來理解它吧！
🌟 原型模式到底在做什麼？ 原型模式簡單來說就是透過「複製」現有的物件，來建立一個新物件。就像我們常用的「複製貼上」一樣。
比如你去文具店要印名片，你只需要給店員一張原稿，他就能根據這份原稿複製出許多張一模一樣的名片，而不用一張一張重新設計。
🤔 什麼時候該用原型模式？ 物件的建立成本較高（例如需要從資料庫讀取大量資料）。 你要建立的物件跟現有物件差異不大，只需要稍微修改一下就可以使用。 希望降低物件建立時的複雜度與耗時。 📑 C# 原型模式範例 這次我們就以「履歷表複製」作為實際案例，來看看怎麼使用原型模式吧！
📄 定義原型介面 /// &amp;lt;summary&amp;gt; /// 原型介面，提供複製方法 /// &amp;lt;/summary&amp;gt; public interface IResume { /// &amp;lt;summary&amp;gt; /// 複製自身 /// &amp;lt;/summary&amp;gt; IResume Clone(); /// &amp;lt;summary&amp;gt; /// 顯示履歷內容 /// &amp;lt;/summary&amp;gt; void Display(); } 📄 實作具體原型類別 using System; /// &amp;lt;summary&amp;gt; /// 履歷表 /// &amp;lt;/summary&amp;gt; public class Resume : IResume { /// &amp;lt;summary&amp;gt; /// 姓名 /// &amp;lt;/summary&amp;gt; public string Name { get; set; } /// &amp;lt;summary&amp;gt; /// 工作經驗 /// &amp;lt;/summary&amp;gt; public string Experience { get; set; } public Resume(string name, string experience) { Name = name; Experience = experience; } /// &amp;lt;summary&amp;gt; /// 複製自身 /// &amp;lt;/summary&amp;gt; public IResume Clone() { // 直接淺層複製即可 return (IResume)this.</description></item><item><title>Day 10: 【文件 #5】溝通的契約：用 Gemini 撰寫「Web API 規格書」</title><link>/ChiYu-Blob/posts/2025ithomeironmanday10/</link><pubDate>Fri, 29 Aug 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday10/</guid><description>安安，我是 ChiYu！
昨天，我們完成了餐廳的「食材倉庫」設計圖——資料庫綱要。至此，我們專案的願景、使用者需求、系統架構、數據儲存方式，都已經有了明確的定義。
我們的餐廳藍圖（架構）和食材倉庫（資料庫）都設計好了。下一步，就是要交給「服務生 (API)」一份精準的「菜單」，讓他知道如何跟廚房溝通，顧客可以點哪些菜，以及餐點會以什麼形式送上。
這份「菜單」，就是我們今天要產出的，後端藍圖的最後一塊拼圖——Web API 規格書。
Part 1：什麼是「API 規格書」？ 我們在 Day 7 提過，API 是前端（前台）與後端（廚房）之間的溝通橋樑。而「API 規格書」就是一份極其嚴謹、毫無模糊空間的技術文件，如同法律契約一般，精準地定義了前端與後端之間每一次互動的細節。
什麼是 OpenAPI 3.0 (Swagger)？ 為了避免每家公司都用自己的格式來寫規格書，業界發展出了一套公認的標準，其中最流行的就是 OpenAPI 3.0（前身就是大名鼎鼎的 Swagger）。它用 YAML 或 JSON 格式，提供了一套完整的語法規則來描述 API。YAML 格式因其對人類更友善、更易讀的特性而廣受歡迎。
使用 OpenAPI 的最大好處是，有非常多工具可以讀取這份文件，自動生成可以互動的 API 文件網站、不同語言的客戶端程式碼、甚至是伺服器端的程式碼骨架！這也體現了一種專業的「設計優先 (Design-First)」開發哲學——我們先把契約定義好，再動手寫程式，這與我們系列「藍圖優先」的核心思想不謀而合。
Part 2：實戰開始：讓 Gemini 成為我們的 API 設計專家 好了，讓我們來設計這份最重要的契約吧！
Step 1：詠唱我們的魔法 (Craft the Prompt) API 的設計，需要通盤考慮專案的目標、使用者故事、系統架構、以及資料庫綱要。所以這次，我們要拿出至今為止的所有成果，全部餵給 Gemini！
打開 VS Code 終端機，詠唱我們至今為止最複雜的一個「文件生成咒語」：
【魔法詠唱：我們的 Prompt】 # --------------------------------------------------------------------------- # PROMPT FOR GEMINI: Production-Ready OpenAPI 3.0.3 Specification Generator # --------------------------------------------------------------------------- # 角色 (Role) 你是一位頂尖的後端工程師與 API 設計專家，精通 RESTful API 設計原則與 OpenAPI 3.</description></item><item><title>建造者模式：一步步完成複雜任務</title><link>/ChiYu-Blob/posts/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%80%E6%AD%A5%E6%AD%A5%E5%AE%8C%E6%88%90%E8%A4%87%E9%9B%9C%E4%BB%BB%E5%8B%99/</link><pubDate>Thu, 12 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%80%E6%AD%A5%E6%AD%A5%E5%AE%8C%E6%88%90%E8%A4%87%E9%9B%9C%E4%BB%BB%E5%8B%99/</guid><description>哈囉各位朋友們～今天我們繼續設計模式之旅，來聊聊 建造者模式（Builder） 吧！
🌟 建造者模式是什麼？ 簡單地說，建造者模式就是將一個複雜產品的建構過程拆分成幾個獨立的步驟，然後逐步組裝起來。
你可以想像去 Subway 點三明治：店員會一步一步詢問你想加什麼食材，麵包種類、起司、蔬菜、醬料……最後做出你最愛的那個獨特三明治。這個點餐流程就有點像建造者模式的概念。
透過建造者模式，你可以有系統地建立出不同組合的複雜產品，並且輕鬆管理每一個步驟。
🤔 什麼時候要用建造者模式？ 產品建立過程複雜，有許多可變步驟或選項。 想要明確區分物件的構建步驟與產出的物件。 未來可能會新增更多的建構方式，但不想更動產品本身。 🥪 C# 建造者模式範例 我們就用「三明治店」當作實際範例，讓你馬上理解這個模式吧！
🥖 首先定義產品類別 using System; using System.Collections.Generic; /// &amp;lt;summary&amp;gt; /// 三明治產品 /// &amp;lt;/summary&amp;gt; public class Sandwich { /// &amp;lt;summary&amp;gt; /// 麵包種類 /// &amp;lt;/summary&amp;gt; public string Bread { get; set; } /// &amp;lt;summary&amp;gt; /// 起司種類 /// &amp;lt;/summary&amp;gt; public string Cheese { get; set; } /// &amp;lt;summary&amp;gt; /// 蔬菜配料 /// &amp;lt;/summary&amp;gt; public List&amp;lt;string&amp;gt; Veggies { get; set; } = new List&amp;lt;string&amp;gt;(); /// &amp;lt;summary&amp;gt; /// 醬料 /// &amp;lt;/summary&amp;gt; public string Sauce { get; set; } /// &amp;lt;summary&amp;gt; /// 顯示三明治內容 /// &amp;lt;/summary&amp;gt; public void Display() { Console.</description></item><item><title>Day 11: 【心法 #2】透過AI幫我們生成Prompt</title><link>/ChiYu-Blob/posts/2025ithomeironmanday11/</link><pubDate>Sat, 30 Aug 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday11/</guid><description>安安，我是 ChiYu！
昨天，我們終於完成了上半部分的最後一份文件！可以正式進入開發的環節！但在進入開發環節前，我想要回頭再詳細聊一下 Ai Prompt Engineering。
我相信大家在經歷了前面五天、一連串燒腦的文件生成後，肯定會有點累，心中可能還會冒出一個疑問：
「ChiYu 你每次給的 Prompt 都又臭又長，結構還那麼複雜，每次都要自己想，也太累了吧？」
你說的沒錯！所以今天，我們要稍微轉換一下節奏，暫時不推進度。我們要來一場「魔法師的幕後揭秘」，聊聊我是如何生成那些看似複雜、但效果奇佳的完整 Prompt 的！
Part 1：為什麼現在才說？先學會走路，再學會開跑車 在揭曉我的秘密武器之前，我想先解釋一下，為什麼我刻意把這個技巧，留到今天才告訴大家。
過去五天，我讓大家親手去「感受」一個 Prompt 的好壞。你們親自體驗了從一個模糊的想法，到一個結構化的指令；從 AI 給出不甚滿意的答案，到透過迭代優化，最終得到專業產出的完整過程。
這個 「手動」的過程至關重要。因為它能讓你建立起對**「好 Prompt」的品味與鑑賞力**。
如果我第一天就教你開跑車，你可能會因為速度太快而看不清沿途的風景，甚至直接翻車。只有當你親自走過一遍崎嶇的山路，你才會知道跑車的懸吊有多重要、輪胎該怎麼選。
現在，你已經是一位合格的**「Prompt 手工藝人」了。是時候，為你配備一台「Prompt 工業母機」**了！
Part 2：我們的「靈感實驗室」：Gemini Web UI 你可能又會問：「咦？我們不是說好要完全在終端機裡 Vibe Coding 嗎？怎麼又回到瀏覽器了？」
問得好！一個專業的開發者，懂得為不同的任務，選擇最適合的工具。
Gemini CLI：是我們的**「生產線」**。它追求的是效率、精準、可重複。當我們心中已經有了明確的目標時（例如：根據 @API_SPEC.yml 生成程式碼），CLI 是我們的最佳選擇。 Gemini Web UI：是我們的**「靈感實驗室」或「創意沙盒」**。它擁有更自由、更具創意的互動介面，可以同時看到多個版本的草稿、方便地進行長篇大論的對話。它最適合的場景，就是進行探索性、創造性、迭代性的任務——例如，打磨我們即將在 CLI 中使用的「終極咒語」！ Part 3：AI 幫我寫咒語：Prompt Engineering 的「後設」技巧 「Prompt Engineering」，直白點說，就是「如何跟 AI 好好說話的藝術」。我們在 Day 5 已經介紹過它的基本原則。但今天，我們要玩一個更進階的**「後設 (Meta)」**技巧——讓 AI 自己，成為一位提示工程專家。
這就像是，我們不只問許願精靈『我想要什麼』，而是拉著精靈坐下來，一起討論：『嘿，精靈！以你對魔法的理解，如果我想要一座完美的黃金城堡，我應該用什麼樣的「許願詞」、提供哪些細節（例如：尺寸、風格、純度），才能讓你最有效率、最不會理解錯誤地幫我變出來？』我們正在讓 AI 成為我們的『許願顧問』。
首先打開你的靈感實驗室，前往 gemini.google.com。
這邊我提供我在使用的萬用咒語：
【我的萬用 Prompt 模板】 # 角色 (Role) 你是一位頂尖的 AI Prompt Engineering 專家與思維框架建構師。你的核心專長是，將使用者提出的初步、模糊的想法，轉化為一個結構完整、指令清晰、包含所有最佳實踐的高品質「進階 Prompt」。 # 目標 (Objective) 我的任務是，請你根據我下方提供的「初步構想」，為我生成一個可以直接複製使用、用於驅動其他 AI 完成具體任務的「進階 Prompt」。 --- ## 使用者提供的初步構想 (User&amp;#39;s Initial Idea) * **[核心任務]**: `[請在這裡用一句話描述你最想讓 AI 做什麼。例如：幫我規劃一趟為期七天的日本東京家庭旅遊行程。]` * **[目標產出]**: `[請描述你希望最終得到的產出物是什麼。例如：一份 Markdown 格式的每日行程表。]` * **[目標受眾]**: `[請描述這個產出物是給誰看的，或在什麼情境下使用。例如：給我的家人看，成員包含兩位長輩和一位小孩。]` * **[關鍵細節與限制]**: `[請列出任何你認為重要的額外資訊、風格要求或限制。例如：行程要輕鬆，不要太趕；需要考慮長輩的體力；預算中等；希望包含至少一個親子景點。]` --- ## 你的任務與產出要求 (Your Task &amp;amp; Output Requirements) 1.</description></item><item><title>介面卡模式：讓不相容也能合作</title><link>/ChiYu-Blob/posts/%E4%BB%8B%E9%9D%A2%E5%8D%A1%E6%A8%A1%E5%BC%8F%E8%AE%93%E4%B8%8D%E7%9B%B8%E5%AE%B9%E4%B9%9F%E8%83%BD%E5%90%88%E4%BD%9C/</link><pubDate>Thu, 12 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E4%BB%8B%E9%9D%A2%E5%8D%A1%E6%A8%A1%E5%BC%8F%E8%AE%93%E4%B8%8D%E7%9B%B8%E5%AE%B9%E4%B9%9F%E8%83%BD%E5%90%88%E4%BD%9C/</guid><description>哈囉大家！今天我們要介紹的設計模式是：介面卡模式（Adapter），又叫做轉接器模式。
🌟 介面卡模式（Adapter）到底在做什麼？ 就像生活中的轉接頭，它能讓本來不相容的介面順利溝通。在軟體開發裡，Adapter 模式同樣扮演橋樑角色，讓舊有系統與新系統或外部套件能順利合作。
🤔 什麼時候適合用 Adapter？ 既有系統或類別的介面與你需要的不相容。 想使用外部套件，但介面不同，無法直接套用。 希望在不修改既有程式碼的前提下解決介面不合的問題。 🔌 C# Adapter 模式範例 我們以「充電器轉接頭」的例子來說明介面卡模式。
🔋 既有不相容的類別 using System; /// &amp;lt;summary&amp;gt; /// 現有的歐洲插座 /// &amp;lt;/summary&amp;gt; public class EuropeanSocket { public void SpecificRequest() =&amp;gt; Console.WriteLine(&amp;#34;使用歐洲規格的插座&amp;#34;); } 🔋 定義目標介面 /// &amp;lt;summary&amp;gt; /// 台灣插頭介面 /// &amp;lt;/summary&amp;gt; public interface ITaiwanPlug { /// &amp;lt;summary&amp;gt; /// 連接插座 /// &amp;lt;/summary&amp;gt; void Request(); } 🔌 建立介面卡 /// &amp;lt;summary&amp;gt; /// 介面卡：讓歐洲插座能用於台灣插頭 /// &amp;lt;/summary&amp;gt; public class PlugAdapter : ITaiwanPlug { private EuropeanSocket _europeanSocket; public PlugAdapter(EuropeanSocket socket) { _europeanSocket = socket; } public void Request() { // 透過轉接頭呼叫原本的歐洲規格插座 _europeanSocket.</description></item><item><title>Day 12: 【後端 #1】起手式：AI 代理人 生成模組化的 Flask 專案</title><link>/ChiYu-Blob/posts/2025ithomeironmanday12/</link><pubDate>Sun, 31 Aug 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday12/</guid><description>安安，我是 ChiYu！歡迎來到歷史性的一刻！
過去一週，我們是專案的「規劃師」，用文字和圖表描繪著未來。從今天起，我們是「建築師」與「魔法師」，要將那些平面的藍圖，用程式碼，一行一行地「召喚」到這個世界上！
今天，我們不打算一個檔案一個檔案地慢慢來。我們要直接挑戰專業的作法！我們將命令 AI 代理人，根據我們 Day 8 設計的「模組化專案結構」，一步到位地為我們生成整個後端專案的基礎架構，包含所有資料庫模型的定義！
Part 1：為什麼要一開始就這麼「搞剛」？ 你可能會問，為什麼不先從一個簡單的檔案開始，之後再慢慢改？
因為專業的習慣，從第一天就要養成。
我們在 Day 7 設計的**「應用程式工廠 (Application Factory)」**模式，雖然看起來檔案比較多，但它為我們專案的未來，鋪設了一條康莊大道。這種結構能幫助我們將專案的不同部分（如設定、資料庫模型、API 路由）清晰地分開，讓專案更有條理、更容易測試與擴展。
從一開始就採用這種專業結構，就像是蓋房子時，直接把客廳、臥室、廚房的隔間都規劃好，而不是先蓋一個大通鋪，之後再來敲牆壁。
Part 2：Vibe Coding 實戰：命令 AI 代理人建立專案 好了，讓我們來指揮 Gemini，讓它為我們建立這座「中央廚房」。這次，我們不只要求它生成文字，我們要命令它直接行動！
Step 1：進入互動模式並下達總指令 我們要使用 gemini chat 互動模式，因為這最能模擬我們與一位「代理人」進行對話的感覺。
在 VS Code 終端機中，輸入 gemini chat 並按下 Enter。 看到 &amp;gt;&amp;gt;&amp;gt; 提示符後，詠唱我們的「專案創世」咒語： 【魔法詠唱：我們的 Prompt】 # --------------------------------------------------------------------------- # PROMPT FOR GEMINI: Production-Ready Flask Project Scaffolding Agent # --------------------------------------------------------------------------- # 角色 (Role) 你是一位精通 Python Flask 專案架構與 Shell 指令的 AI Code Scaffolding Agent。你的核心任務是根據設計文件，自動化地生成一個結構清晰、可立即執行的模組化 Flask 專案骨架。 # 目標 (Objective) 我的目標是讓你根據「軟體架構」與「資料庫綱要」文件，為我生成一個遵循業界最佳實踐的 Flask 專案。這個專案在生成後，應能立即安裝依賴並成功運行。 # 上下文 (Context) - **核心依據**: 你的所有操作都必須基於以下兩份文件的定義： 1.</description></item><item><title>橋接模式：抽象與實作分離</title><link>/ChiYu-Blob/posts/%E6%A9%8B%E6%8E%A5%E6%A8%A1%E5%BC%8F%E6%8A%BD%E8%B1%A1%E8%88%87%E5%AF%A6%E4%BD%9C%E5%88%86%E9%9B%A2/</link><pubDate>Thu, 12 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E6%A9%8B%E6%8E%A5%E6%A8%A1%E5%BC%8F%E6%8A%BD%E8%B1%A1%E8%88%87%E5%AF%A6%E4%BD%9C%E5%88%86%E9%9B%A2/</guid><description>哈囉大家～我們繼續來探索設計模式的世界吧！今天要介紹的是一個聽起來可能有點陌生，但其實很實用的設計模式：橋接模式（Bridge）。
🌟 橋接模式是什麼？ 橋接模式將抽象部分和實作部分分離，讓它們可以獨立變化。想像遙控器與電視：不希望為每種遙控器和電視的組合都寫一次程式碼，這時就能運用橋接模式。
🤔 什麼時候適合用橋接模式？ 避免抽象和實作之間產生過多耦合。 有多個維度需要獨立擴充。 想降低程式複雜度，避免類別過多。 📺 C# 橋接模式範例 以「遙控器控制電視」為例說明。
📡 建立實作介面（電視） /// &amp;lt;summary&amp;gt; /// 電視實作介面 /// &amp;lt;/summary&amp;gt; public interface ITV { void On(); void Off(); void SetChannel(int channel); } 📺 建立具體實作 using System; /// &amp;lt;summary&amp;gt; /// Sony 電視 /// &amp;lt;/summary&amp;gt; public class SonyTV : ITV { public void On() =&amp;gt; Console.WriteLine(&amp;#34;Sony 電視開機&amp;#34;); public void Off() =&amp;gt; Console.WriteLine(&amp;#34;Sony 電視關機&amp;#34;); public void SetChannel(int channel) =&amp;gt; Console.WriteLine($&amp;#34;Sony 電視設定頻道：{channel}&amp;#34;); } /// &amp;lt;summary&amp;gt; /// Samsung 電視 /// &amp;lt;/summary&amp;gt; public class SamsungTV : ITV { public void On() =&amp;gt; Console.</description></item><item><title>Day 13: 【後端 #2】AI 建築師：依藍圖自動建構 CRUD API</title><link>/ChiYu-Blob/posts/2025ithomeironmanday13/</link><pubDate>Mon, 01 Sep 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday13/</guid><description>安安，我是 ChiYu！歡迎來到 Vibe Coding 協奏曲的第一個最大的開發項目！
昨天，我們用一個指令召喚出了整個專案骨架。今天，我們要進行一次令人振奮的專案升級。我們將扮演一位「專案總建築師」，把詳細的「設計藍圖 (API_SPEC.yml)」交給我們的 AI 首席工程師，命令它根據藍圖，將完整的「習慣 (Habits)」資源模組，精準地建構到我們現有的專案結構中！
而在工程完工後，我們還需要一套最先進的「驗收工具」，來驗證成果是否符合藍圖規範。而這套工具的安裝與設定，我們同樣要交給 AI 來完成！
Part 1：Vibe Coding 實戰：下達「程式碼建構」指令 專案藍圖已備妥，讓我們打開終端機，指揮我們的 AI 首席工程師開始施工。
【實戰魔法詠唱：我們的 Prompt】 # 角色 (Role) 你是一位資深的 Python 後端工程師，專精於 Flask 框架與 API 開發。 你擁有豐富的經驗，能夠根據 OpenAPI 規格書，快速、精準地建構出穩定、 安全且符合業務邏輯的後端程式碼。你擅長使用 SQLAlchemy 進行資料庫操作， 並習慣撰寫清晰、可維護的程式碼。 # 目標 (Objective) 你的任務是，根據提供的 `API_SPEC.yml` 規格書與相關設計文件， 在一個已存在的 Python Flask 專案結構中，實作所有 API 端點的後端業務邏輯。 你將直接修改指定的 Python 檔案， 填入完整、可執行、生產級別 (Production-Ready) 的程式碼。 # 上下文與關鍵資訊 (Context &amp;amp; Key Information) * **OpenAPI 規格書 (OpenAPI Specification)**: 檔案位於 `[請提供 API_SPEC.</description></item><item><title>組合模式：樹狀結構的好幫手</title><link>/ChiYu-Blob/posts/%E7%B5%84%E5%90%88%E6%A8%A1%E5%BC%8F%E6%A8%B9%E7%8B%80%E7%B5%90%E6%A7%8B%E7%9A%84%E5%A5%BD%E5%B9%AB%E6%89%8B/</link><pubDate>Thu, 12 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E7%B5%84%E5%90%88%E6%A8%A1%E5%BC%8F%E6%A8%B9%E7%8B%80%E7%B5%90%E6%A7%8B%E7%9A%84%E5%A5%BD%E5%B9%AB%E6%89%8B/</guid><description>哈囉大家，歡迎繼續探索設計模式之旅！今天要介紹的是一個既實用又好理解的設計模式：組合模式（Composite）。
🌟 組合模式是什麼？ 組合模式讓你能將物件組織成樹狀結構，表示「整體—部分」的層次關係。像資料夾裡有資料夾、檔案又放在資料夾中，這正是組合模式的典型應用。
🤔 什麼時候適合用組合模式？ 需要表示物件的「整體—部分」階層。 想要用一致的方式處理個別物件和物件群組。 希望簡化客戶端程式碼，不必區分個體與集合的處理邏輯。 📁 C# 組合模式範例 用「檔案系統」來示範組合模式。
📄 建立抽象組件介面 /// &amp;lt;summary&amp;gt; /// 抽象檔案系統元件 /// &amp;lt;/summary&amp;gt; public interface IFileSystemComponent { /// &amp;lt;summary&amp;gt; /// 以縮排方式顯示結構 /// &amp;lt;/summary&amp;gt; void Display(int depth); } 📁 建立樹枝構件（資料夾） using System; using System.Collections.Generic; /// &amp;lt;summary&amp;gt; /// 資料夾 /// &amp;lt;/summary&amp;gt; public class Folder : IFileSystemComponent { private string _name; private List&amp;lt;IFileSystemComponent&amp;gt; _components = new List&amp;lt;IFileSystemComponent&amp;gt;(); public Folder(string name) { _name = name; } /// &amp;lt;summary&amp;gt; /// 新增子元件 /// &amp;lt;/summary&amp;gt; public void Add(IFileSystemComponent component) { _components.</description></item><item><title>Day 14: 【DevOps #1】AI 品管員：設定 GitHub Actions 自動化程式碼檢查</title><link>/ChiYu-Blob/posts/2025ithomeironmanday14/</link><pubDate>Tue, 02 Sep 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday14/</guid><description>安安，我是 ChiYu！
我們前幾天火力全開，後端 API 核心功能都搞定了。我們的後端架構現在什麼功能都做得出來！但問題來了，我們怎麼保證每個工程師（當然也包括幾週後的你自己！）在添加新功能時，都遵守一樣的編碼標準跟架構美學？
光靠口頭約定絕對不夠，我們需要一套自動的、鐵面無私的「 品質稽查系統 」。只要有新的程式碼被提交 (commit)，系統就自動進行檢查，確保一切都符合最高標準！
今天，我們就要來幫專案請一位 24 小時不休息的稽查員—— GitHub Actions ，順便設定好我們的第一條自動化品管流程 (CI)！
Part 1：什麼是 CI？為什麼要從「程式碼風格」開始？ CI (Continuous Integration)，持續整合，是現代軟體開發的基本功！它的精神就是「沒事多 commit，多 commit 沒事」。每次完成一小塊功能，就提交上來讓系統檢查，這樣才不會到最後要合併時，大家的程式碼風格迥異、互相衝突，那簡集是開發地獄！
我們要派給這位品管員的第一個任務，非常基礎，就是 「檢查程式碼乾不乾淨 (Linting)」！這就好像檢查建築的管線有沒有外露、牆面是否平整一樣。我們要讓所有的 Code 都遵循 Python 的官方風格指南 (PEP 8)，看起來整整齊齊、清爽漂亮！
Part 2：Vibe Coding 實戰：聘請 AI 撰寫「自動化工作手冊」 準備好了嗎？又到了我們使喚 Gemini 的快樂時光！把它當成我們的 DevOps 專家，來幫我們撰寫那份詳細的工作手冊 (.yml 檔) 吧！
Step 1: 命令 AI 準備「稽查工具清單」 第一步，我們要先列一張「工具清單 (requirements.txt)」，告訴我們的稽查員執行任務時需要哪些工具。這點小事，當然也是丟給 AI 去做！
打開終端機，切換到 gemini chat 模式，下達我們的第一道指令：
【魔法詠唱：生成依賴文件】 # 角色 (Role) 你是一位經驗豐富的 Python 開發者，非常熟悉使用 `requirements.txt` 來管理專案的相依性套件，並了解區分「生產環境依賴」與「開發環境依賴」的最佳實踐。 # 目標 (Objective) 請為一個 Python 專案生成 `requirements.</description></item><item><title>裝飾者模式：讓功能自由加點</title><link>/ChiYu-Blob/posts/%E8%A3%9D%E9%A3%BE%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AE%93%E5%8A%9F%E8%83%BD%E8%87%AA%E7%94%B1%E5%8A%A0%E9%BB%9E/</link><pubDate>Thu, 12 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E8%A3%9D%E9%A3%BE%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AE%93%E5%8A%9F%E8%83%BD%E8%87%AA%E7%94%B1%E5%8A%A0%E9%BB%9E/</guid><description>哈囉朋友們～今天要介紹的設計模式可是非常實用又有趣的喔，那就是 裝飾者模式（Decorator）！
🌟 什麼是裝飾者模式？ 裝飾者模式讓你在不修改現有物件程式碼的情況下，動態地增加新的功能。簡單來說，就是「包一層再包一層」的概念。
想像一下買一杯飲料，你可以加珍珠、椰果、鮮奶油等等，每個配料就像一個裝飾，你可以自由組合，做出你專屬的飲料，這就是裝飾者模式的概念！
🤔 什麼情況適合用裝飾者模式？ 當你遇到以下情境時，很適合使用裝飾者模式：
需要動態地為物件增加或移除功能。 不想直接修改原本類別的程式碼，避免影響原本物件的穩定性。 想要彈性地組合不同的功能，並且可以隨時調整功能。 🎂 C# 裝飾者模式範例 我們用最容易理解的「咖啡加料」案例，來看看怎麼實作裝飾者模式吧！
☕ 定義抽象元件（Component） using System; /// &amp;lt;summary&amp;gt; /// 咖啡抽象元件 /// &amp;lt;/summary&amp;gt; public abstract class Coffee { /// &amp;lt;summary&amp;gt; /// 取得描述 /// &amp;lt;/summary&amp;gt; public abstract string GetDescription(); /// &amp;lt;summary&amp;gt; /// 供應咖啡 /// &amp;lt;/summary&amp;gt; public abstract void Serve(); } ☕ 實作具體元件 using System; /// &amp;lt;summary&amp;gt; /// 基本咖啡 /// &amp;lt;/summary&amp;gt; public class SimpleCoffee : Coffee { /// &amp;lt;summary&amp;gt; /// 取得描述 /// &amp;lt;/summary&amp;gt; public override string GetDescription() =&amp;gt; &amp;#34;基本咖啡&amp;#34;; /// &amp;lt;summary&amp;gt; /// 供應咖啡 /// &amp;lt;/summary&amp;gt; public override void Serve() { Console.</description></item><item><title>Day 15: 【後端 #3】API 測試：用 Gemini CLI 輔助撰寫 Pytest</title><link>/ChiYu-Blob/posts/2025ithomeironmanday15/</link><pubDate>Wed, 03 Sep 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday15/</guid><description>安安，我是 ChiYu！
昨天，我們的 CI 品管員 (GitHub Actions) 成功上崗，確保了所有程式碼的「風格」都符合最高標準。
但是，一本語法完全正確的食譜，不代表按照它做出來的菜就一定好吃。我們的專案，即使程式碼風格再優雅，如果 API 的商業邏輯出現錯誤，那依然是嚴重的品質問題。
今天，我們就要來建立一張更堅實的「 安全網」。我們將引入自動化測試，指揮 Gemini 化身為「 測試工程師」，為我們撰寫測試案例，並直接升級 CI 流程，確保我們的 API 邏輯永遠精準無誤！
Part 1：告別「手動點點點」：為什麼需要自動化測試？ 你可能會問：「我們不是已經用 Swagger UI 手動測試過 API 了嗎？」
手動測試在開發時很方便，但它有幾個致命缺點：效率極低、容易遺漏、無法規模化。當專案功能變多，你不可能每次修改後，都把所有 API 再手動點一次。
而自動化測試，就是「用程式碼來測試程式碼」。我們預先寫好一系列的「考卷」（測試案例），然後讓電腦在幾秒鐘內，自動「批改」我們的應用程式。
比喻來說：
自動化測試就像是高空走鋼索表演底下的那張「安全網」。有了它，開發者才能充滿信心地在鋼索上快速前進、大膽地嘗試新動作（重構或新增功能）。因為我們知道，即使不小心失足（不小心改壞了舊功能），這張安全網也會立刻接住我們（測試會失敗並報錯），而不是讓我們直接摔到地上（等使用者回報 Bug）。
Part 2：我們的測試武器：Pytest Pytest 是 Python 世界中最受歡迎、也最簡單易用的測試框架。我們將用它來撰寫我們的「考卷」。
Part 3：Vibe Coding 實戰：與 AI 測試工程師的協作 準備好了嗎？讓我們進入 gemini chat 模式，一步步指揮我們的 AI 測試工程師。
Step 1: 命令 AI 設置「測試實驗室」 首先，我們要讓 AI 為我們準備好測試所需的環境。
【魔法詠唱：設置測試環境】 好的，我們準備為專案加入自動化測試。
請幫我執行以下任務：
安裝測試框架: 使用 pip 安裝 pytest。 更新依賴清單: 將 pytest 新增到 requirements.</description></item><item><title>外觀模式：化繁為簡</title><link>/ChiYu-Blob/posts/%E5%A4%96%E8%A7%80%E6%A8%A1%E5%BC%8F%E5%8C%96%E7%B9%81%E7%82%BA%E7%B0%A1/</link><pubDate>Thu, 12 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E5%A4%96%E8%A7%80%E6%A8%A1%E5%BC%8F%E5%8C%96%E7%B9%81%E7%82%BA%E7%B0%A1/</guid><description>哈囉大家～今天的主題非常實用，那就是「外觀模式（Facade）」！這個模式可以有效地讓複雜的系統變得簡單又好用，就像你按下遙控器的開機鍵，電視就會自動開啟、調整音量，甚至切換到你最愛的頻道一樣。
🌟 外觀模式是什麼？ 外觀模式其實就是為複雜系統提供一個簡單的介面，讓使用者不需要了解複雜的細節，就能輕鬆操作系統內部的功能。
例如，去電影院看電影時，你只需要買一張電影票，電影院就幫你搞定座位安排、播放電影、空調系統等等，這就是外觀模式的概念啦！
🤔 什麼情況適合用外觀模式？ 當你遇到以下的狀況時，特別適合使用外觀模式：
系統變得複雜，使用者需要了解太多細節。 想提供一個簡單的介面給使用者，隱藏複雜的內部運作細節。 想降低系統的耦合性，提高易用性與可維護性。 🎬 C# 外觀模式範例 這次我們就用「電影院系統」的例子，來看看外觀模式怎麼運作吧！
🎥 複雜的子系統類別 using System; /// &amp;lt;summary&amp;gt; /// 投影機 /// &amp;lt;/summary&amp;gt; public class Projector { /// &amp;lt;summary&amp;gt; /// 開啟投影機 /// &amp;lt;/summary&amp;gt; public void TurnOn() =&amp;gt; Console.WriteLine(&amp;#34;投影機已開啟。&amp;#34;); /// &amp;lt;summary&amp;gt; /// 關閉投影機 /// &amp;lt;/summary&amp;gt; public void TurnOff() =&amp;gt; Console.WriteLine(&amp;#34;投影機已關閉。&amp;#34;); } /// &amp;lt;summary&amp;gt; /// 音響系統 /// &amp;lt;/summary&amp;gt; public class AudioSystem { /// &amp;lt;summary&amp;gt; /// 開啟音響系統 /// &amp;lt;/summary&amp;gt; public void TurnOn() =&amp;gt; Console.</description></item><item><title>Day 16: 【整合篇】後端竣工！回顧與展望</title><link>/ChiYu-Blob/posts/2025ithomeironmanday16/</link><pubDate>Thu, 04 Sep 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday16/</guid><description>安安，我是 ChiYu！
走到這一步，請先放下鍵盤，靠在椅背上，深呼吸，然後給自己一個最真誠、最響亮的掌聲！你真的非常、非常了不起！
今天，是我們「左手藍圖，右手魔法」協奏曲的上半場終章。我們將暫時放下後端的程式碼，為過去兩週緊湊而充實的奮鬥，畫下一個完美的句點。今天的議程很簡單：慶祝，回顧我們走了多遠，沉澱我們學到了什麼，然後滿懷期待地展望未來。
Part 1：旅程回顧：從一個模糊的想法到一個會說話的後端 還記得兩週前的我們嗎？那時，我們手中只有一個飄在空中的、模糊的想法：「我想做個能幫助人們的習慣追蹤器」。它很美好，但也很脆弱。
而現在，經過十四天的淬鍊，我們共同打造出了一個堅實的、看得見摸得著的成果。它不再只是一個想法，而是一個功能完整、經過雙重自動化驗證、穩定可靠的後端服務。我們親手賦予了它骨骼與心跳。
讓我們一同盤點，在這趟旅程中，我們從無到有，創造了哪些寶貴的「數位資產」：
一套完整的「設計藍圖」：我們產出了五份彼此關聯、層層遞進的專業文件。從定義方向的《專案章程》，到釐清需求的《使用者故事》，再到搭建骨架的《軟體架構》、規劃數據的《資料庫綱要》，最終確立契約的《API 規格書》。這套藍圖，是我們所有工作的「單一真理來源」，它確保了我們的航行始終朝著正確的航向。 一組強大的「核心 API」：我們利用 Vibe Coding，高效地實作了身份驗證、習慣管理等所有核心的 CRUD 端點。這些 API 就是我們餐廳廚房の爐火，是我們專案未來所有功能的動力來源。 一道堅實的「自動化品質防線」：我們建立了兩道 CI 品質防線。flake8 如同一位嚴謹的文學編輯，確保我們的程式碼風格優雅；pytest 則像一位精明的邏輯考官，確保我們的功能邏輯準確無誤。這道防線，是我們未來敢於快速迭代、大膽重構的最大底氣。 一套進化的「AI 協作方法論」：這或許是我們最大的收穫。我們不再只是 AI 的使用者，我們學會了如何扮演指揮家，透過精準的 Prompt，引導 AI 成為我們的產品經理、架構師、甚至是測試工程師。我們掌握了一套能夠駕馭 AI，進行現代化高效開發的全新工作流。 我們嚴格地遵循了「先有藍圖，再有魔法」的原則，而這整個過程，其實隱含了許多超越程式碼本身、能讓你受用無窮的專業開發心法。
Part 2：超越程式碼的三個核心心法 在我們為上半場畫下句點之前，讓我們花點時間，從我們剛剛完成的後端專案中，提煉出幾個更深層次的、關於「如何思考」的專業心法。
心法一：各司其職的藝術 (關注點分離) 回想我們的餐廳比喻： 前台（Frontend） 負責點餐、 廚房（Backend） 負責做菜、 食材庫（Database）負責存貨。它們各司其職，互不干涉，透過定義好的流程（API）來溝通。這在軟體開發中，被稱為「關注點分離 (Separation of Concerns)」 。這不僅是一種技術，更是一種思維的紀律。它讓我們在面對複雜問題時，能夠將其拆解成一個個獨立、可管理的小問題，然後逐一擊破。
對 Vibe Coding 的啟示是：當你向 AI 提問時，也要保持這種思維紀律。一次只專注在一件事上。正是因為我們將任務拆解成「幫我設計資料庫」、「幫我生成 API」、「幫我寫測試」，我們才避免了 Day 1 那種「我想要一台腳踏車，AI 卻給我一艘航空母艦」的失控窘境。你的問題越聚焦，AI 給你的答案品質就越高，你也越能掌控最終的結果。
心法二：跟隨慣例，事半功倍 (慣例優於設定) 你可能已經發現，我們遵循了很多「慣例 (Convention)」：測試檔案放在 tests/，CI 設定檔放在 .github/workflows/，依賴套件寫在 requirements.txt。這些都不是硬性規定，但它們是整個開發者社群歷經多年演化，沉澱下來的「最佳實踐」。
這就是 「慣例優於設定 (Convention over Configuration)」 的哲學。當我們遵循社群普遍認可的慣例時，就等於在使用一種「共通語言」。這使得我們的專案對於任何一位有經驗的開發者（甚至是 AI！）來說，都是熟悉且可預測的。它大幅降低了溝通成本與新成員的學習曲線，同時也讓許多工具能夠「開箱即用」。</description></item><item><title>享元模式：節省記憶體的利器</title><link>/ChiYu-Blob/posts/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E7%AF%80%E7%9C%81%E8%A8%98%E6%86%B6%E9%AB%94%E7%9A%84%E5%88%A9%E5%99%A8/</link><pubDate>Thu, 12 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E7%AF%80%E7%9C%81%E8%A8%98%E6%86%B6%E9%AB%94%E7%9A%84%E5%88%A9%E5%99%A8/</guid><description>哈囉各位朋友，今天我們要聊的是一個特別省資源的設計模式：享元模式（Flyweight）。
🌟 享元模式是什麼？ 享元模式是一種可以有效節省記憶體的設計模式，透過共享相同或相似的物件，避免建立過多重複的小型物件。
舉個例子：假設你在做簡報，需要大量使用同一張圖片，與其在每張投影片裡都重新複製一次圖片，不如只保留一張原始圖片，其他投影片只需要參考這張圖片就好。這樣一來可以降低檔案大小，節省記憶體。
🤔 什麼情境適合使用享元模式？ 系統中存在大量重複的物件。 物件的建立與銷毀成本過高，並且這些物件大多類似。 想節省記憶體資源，提升系統效能。 🌳 C# 享元模式範例 以下以遊戲中常見的「樹木」為例，示範享元模式的實作方式。
🌳 享元介面與實作 using System; /// &amp;lt;summary&amp;gt; /// 樹木介面 /// &amp;lt;/summary&amp;gt; public interface ITree { /// &amp;lt;summary&amp;gt; /// 顯示樹木 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;x&amp;#34;&amp;gt;位置 X 座標&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;y&amp;#34;&amp;gt;位置 Y 座標&amp;lt;/param&amp;gt; void Display(int x, int y); } /// &amp;lt;summary&amp;gt; /// 具體享元類別 /// &amp;lt;/summary&amp;gt; public class Tree : ITree { private readonly string _treeType; public Tree(string treeType) { _treeType = treeType; Console.</description></item><item><title>Day 17: 【前端 #0】前端世界的基石： HTML, CSS 與 JavaScript</title><link>/ChiYu-Blob/posts/2025ithomeironmanday17/</link><pubDate>Fri, 05 Sep 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday17/</guid><description>安安，我是 ChiYu！
昨天，我們為精彩的後端開發之旅，畫下了一個完美的句點。我們現在擁有一個性能強大、穩定可靠的「專案引擎」，一顆強壯、默默跳動的心臟，但它還沒有形體，等待著被賦予生命。
從今天起，我們將正式開啟一個全新的篇章： 前端開發。我們將從幕後的「引擎工程師」，搖身一變，成為面向使用者的「 造物主」與「 生命設計師」。
但在我們開始 Vibe Coding 我們的數位生命之前，我們必須先花一天時間，回歸本心，認識一下構成生命的三大基本元素。今天，是前端開發的 Day 0，我們不寫任何一行專案程式碼，只專注於一件事：用最簡單的比喻和親手實作，讓你徹底搞懂構成全世界所有網頁的生命三要素——HTML, CSS, 與 JavaScript。
Part 1：HTML - 生命的「骨骼」 想像一下我們要創造一個生命體。我們做的第一件事是什麼？塑造它的骨架。這就是 HTML (HyperText Markup Language) 的角色。
HTML 的唯一職責，就是定義網頁的「內容」與「結構」。它決定了這個生命體「有哪些器官」，但完全不管它「長什麼樣子」。
&amp;lt;h1&amp;gt; 標籤告訴瀏覽器：「嘿，這是頭顱」，是思考的中心。 &amp;lt;p&amp;gt; 標籤說：「這是一塊軀幹」，是身體的主體。 &amp;lt;img&amp;gt; 標籤說：「這裡要有眼睛」，用來觀看世界。 &amp;lt;button&amp;gt; 標籤說：「這裡要有手」，用來與世界互動。 HTML 就是生命的骨架，最基礎、最核心，沒有它，皮囊與肌肉都將無所依附。
【動手玩玩看 #1】 建立實驗室：在你的電腦桌面，建立一個新的資料夾，取名為 frontend-playground。 用 VS Code 開啟：打開 VS Code，點擊左上角「檔案 (File)」-&amp;gt;「開啟資料夾 (Open Folder)」，然後選擇我們剛剛建立的 frontend-playground。 建立 HTML 檔案：在 VS Code 左側的檔案總管中，點擊「新增檔案」的圖示，將檔案命名為 index.html。 貼上骨架程式碼：將下面的程式碼，完整地複製並貼到你剛剛建立的 index.html 檔案中。 &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;我的生命體&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;這是頭顱&amp;lt;/h1&amp;gt; &amp;lt;p&amp;gt;這是一塊樸素的軀幹。&amp;lt;/p&amp;gt; &amp;lt;button&amp;gt;這是一隻手&amp;lt;/button&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 預覽結果：直接在檔案總管中，找到 index.</description></item><item><title>代理模式：控制存取的守門員</title><link>/ChiYu-Blob/posts/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E6%8E%A7%E5%88%B6%E5%AD%98%E5%8F%96%E7%9A%84%E5%AE%88%E9%96%80%E5%93%A1/</link><pubDate>Thu, 12 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E6%8E%A7%E5%88%B6%E5%AD%98%E5%8F%96%E7%9A%84%E5%AE%88%E9%96%80%E5%93%A1/</guid><description>哈囉各位朋友～今天我們要介紹的是很實用且日常生活也常碰到的 代理模式（Proxy）！
🌟 代理模式是什麼？ 代理模式提供一個中介物件來控制對某個目標物件的存取，藉此加入額外行為或保護原本的物件。 就像看醫生必須先掛號一樣，櫃檯人員就是代理，他負責管理你與醫生之間的互動。
🤔 什麼情況適合用代理模式？ 需要控制物件的存取權限，例如安全管理或權限限制。 想延遲建立昂貴的物件實例，例如檔案或資料庫連線。 想在不影響原有物件的情況下，加入額外行為（例如日誌紀錄）。 🛂 C# 代理模式範例 這裡以「檔案存取權限控制」為例，示範代理模式的實作。
📂 定義共通介面 /// &amp;lt;summary&amp;gt; /// 檔案介面 /// &amp;lt;/summary&amp;gt; public interface IFile { /// &amp;lt;summary&amp;gt; /// 顯示檔案內容 /// &amp;lt;/summary&amp;gt; void Display(); } 📄 建立具體物件類別 using System; /// &amp;lt;summary&amp;gt; /// 真實存取檔案的類別 /// &amp;lt;/summary&amp;gt; public class RealFile : IFile { private readonly string _fileName; public RealFile(string fileName) { _fileName = fileName; LoadFromDisk(fileName); } /// &amp;lt;summary&amp;gt; /// 顯示檔案 /// &amp;lt;/summary&amp;gt; public void Display() { Console.</description></item><item><title>Day 18: 【文件 #6】網站的風格指南：用 Gemini 定義顏色與字體</title><link>/ChiYu-Blob/posts/2025ithomeironmanday18/</link><pubDate>Sat, 06 Sep 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday18/</guid><description>安安，我是 ChiYu！
昨天，我們扮演了「造物主」，理解了構成數位生命的三大基本元素：HTML (骨骼)、CSS (皮囊) 與 JavaScript (肌肉)。
我們的生命體現在有了基本的構造，但它還沒有「氣質」與「個性」。它的膚色、瞳孔顏色、說話的語氣（字體）都尚未被定義。如果我們現在就開始隨心所欲地為它上色、化妝，最終很可能會創造出一個風格混亂、不忍直視的「四不像」。
因此，在我們動手寫任何一行 CSS 之前，我們要再次回到我們最信賴的工作流程——文件驅動。今天，我們將化身為「 首席視覺設計師」，與我們的 AI 夥伴 Gemini 深度對談，為我們的 App 定義一套獨一無二的視覺風格，並將其記錄成一份專業的**「風格指南 (Style Guide)」**文件。
Part 1：什麼是「風格指南」？為什麼它是設計的「DNA」？ 「風格指南」是一份定義了專案所有視覺元素（顏色、字體、間距、圖示、按鈕樣式等）使用規則的「設計聖經」。它就是我們數位生命的 「基因圖譜 (DNA)」。
為什麼我們需要它？
確保一致性 (Consistency)：一份好的風格指南，能確保你網站上的每一個按鈕、每一段文字，看起來都像是來自同一個「家族」。這種視覺上的一致性，會給使用者帶來專業、可靠、值得信賴的感覺。 提升開發效率 (Efficiency)：它能將設計師與工程師從無盡的「這個藍色深一點還是淺一點？」、「這個標題用多大字體？」的決策地獄中解放出來。我們不再需要每次都重新發明輪子，只需要遵循 DNA 的指示即可。 賦予 AI 清晰的指令：這對我們 Vibe Coding 的流程至關重要！當我們有了這份文件，未來就可以直接對 Gemini 說：「請用我們的 primary-color 設計一個按鈕」，AI 就能立刻理解並產出符合我們整體風格的程式碼。 Part 2：定義我們 App 的「Vibe」- 專案的個性 在挑選顏色和字體之前，我們得先回答一個更根本的問題：我們希望這個 App 給人什麼樣的「感覺 (Vibe)」？
回顧我們 Day 5 的專案章程，我們的願景是「賦予使用者力量，建立正向習慣並擁抱更健康的心態」。基於這個願景，我們可以提煉出幾個關鍵詞來定義我們 App 的個性：
Calm (平靜)：介面應該是簡潔、無干擾的，讓使用者能專注於紀錄與反思。 Encouraging (鼓勵)：視覺元素應該帶有溫度，給人一種積極、正向的感覺。 Clean (乾淨)：佈局要清晰，留有足夠的呼吸空間 (留白)，避免資訊過載。 Trustworthy (可靠)：設計要專業、一致，讓使用者願意將他們的個人數據託付給我們。 這幾個關鍵詞，就是我們接下來與 Gemini 溝通時的「通關密語」。</description></item><item><title>責任鏈模式：層層把關的處理機制</title><link>/ChiYu-Blob/posts/%E8%B2%AC%E4%BB%BB%E9%8F%88%E6%A8%A1%E5%BC%8F%E5%B1%A4%E5%B1%A4%E6%8A%8A%E9%97%9C%E7%9A%84%E8%99%95%E7%90%86%E6%A9%9F%E5%88%B6/</link><pubDate>Thu, 12 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E8%B2%AC%E4%BB%BB%E9%8F%88%E6%A8%A1%E5%BC%8F%E5%B1%A4%E5%B1%A4%E6%8A%8A%E9%97%9C%E7%9A%84%E8%99%95%E7%90%86%E6%A9%9F%E5%88%B6/</guid><description>哈囉～又來到了我們設計模式系列啦，今天要介紹的是一個非常靈活又好用的模式：責任鏈模式（Chain of Responsibility）。
🌟 責任鏈模式是什麼？ 責任鏈模式是一種將請求逐一傳遞，直到找到合適的處理者來處理的設計模式。就像公司報銷流程，先交給直屬主管簽核，如果權限不足就往上一層，直到有權限的人批准為止。
透過這個模式，每個處理者只專注自己的職責，無法處理的部分就交給下一個處理者，既清楚又明確。
🤔 什麼情況適合使用責任鏈模式？ 多個物件都能處理同一個請求，但條件或處理範圍不同。 責任層級可能會更動，希望降低請求者與處理者的耦合度。 想讓系統更彈性，可依需求增減處理節點。 📝 C# 責任鏈模式範例 以下以「公司費用審核」為例，示範責任鏈模式的實作。
💼 建立抽象處理者（Handler） using System; /// &amp;lt;summary&amp;gt; /// 抽象處理者 /// &amp;lt;/summary&amp;gt; public abstract class Approver { /// &amp;lt;summary&amp;gt; /// 下一位處理者 /// &amp;lt;/summary&amp;gt; protected Approver _nextApprover; /// &amp;lt;summary&amp;gt; /// 設定下一位處理者 /// &amp;lt;/summary&amp;gt; public void SetNext(Approver approver) { _nextApprover = approver; } /// &amp;lt;summary&amp;gt; /// 處理請求 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;amount&amp;#34;&amp;gt;請求金額&amp;lt;/param&amp;gt; public abstract void HandleRequest(decimal amount); } 👩‍💻 建立具體處理者（主管、經理、總經理） using System; /// &amp;lt;summary&amp;gt; /// 主管 /// &amp;lt;/summary&amp;gt; public class Supervisor : Approver { public override void HandleRequest(decimal amount) { if (amount &amp;lt;= 1000) { Console.</description></item><item><title>Day 19: 【文件 #7】頁面的骨架：用 Gemini 規劃主佈局與元件拆分</title><link>/ChiYu-Blob/posts/2025ithomeironmanday19/</link><pubDate>Sun, 07 Sep 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday19/</guid><description>安安，我是 ChiYu！
昨天，我們扮演了「首席視覺設計師」，為我們的數位生命，定義了一套獨一無二的「基因圖譜 (DNA)」——我們的 風格指南。現在，我們有了調色盤、有了字體，知道了這個生命體該有的氣質。
但光有這些還不夠。在我們開始為它披上皮囊（寫 CSS）之前，我們需要先確定它的「身體結構」。它的頭、身體、四肢要如何組織？身體的各個器官（按鈕、卡片、列表）又要如何劃分？
今天，我們將化身為「UI 架構師」，再次回到我們最信賴的文件驅動流程。我們將指揮 Gemini，根據我們的使用者故事，設計出網站的 主要佈局 (Layout)，並將複雜的介面，拆解成一份清晰的、可重複使用的 元件清單 (Component Breakdown)。
Part 1：什麼是「佈局 (Layout)」？—— 房子的「格局規劃」 如果說昨天的風格指南是「室內設計風格」（例如：北歐風、工業風），那今天的「佈局」，就是這棟房子的「格局規劃圖」。
它定義了整個應用程式最頂層的、共通的結構。例如：
玄關/大廳 (Header / Navbar)：訪客一進門會看到的地方，通常包含 Logo 和主要的導覽連結。 客廳/主要活動區 (Main Content Area)：這是房子的核心，大部分的活動都會在這裡發生。 書房/側邊功能區 (Sidebar)：一個固定的區域，用來放置次要的導覽或工具。 陽台/頁腳 (Footer)：房子的底部，通常放一些版權資訊或次要連結。 先定義好這個共通的「格局」，能確保使用者在我們網站的不同房間（頁面）之間穿梭時，永遠不會迷路，擁有一致且可預測的體驗。
Part 2：什麼是「元件拆分」？—— 用「樂高」來蓋房子 這是一個現代前端開發中，最最最重要的核心思想。
想像一下，你要蓋一座樂高城堡。你不會每次都從最微小的顆粒開始，一顆一顆地去想要怎麼組成一扇窗戶。一個聰明的樂高玩家，會先預先組裝好幾種標準尺寸的「窗戶」、「門」、「城牆塊」、「塔頂」——這些，就是我們的 「元件 (Component)」。
當你要蓋城堡時，你只需要像組合積木一樣，把這些預先做好的「元件」拼裝起來即可。
*「元件拆分 (Component Breakdown)」 **就是這個過程。我們在動手寫程式碼之前，先審視我們的設計稿（或使用者故事），然後像玩樂高一樣，思考：「這個介面，可以拆解成哪些可以重複使用的積木？」 這樣做的好處是：
可複用性 (Reusability)：我們只需要設計和製作一次「習慣卡片」這個元件，之後在儀表板、回顧頁面，都可以重複使用它。 可維護性 (Maintainability)：未來如果想修改所有習慣卡片的樣式，我們只需要修改一個地方，所有用到它的地方就全部更新了！ Vibe Coding 的加速器：這是最關鍵的一點！當我們定義好元件後，未來就可以直接對 Gemini 說：「幫我生成一個 HabitCard 元件的程式碼」，AI 就能根據這份文件，精準地產出我們需要的「樂高積木」。 Part 3：實戰開始：讓 Gemini 成為我們的 UI 架構師 好了，理論武裝完畢，讓我們再次召喚 Gemini CLI，請它扮演我們的 UI 架構師。</description></item><item><title>命令模式：靈活封裝的請求指令</title><link>/ChiYu-Blob/posts/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E9%9D%88%E6%B4%BB%E5%B0%81%E8%A3%9D%E7%9A%84%E8%AB%8B%E6%B1%82%E6%8C%87%E4%BB%A4/</link><pubDate>Thu, 12 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E9%9D%88%E6%B4%BB%E5%B0%81%E8%A3%9D%E7%9A%84%E8%AB%8B%E6%B1%82%E6%8C%87%E4%BB%A4/</guid><description>哈囉大家，今天我們來聊聊 命令模式（Command），這個設計模式能幫助你將請求封裝成物件，讓你可以輕鬆地操作、延遲或撤銷命令。
🌟 命令模式是什麼？ 命令模式是一種將「動作」封裝成獨立物件的設計模式。這樣做的好處是，你可以隨時決定何時執行這個動作，甚至是取消它。
舉個例子來說，就像餐廳點餐時，你的每一份點餐單都是一個命令，廚房按照你的點餐單來做餐點，服務生只需將點餐單交給廚房即可，不需要知道廚房如何烹飪食物。
🤔 什麼情況適合使用命令模式？ 想要將執行動作的物件與觸發動作的物件解耦。 需要將命令排程、延遲或撤銷。 想記錄請求歷史，以支援撤銷操作。 🍔 C# 命令模式範例 這次我們以餐廳點餐的例子來實作命令模式。
📝 定義命令介面 /// &amp;lt;summary&amp;gt; /// 命令介面 /// &amp;lt;/summary&amp;gt; public interface ICommand { /// &amp;lt;summary&amp;gt; /// 執行命令 /// &amp;lt;/summary&amp;gt; void Execute(); } 🍲 建立具體命令 using System; /// &amp;lt;summary&amp;gt; /// 點餐命令 /// &amp;lt;/summary&amp;gt; public class OrderCommand : ICommand { private readonly Kitchen _kitchen; private readonly string _dish; public OrderCommand(Kitchen kitchen, string dish) { _kitchen = kitchen; _dish = dish; } /// &amp;lt;summary&amp;gt; /// 執行點餐動作 /// &amp;lt;/summary&amp;gt; public void Execute() { _kitchen.</description></item><item><title>Day 20: 【前端 #1】Gemini Canvas 生成UI (還有新的AI建議功能)</title><link>/ChiYu-Blob/posts/2025ithomeironmanday20/</link><pubDate>Mon, 08 Sep 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday20/</guid><description>安安，我是 ChiYu！
昨天，我們完成了前端開發的最後一份規劃文件。至此，我們所有的「左手藍圖」工作，全部大功告成！
從今天起，我們將正式拿起工具，戴上安全帽，開始 Vibe Coding 的前端實作！但&amp;hellip; 我們真的要像傳統的「建築工人」那樣，一行一行地去搭建 HTML 骨架，再一點一點地去粉刷 CSS 樣式嗎？
不！時代變了！今天，我們要直接從「建築工人」一步到位，升級成「魔法建築師」！我們不再一磚一瓦地蓋房子，我們要直接攤開我們的設計藍圖，對著 Gemini 詠唱咒語，瞬間召喚出一棟功能完整、外觀精美的 UI 原型！
Part 1：為什麼要用 Canvas？—— 從「盲人摸象」到「上帝視角」 在 Day 12，我們體驗了在終端機 Vibe Coding 的快感。它很酷，但對於 UI 開發來說，它有個小缺點：我們就像是在黑暗中「盲人摸象」，敲下一行指令，然後切換到瀏覽器看看成果，來來回回，效率不高。
而 Gemini Web UI 的 Canvas 功能，則給了我們截然不同的體驗——「上帝視角」。
Canvas 是一個視覺化的 AI 互動介面，它能讓我們在描述需求的同時，即時預覽 AI 生成的 UI 畫面。它追求的是 「極速視覺化」，讓我們能在幾分鐘內，就得到一個可以直接互動、外觀精美的 UI 原型。這對於前端開發來說，簡直是夢幻般的工具！
Part 2：Canvas 實戰：為 AI 建築師提供「設計圖」 現在，讓我們打開我們的「魔法實驗室」—— gemini.google.com，然後選擇 Canvas 功能。我們要學習一門全新的 Prompt 技巧：如何用文字，向一位魔法建築師描述一棟房子？
答案很簡單：把我們嘔心瀝血產出的設計文件餵給它！
【魔法詠唱：UI 生成咒語】 # 角色 (Role) 你是一位頂尖的前端工程師，精通 HTML, CSS, JavaScript，並且對 UI/UX 設計有深刻的理解。 # 目標 (Objective) 請根據我提供的設計文件和詳細需求，為我生成一個功能完整的「習慣追蹤器」Web UI 的**單一 HTML 檔案** # 上下文 (Context) - **風格指南**: STYLE_GUIDE.</description></item><item><title>解譯器模式：讓程式聽懂你的指令</title><link>/ChiYu-Blob/posts/%E8%A7%A3%E8%AD%AF%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%AE%93%E7%A8%8B%E5%BC%8F%E8%81%BD%E6%87%82%E4%BD%A0%E7%9A%84%E6%8C%87%E4%BB%A4/</link><pubDate>Thu, 12 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E8%A7%A3%E8%AD%AF%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%AE%93%E7%A8%8B%E5%BC%8F%E8%81%BD%E6%87%82%E4%BD%A0%E7%9A%84%E6%8C%87%E4%BB%A4/</guid><description>哈囉各位朋友，今天我們來認識一個有趣又實用的設計模式：解譯器模式（Interpreter），並以好玩的「文字冒險遊戲」為例，輕鬆學會如何讓你的程式讀懂自訂語言或指令。
🌟 解譯器模式是什麼？ 解譯器模式是一種用來解析特定語言或表達式的設計模式，它能夠讓你的程式懂得使用者輸入的特定語法或指令，並做出相應的回應或行動。
就像在玩文字冒險遊戲時，你輸入「攻擊 巨龍 使用 火球」，遊戲就能理解你的指令，並做出相應的動作一樣。
🤔 什麼情況適合使用解譯器模式？ 需要處理使用者輸入的特殊指令或語法。 想設計一個易於擴充與修改的指令解析系統。 系統需要理解並執行使用者自定義的操作。 🎮 C# 解譯器模式範例（文字冒險遊戲） 以下以文字冒險遊戲為例，示範如何透過解譯器模式解析玩家輸入的指令。
🎲 定義抽象指令介面 /// &amp;lt;summary&amp;gt; /// 遊戲指令介面 /// &amp;lt;/summary&amp;gt; public interface IGameCommand { /// &amp;lt;summary&amp;gt; /// 執行指令 /// &amp;lt;/summary&amp;gt; void Execute(); } ⚔️ 建立具體指令 using System; /// &amp;lt;summary&amp;gt; /// 攻擊指令 /// &amp;lt;/summary&amp;gt; public class AttackCommand : IGameCommand { private readonly string _target; // 攻擊目標 private readonly string _weapon; // 使用武器 public AttackCommand(string target, string weapon) { _target = target; _weapon = weapon; } /// &amp;lt;inheritdoc /&amp;gt; public void Execute() { Console.</description></item><item><title>Day 21: 【前端 #2】從原型到架構：拆解並整合 AI 生成的 UI 程式碼</title><link>/ChiYu-Blob/posts/2025ithomeironmanday21/</link><pubDate>Tue, 09 Sep 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday21/</guid><description>安安，我是 ChiYu！
昨天那場「視覺魔法秀」是不是超震撼的？才幾分鐘，AI 就「咻」一下變出一個又美又能動的 UI 原型，真的太扯了！這證明 AI 拿來做 prototype 根本是開外掛啊。
不過，身為一個有格調的工程師，光是「能動」怎麼夠呢？今天，我們就要來當個「結構工程師」，幫這棟魔法變出來的漂亮房子，來個專業級的 「大改造 (Refactoring)」！
Part 1：心法時間：為什麼高手絕對不把 CSS 跟 JS 塞在同一個 HTML 檔？ 昨天 AI 給我們的那個檔案，HTML、CSS、JavaScript 全都擠在一起。拿來看看樣子當然很方便，但在真專案裡，這樣搞可是超級大忌喔！為什麼？這背後藏著三個高手才知道的心法：
各管各的 (Separation of Concerns)：這點最重要！HTML 是骨架、CSS 是外表、JS 是肌肉，大家各有各的工作。把它們全混在一起，就像把廚房、臥室、客廳的功能全塞到一個房間裡，保證亂到你媽都認不出來，以後要修根本是惡夢！ 讓瀏覽器偷懶 (Browser Caching)：你想想，你把 CSS 跟 JS 分開成獨立檔案後，瀏覽器第一次看完，就可以把它們存起來。下次你再逛同個網站的其他頁面，因為 style.css 跟 script.js 沒變，瀏覽器就不用再下載一次，直接拿舊的來用就好，這樣網站跑起來才會飛快啊！ 大家好做事 (Maintainability &amp;amp; Collaboration)：專案一搞大，肯定不止你一個人寫。把檔案分開，管畫面的同事就專心搞 .css，管功能的就專心搞 .js，大家井水不犯河水，才不會打架，做事效率才會高嘛！ 所以啦，我們的目標很簡單，就是把昨天那個漂亮的「藝術品」，改造成一個真正可以用在專案上、結構超清楚的「工業級產品」！
Part 2：開工啦：來唸個「一鍵改造」的超級咒語 這個精細的「分家手術」，我們不用慢慢來。我們要用一個更猛的 Prompt，直接叫 AI 「一次搞定」！
Step 1: 把昨天變出來的魔法成果搬進來 首先，當然是把昨天的成果，正式放到我們的專案裡。
建立前端基地：在 VS Code 的專案根目錄，建立一個叫 frontend 的新資料夾。 儲存原型：把昨天從 Canvas 下載或複製的完整程式碼，在 frontend 資料夾裡存成 prototype.</description></item><item><title>迭代器模式：輕鬆遍歷集合元素</title><link>/ChiYu-Blob/posts/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%BC%95%E9%AC%86%E9%81%8D%E6%AD%B7%E9%9B%86%E5%90%88%E5%85%83%E7%B4%A0/</link><pubDate>Fri, 13 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%BC%95%E9%AC%86%E9%81%8D%E6%AD%B7%E9%9B%86%E5%90%88%E5%85%83%E7%B4%A0/</guid><description>哈囉朋友們～今天來聊聊迭代器模式（Iterator），這個設計模式能幫你輕鬆管理和操作集合中的元素。
🌟 什麼是迭代器模式？ 迭代器模式讓你可以逐一瀏覽集合中的每個元素，而不需知道集合的內部結構。 就像你用音樂 App 播放音樂時，播放清單會自動幫你一首一首播放下一首歌曲，你不需要知道歌曲是怎麼儲存的。這就是迭代器模式的精髓啦！
🤔 什麼情況適合使用迭代器模式？ 以下情況很適合使用迭代器模式：
當你需要循序瀏覽集合中的元素，但不想暴露集合的內部結構。 你希望使用相同的方式來遍歷不同類型的集合。 想要讓集合的操作更加直觀與易用。 🎧 C# 迭代器模式範例：音樂播放清單 我們以「音樂播放清單」為範例，讓你輕鬆理解迭代器模式的應用。
🎵 定義抽象迭代器介面 /// &amp;lt;summary&amp;gt; /// 迭代器介面 /// &amp;lt;/summary&amp;gt; public interface IIterator { /// &amp;lt;summary&amp;gt; /// 是否還有下一首 /// &amp;lt;/summary&amp;gt; bool HasNext(); /// &amp;lt;summary&amp;gt; /// 取得下一首歌曲 /// &amp;lt;/summary&amp;gt; string Next(); } 🎶 建立集合類別（播放清單） using System.Collections.Generic; /// &amp;lt;summary&amp;gt; /// 音樂播放清單 /// &amp;lt;/summary&amp;gt; public class Playlist { private readonly List&amp;lt;string&amp;gt; _songs = new(); // 儲存歌曲 /// &amp;lt;summary&amp;gt; /// 歌曲清單(唯讀) /// &amp;lt;/summary&amp;gt; public IReadOnlyList&amp;lt;string&amp;gt; Songs =&amp;gt; _songs; /// &amp;lt;summary&amp;gt; /// 新增歌曲 /// &amp;lt;/summary&amp;gt; public void AddSong(string song) { _songs.</description></item><item><title>Day 22: 【前端 #3】AI 一鍵生成完整 App 靜態 UI</title><link>/ChiYu-Blob/posts/2025ithomeironmanday22/</link><pubDate>Wed, 10 Sep 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday22/</guid><description>安安，我是 ChiYu！
昨天，我們扮演了一位冷靜而專業的「結構工程師」，成功地將 AI 生成的華麗原型，重構成為一個結構清晰、職責分明的專業前端專案。我們的 index.html, style.css, script.js 現在各司其職，一切都井井有條。
我們現在有了一個專業的「建築框架」，以及一些基本的「核心傢俱」（習慣列表和 Modal）。但是，我們的房子裡還有很多房間是空的，例如完整的導覽列、心情記錄區等等。
今天，我們的任務就是進行一場 「UI 補完計畫」！我們將繼續指揮我們的 AI 助手，根據我們所有的設計藍圖，在現有的專案基礎上，將 MVP 所需的所有靜態 UI 元素全部建造完成！
Part 1：今日的作戰計畫：完成我們的「樣品屋」 我們的目標非常明確：將我們目前的 UI，擴建成一個外觀上 100% 完整的樣品屋。使用者看到它時，會覺得這就是一個功能齊全的 App，即使它內部還沒有連上數據。
根據我們的《使用者故事》和《佈局元件》文件，我們今天需要補全以下幾個關鍵部分：
一個功能完整的側邊導覽列 (Sidebar)。 一個心情記錄區 (Mood Tracker)。 整體樣式微調，確保所有新舊元件完美融合。 Part 2：Vibe Coding 實戰：指揮 AI 進行「室內精裝修」 現在，讓我們回到 gemini chat 模式，指揮 AI 在我們現有的程式碼基礎上，進行一次**「增量開發 (Incremental Development)」**。這是一個非常重要的專業開發模式，代表我們不是每次都推倒重來，而是在現有基礎上，逐步疊加新功能。
【魔法詠唱：UI 擴建】 # 角色 (Role) 你是一位頂尖的前端工程師，精通語意化 HTML 和現代 CSS，擅長在現有專案基礎上，根據設計文件擴充 UI。 **# 目標 (Objective)** 請根據我提供的所有設計文件，擴充我現有的前端程式碼，補完 MVP 所需的全部靜態 UI 元素。 **# 上下文 (Context)** - **現有 HTML**: `@frontend/index.</description></item><item><title>中介者模式：管理複雜溝通的好幫手</title><link>/ChiYu-Blob/posts/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%E7%AE%A1%E7%90%86%E8%A4%87%E9%9B%9C%E6%BA%9D%E9%80%9A%E7%9A%84%E5%A5%BD%E5%B9%AB%E6%89%8B/</link><pubDate>Fri, 13 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%E7%AE%A1%E7%90%86%E8%A4%87%E9%9B%9C%E6%BA%9D%E9%80%9A%E7%9A%84%E5%A5%BD%E5%B9%AB%E6%89%8B/</guid><description>哈囉朋友們～今天要聊的設計模式是中介者模式（Mediator），這個模式能讓你的程式輕鬆管理物件之間複雜的溝通關係。
🌟 中介者模式是什麼？ 中介者模式透過一個中介者物件來協調其他物件之間的互動，避免物件間的直接聯繫導致的混亂。
想像你使用聊天室時，你並不直接跟每個使用者對話，而是透過聊天室作為中介，幫你發送訊息給其他使用者，這樣每個人只要與聊天室溝通即可，簡單明瞭。
🤔 什麼情況適合使用中介者模式？ 以下情況適合使用中介者模式：
當系統內有許多物件需要彼此溝通，關係變得複雜難以管理。 想降低物件間的耦合度，讓系統容易維護與擴充。 想集中管理物件之間的溝通邏輯。 💬 C# 中介者模式範例：聊天室應用程式 我們透過「聊天室」範例來實際展示中介者模式。
💻 定義中介者介面 /// &amp;lt;summary&amp;gt; /// 中介者介面 /// &amp;lt;/summary&amp;gt; public interface IChatMediator { /// &amp;lt;summary&amp;gt; /// 傳送訊息給其他使用者 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;message&amp;#34;&amp;gt;訊息內容&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;user&amp;#34;&amp;gt;發送者&amp;lt;/param&amp;gt; void SendMessage(string message, User user); /// &amp;lt;summary&amp;gt; /// 註冊使用者到聊天室 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;user&amp;#34;&amp;gt;新使用者&amp;lt;/param&amp;gt; void RegisterUser(User user); } 👥 建立具體中介者（聊天室） using System; using System.Collections.Generic; /// &amp;lt;summary&amp;gt; /// 聊天室中介者，負責轉發訊息 /// &amp;lt;/summary&amp;gt; public class ChatMediator : IChatMediator { private readonly List&amp;lt;User&amp;gt; _users = new(); // 聊天室中的使用者名單 /// &amp;lt;inheritdoc /&amp;gt; public void RegisterUser(User user) { _users.</description></item><item><title>Day 23: 【前端 #4】非同步的藝術：深入 Fetch API 與 Promise</title><link>/ChiYu-Blob/posts/2025ithomeironmanday23/</link><pubDate>Thu, 11 Sep 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday23/</guid><description>安安，我是 ChiYu！
昨天，我們扮演了一位「創世神」，指揮 AI 在一天之內，為我們建構出了 App 完整、精美的靜態 UI。我們現在手上，有了一個外觀完美，但沒有靈魂的「App 蠟像館」。
它很美，但它是靜默的。它無法感知外界，也無法與我們在後端建立的強大「大腦」進行溝通。
今天，我們就要來為它安裝這套至關重要的神經系統！我們將深入前端開發中最核心、也最讓新手困惑的觀念——非同步程式設計 (Asynchronous Programming)，並學習如何使用 Fetch API，讓前端的「身體」與後端的「大腦」進行第一次的歷史性對話！
Part 1：前端心法：為什麼我們需要「非同步」？ 想像一個場景：你去一家超紅的手搖飲店點餐。你點完一杯「珍珠鮮奶茶，半糖少冰」後，是會呆呆地站在櫃檯前，死盯著店員，從他開始煮珍珠、泡茶、加牛奶、到最後封膜，一步都不離開嗎？
當然不會！那樣不僅你自己浪費時間，還會把後面的客人全都堵死。一個正常的流程是：你點完餐，店員給你一個會震動的「取餐呼叫器」，然後你就可以去旁邊找個位子坐下、滑滑手機、看看書。等到飲料做好了，呼叫器「嗡嗡嗡」地震動，你再優雅地過去取餐。
前端與後端的溝通，就跟這個過程一模一樣！
同步 (Synchronous)：就是那個呆站在櫃檯的笨方法。如果前端用「同步」的方式去跟後端要資料（例如，去資料庫拿你的習慣列表），那整個網頁畫面就會完全卡死，捲動不了、按鈕沒反應，直到後端把資料傳回來為止。這對使用者來說，是災難性的體驗。 非同步 (Asynchronous)：就是那個聰明的「呼叫器」方法。前端發出一個請求給後端後，它不會原地等待，而是會繼續做自己的事（例如：保持畫面的流暢、回應使用者的其他操作）。後端處理完資料後，會透過一個機制「通知」前端：「嘿，你的資料好了，快來拿！」 而這個神奇的「呼叫器」，在 JavaScript 的世界裡，就叫做 Promise。
什麼是 Promise？ Promise 是一個物件，它代表一個「承諾」。當你呼叫一個非同步操作（例如 fetch）時，它會立刻回給你一個 Promise。這個 Promise 就像是那個取餐呼叫器，它有三種狀態：
Pending (等待中)：你剛拿到呼叫器，它還沒震動。代表飲料還在做。 Fulfilled (已實現)：呼叫器震動了！代表你的珍奶做好了（數據成功取回）。 Rejected (已拒絕)：呼叫器發出悲鳴！代表珍珠賣完了（網路錯誤或伺服器出錯）。 async/await：優雅地等待呼叫器 早期的 JavaScript 處理 Promise 非常麻煩（俗稱「回調地獄」），但現代 JS 提供了一套超級優雅的語法糖——async/await。它能讓我們用寫「同步」程式碼的感覺，來處理「非同步」操作，大大提升了程式碼的可讀性。
Part 2：Vibe Coding 實戰：建立我們的「通訊模組」 好了，理論武裝完畢！在我們開始呼叫 API 之前，專業的作法是建立一個專門負責與後端溝通的「通訊模組」，而不是把 fetch 寫得到處都是。這也是一種「關注點分離」！
Step 1: 命令 AI 建立 api.js 讓我們進入 gemini chat 模式，指揮 AI 為我們建立這個模組。</description></item><item><title>備忘錄模式：保存與恢復物件狀態</title><link>/ChiYu-Blob/posts/%E5%82%99%E5%BF%98%E9%8C%84%E6%A8%A1%E5%BC%8F%E4%BF%9D%E5%AD%98%E8%88%87%E6%81%A2%E5%BE%A9%E7%89%A9%E4%BB%B6%E7%8B%80%E6%85%8B/</link><pubDate>Fri, 13 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E5%82%99%E5%BF%98%E9%8C%84%E6%A8%A1%E5%BC%8F%E4%BF%9D%E5%AD%98%E8%88%87%E6%81%A2%E5%BE%A9%E7%89%A9%E4%BB%B6%E7%8B%80%E6%85%8B/</guid><description>哈囉朋友們！今天我們要介紹的是一個超實用的設計模式：備忘錄模式（Memento），透過它，我們可以輕鬆儲存並回復物件的狀態！
🌟 備忘錄模式是什麼？ 備忘錄模式允許你捕捉一個物件的內部狀態，並且在未來需要時，能夠將物件回復到原先的狀態。
就像玩遊戲時的「存檔」和「讀取進度」功能一樣，當你不小心走錯路或失敗時，可以輕鬆回到之前的狀態重新來過。
🤔 什麼情況適合使用備忘錄模式？ 當你有以下情境時，很適合使用備忘錄模式：
需要提供撤銷（undo）或回復（redo）操作。 物件狀態可能頻繁改變，且希望能隨時回到某個特定的狀態。 不想暴露物件內部狀態的細節給外部使用者。 🎮 C# 備忘錄模式範例：遊戲存檔系統 我們透過「遊戲角色存檔」來說明備忘錄模式的應用。
🎲 建立備忘錄（Memento） /// &amp;lt;summary&amp;gt; /// 遊戲狀態備忘錄 /// &amp;lt;/summary&amp;gt; public class GameMemento { /// &amp;lt;summary&amp;gt; /// 等級 /// &amp;lt;/summary&amp;gt; public int Level { get; } /// &amp;lt;summary&amp;gt; /// 生命值 /// &amp;lt;/summary&amp;gt; public int Health { get; } public GameMemento(int level, int health) { Level = level; Health = health; } } 🧙 遊戲角色（Originator） using System; /// &amp;lt;summary&amp;gt; /// 遊戲角色 /// &amp;lt;/summary&amp;gt; public class GameCharacter { /// &amp;lt;summary&amp;gt; /// 等級 /// &amp;lt;/summary&amp;gt; public int Level { get; set; } /// &amp;lt;summary&amp;gt; /// 生命值 /// &amp;lt;/summary&amp;gt; public int Health { get; set; } /// &amp;lt;summary&amp;gt; /// 顯示目前狀態 /// &amp;lt;/summary&amp;gt; public void DisplayStatus() { Console.</description></item><item><title>Day 24: 【前端 #5】狀態管理的哲學：讓 UI 成為數據的鏡子</title><link>/ChiYu-Blob/posts/2025ithomeironmanday24/</link><pubDate>Fri, 12 Sep 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday24/</guid><description>安安，我是 ChiYu！
昨天，我們的 App 經歷了一次歷史性的飛躍。我們為它安裝了「神經系統」，成功地讓前端的「身體」與後端的「大腦」進行了第一次對話。我們的 App 不再是離線的空殼，它擁有了「記憶」。
但是，這些寶貴的記憶，現在還只靜靜地躺在瀏覽器的 console 裡，像一本鎖在保險箱裡的日記，使用者完全無法窺見其貌。我們的 App 雖然有了記憶，但它還是一個「啞巴」，無法將自己的所思所想表達出來。
今天，我們就要來為 App 安裝「聲帶」和「表情肌肉」，教它如何開口說話。我們將深入探討一個區分業餘與專業前端開發的核心心法——狀態管理 (State Management)，並引入一個輕量的「狀態中心」模式，讓我們的 UI 成為數據最忠實的鏡子。
Part 1：前端心法：為什麼「直接操作 DOM」是個壞主意？ 你可能會想：「這很簡單啊！昨天拿到數據後，我用 JavaScript 的 document.createElement、appendChild 這些方法，手動把一個個習慣項目加到畫面上不就好了嗎？」
問得好！這確實是一種方法，但它就像一個木偶戲的師傅，用線牽引著木偶（DOM 元素）的一舉一動。當只有一兩個木偶時，這套方法還行得通。但想像一下，你的 App 越來越複雜，畫面上同時有幾十個木偶，它們之間還有複雜的互動，這位可憐的師傅很快就會手忙腳亂，把線纏在一起，最終導致整場表演崩潰。
「直接操作 DOM」的壞處在於：
程式碼極度混亂：你的 script.js 將會充滿各種查找元素、新增元素、刪除元素、修改樣式的程式碼，很快就會變得難以閱讀和維護。 狀態不一致：你很可能會忘記更新某個地方的數字，導致畫面上顯示的數據，跟你內心（程式碼變數）裡記得的數據不一致，這就是 Bug 的主要來源。 難以追蹤：當 Bug 出現時，你很難知道到底是哪一段手動操作，導致了畫面最終的錯誤狀態。 專業的作法：數據驅動畫面 那麼，專業的前端開發者是怎麼做的呢？他們不做那個辛苦的木偶師傅，而是做一位「劇本設計師」。
他們會建立一個唯一的**「劇本 (State)」，這個劇本用數據完整地描述了舞台上應該是什麼樣子。然後，他們會聘請一位叫做「渲染引擎 (Render Function)」的超級演員，這位演員的唯一工作，就是閱讀劇本，然後完美地將自己扮演成劇本描述的樣子**。
開發者的工作，從「手動去移動木偶的每一根手指」，變成了**「專心修改劇本」**。每當劇本（State）有任何變動，我們就大喊一聲：「卡！重來！」，然後渲染引擎就會立刻根據最新的劇本，重新表演一次，確保舞台上的畫面永遠與劇本 100% 同步。
這個「劇本」，就是我們的**「單一真理來源 (Single Source of Truth)」**。這個過程，就是 「數據驅動畫面 (Data-Driven UI)」 的核心哲學。
Part 2：Vibe Coding 實戰：建立我們的「狀態中心」與「渲染引擎」 好了，理論武裝完畢！讓我們進入 gemini chat 模式，指揮 AI 為我們重構昨天的邏輯，將這種專業的開發模式，注入我們的 App。</description></item><item><title>觀察者模式：即時通知的好幫手</title><link>/ChiYu-Blob/posts/%E8%A7%80%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%8D%B3%E6%99%82%E9%80%9A%E7%9F%A5%E7%9A%84%E5%A5%BD%E5%B9%AB%E6%89%8B/</link><pubDate>Fri, 13 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E8%A7%80%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%8D%B3%E6%99%82%E9%80%9A%E7%9F%A5%E7%9A%84%E5%A5%BD%E5%B9%AB%E6%89%8B/</guid><description>哈囉朋友們～今天我們要聊的是觀察者模式（Observer），這個模式在現實生活中非常常見，讓我們輕鬆理解並學會如何運用它！
🌟 觀察者模式是什麼？ 觀察者模式定義了物件之間一對多的依賴關係，當一個物件的狀態發生變化時，所有依賴它的物件都能立即收到通知。
就像你在追蹤 YouTuber 的頻道一樣，當他們有新影片上傳，你就會收到通知，立刻去觀看新內容。這個頻道就像被觀察的物件（Subject），而你就像是觀察者（Observer）。
🤔 什麼時候適合使用觀察者模式？ 以下情況很適合使用觀察者模式：
當你想要在物件的狀態改變時，自動通知其他相關物件。 希望實現鬆散耦合，提升系統彈性。 當系統的變更可能會影響多個物件時。 🔔 C# 觀察者模式範例：YouTube 頻道通知系統 這次我們以 YouTube 頻道訂閱通知為例，來實作觀察者模式。
📺 建立主題介面（Subject） using System.Collections.Generic; /// &amp;lt;summary&amp;gt; /// 主題介面，負責管理訂閱者 /// &amp;lt;/summary&amp;gt; public interface IChannel { /// &amp;lt;summary&amp;gt; /// 訂閱頻道 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;subscriber&amp;#34;&amp;gt;訂閱者&amp;lt;/param&amp;gt; void Subscribe(ISubscriber subscriber); /// &amp;lt;summary&amp;gt; /// 取消訂閱 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;subscriber&amp;#34;&amp;gt;訂閱者&amp;lt;/param&amp;gt; void Unsubscribe(ISubscriber subscriber); /// &amp;lt;summary&amp;gt; /// 通知所有訂閱者 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;videoTitle&amp;#34;&amp;gt;影片標題&amp;lt;/param&amp;gt; void NotifySubscribers(string videoTitle); } 🎥 具體主題類別（頻道） using System; using System.</description></item><item><title>Day 25: 【前端 #6】核心生命週期：一天搞定習慣的「增刪改查」與「打卡」</title><link>/ChiYu-Blob/posts/2025ithomeironmanday25/</link><pubDate>Sat, 13 Sep 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday25/</guid><description>安安，我是 ChiYu！
昨天，我們的 App 經歷了一次質的飛躍。我們為它植入了「靈魂」——一個中央的狀態 (state) 和一個渲染引擎 (render)。它學會了如何「思考」（管理數據）並「表達」（渲染畫面），成功地將從後端獲取的真實數據，呈現在使用者面前。
我們的 App 現在有了一個能反映真實數據的漂亮外殼。但是，它還是一個只能「讀」，不能「寫」的「展示品」。使用者還無法新增、修改或刪除這些習慣，無法真正地與 App 產生連結。
今天，我們將迎來一個內容極其豐富、極具挑戰、也極富成就感的 「濃縮實戰篇」。我們將火力全開，一天之內，搞定所有習慣的「增、刪、改、查」與「打卡」功能，讓我們的 App 真正地「動」起來，完成其核心功能的生命週期！
Part 1：前端心法：萬變不離其宗的「互動模式」 在我們開始瘋狂寫 Code 之前，讓我們先建立一個清晰的「心智模型」。今天我們要做的所有功能，無論是新增、刪除還是打卡，都將嚴格遵循我們前幾天建立的、那個優雅而強大的「數據驅動」模式。
這個模式，就是我們所有互動功能的 「黃金公式」：
使用者事件 (User Event)：使用者觸發一個動作（例如：點擊「儲存」按鈕）。 呼叫 API (Call API)：我們的 JavaScript 會捕捉到這個事件，然後呼叫對應的 api.js 函式，向後端發送一個請求（POST, DELETE, PUT&amp;hellip;）。 更新狀態 (Update State)：在成功收到後端的回應後，我們不去手動修改畫面，而是去更新我們中央的 state 物件。 自動渲染 (Auto Re-render)：setState 函式會自動觸發 render()，我們的 UI 就會像鏡子一樣，自動、精準地反映出 state 的最新樣貌。 記住這個公式，你會發現，再複雜的互動，都能被拆解成這幾個簡單、可預測的步驟。
Part 2：Vibe Coding 實戰 (上)：擴充我們的「通訊模組」 我們的 api.js 現在只會「讀取」(fetchHabits)，是時候教它「寫入」了。
【魔法詠唱：升級通訊模組】 讓我們進入 gemini chat 模式，指揮 AI 為我們擴充 api.js。
# 角色 (Role) 你是一位資深的 API 用戶端架構師 (API Client Architect)，精通 `fetch` API 與 `async/await`，並致力於遵循 DRY (Don&amp;#39;t Repeat Yourself) 原則，撰寫可複用、可擴展且易於維護的數據獲取模組。 # 目標 (Objective) 請對現有的 `@frontend/api.</description></item><item><title>狀態模式：依狀態改變行為的祕訣</title><link>/ChiYu-Blob/posts/%E7%8B%80%E6%85%8B%E6%A8%A1%E5%BC%8F%E4%BE%9D%E7%8B%80%E6%85%8B%E6%94%B9%E8%AE%8A%E8%A1%8C%E7%82%BA%E7%9A%84%E7%A5%95%E8%A8%A3/</link><pubDate>Fri, 13 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E7%8B%80%E6%85%8B%E6%A8%A1%E5%BC%8F%E4%BE%9D%E7%8B%80%E6%85%8B%E6%94%B9%E8%AE%8A%E8%A1%8C%E7%82%BA%E7%9A%84%E7%A5%95%E8%A8%A3/</guid><description>哈囉朋友們～今天我們要聊的是非常實用且有趣的狀態模式（State），這個模式讓你的物件能夠根據內部狀態的變化而自動改變行為。
🌟 狀態模式是什麼？ 狀態模式允許一個物件在內部狀態改變時改變它的行為，就像換了一個角色一樣。
舉個實際例子，就像是手機的鈴聲狀態，手機在「靜音」模式時，不會響鈴；切換到「響鈴」模式後，就會有聲音通知你。這就是狀態模式的基本概念，透過改變狀態讓物件呈現不同的行為。
🤔 什麼時候適合使用狀態模式？ 以下情況很適合使用狀態模式：
物件的行為會根據內部狀態不同而有所改變。 當有大量條件判斷，且這些條件判斷取決於物件的狀態時。 希望避免使用大量的條件語句（if-else或switch），讓程式更清晰、更易於維護。 📱 C# 狀態模式範例：手機鈴聲模式 我們以手機鈴聲模式為範例來示範狀態模式。
🔕 定義狀態介面 /// &amp;lt;summary&amp;gt; /// 狀態介面 /// &amp;lt;/summary&amp;gt; public interface IMobileState { /// &amp;lt;summary&amp;gt; /// 依目前狀態執行提醒 /// &amp;lt;/summary&amp;gt; void Alert(); } 📳 建立具體狀態類別 using System; /// &amp;lt;summary&amp;gt; /// 響鈴模式 /// &amp;lt;/summary&amp;gt; public class RingingState : IMobileState { /// &amp;lt;inheritdoc /&amp;gt; public void Alert() { Console.WriteLine(&amp;#34;手機正在響鈴...&amp;#34;); } } /// &amp;lt;summary&amp;gt; /// 靜音模式 /// &amp;lt;/summary&amp;gt; public class SilentState : IMobileState { /// &amp;lt;inheritdoc /&amp;gt; public void Alert() { Console.</description></item><item><title>Day 26: 【前端 #7】用戶體驗的最後一哩路：優雅地處理載入與錯誤</title><link>/ChiYu-Blob/posts/2025ithomeironmanday26/</link><pubDate>Sun, 14 Sep 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday26/</guid><description>安安，我是 ChiYu！
昨天，我們的 App 經歷了一次完全體的進化！我們在一天之內，火力全開，搞定了核心的 CRUD 功能。我們的 App 不僅能思考、能表達，現在更擁有了完整的 行動能力。
但是，一個專業的產品，不只需要考慮「成功」的情境，更需要優雅地處理「等待」與「失敗」。想像一下，你點擊「儲存」後，如果因為網路不好，畫面卡住不動長達五秒，你會不會以為 App 當機了，然後狂點好幾次？如果伺服器剛好在維護，畫面直接崩潰，你是不是會立刻對這個 App 失去信心？一個沉默的 App 是一個「無禮」的 App，它不尊重使用者的時間和情緒。
今天，我們就要來補上這至關重要的用戶體驗最後一哩路。我們將扮演一位「用戶體驗工程師」，為我們的 App 注入「同理心」，教它如何與使用者溝通，優雅地處理「載入中」和「錯誤」狀態，讓它從一個「能用」的產品，進化成一個 「好用」 且 **「貼心」**的產品！
Part 1：前端心法：從「單一路徑」到「UI 狀態機」 一個業餘的 App 只會為「成功」而設計，也就是我們常說的「快樂路徑 (Happy Path)」。但一個專業的 App，會將每一次互動都視為一個 「狀態機 (State Machine)」。這意味著，我們的 UI 介面，在任何時刻，都只會處於一個明確、可預測的狀態中。
對於資料獲取這個常見的場景，一個最基本的狀態機至少包含以下幾個狀態：
閒置狀態 (Idle)：互動發生前的初始狀態。 等待狀態 (Loading)：從使用者點擊，到後端伺服器回應之前的這段時間。這是最容易被忽略，卻也最影響使用者感受的環節。一個好的 App 會在這時給出明確的回饋（例如轉圈動畫），告訴使用者：「我知道了，正在處理中，請稍候」，而不是讓使用者在原地焦慮地猜測。 成功狀態 (Success)：我們昨天做的所有功能，都屬於這個狀態。 錯誤狀態 (Error)：當網路中斷、伺服器出錯時，就會進入這個狀態。一個好的 App 會給出清晰、友善的錯誤提示，引導使用者解決問題，而不是直接崩潰或顯示一堆看不懂的程式碼。 我們可以將這個流程視覺化：
graph TD A(閒置 Idle) --&amp;gt;|使用者操作| B(載入中 Loading); B --&amp;gt; C(成功 Success); B --&amp;gt; D(錯誤 Error); C --&amp;gt; A; D --&amp;gt; A; 我們今天的目標，就是要讓我們的「狀態中心 (State)」能夠完整地描述這個狀態機，並讓我們的「渲染引擎 (Render Function)」能夠忠實地將每一個狀態呈現出來。</description></item><item><title>策略模式：靈活切換行為的好幫手</title><link>/ChiYu-Blob/posts/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E9%9D%88%E6%B4%BB%E5%88%87%E6%8F%9B%E8%A1%8C%E7%82%BA%E7%9A%84%E5%A5%BD%E5%B9%AB%E6%89%8B/</link><pubDate>Fri, 13 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E9%9D%88%E6%B4%BB%E5%88%87%E6%8F%9B%E8%A1%8C%E7%82%BA%E7%9A%84%E5%A5%BD%E5%B9%AB%E6%89%8B/</guid><description>哈囉朋友們～今天我們要介紹的設計模式是非常靈活好用的策略模式（Strategy），透過它，你可以輕鬆替換不同的行為，讓你的程式更有彈性！
🌟 策略模式是什麼？ 策略模式允許你定義一系列的演算法，並讓這些演算法可以互相替換，且獨立於使用它們的客戶端。
想像一下，你去旅行時可以選擇不同的交通方式，比如搭飛機、搭高鐵或開車。你根據不同的需求（時間、成本、舒適度）選擇不同的策略，這就是策略模式的核心概念！
🤔 什麼情況適合使用策略模式？ 以下情況很適合使用策略模式：
需要動態地切換不同的演算法或行為。 想避免使用大量的條件判斷語句（if-else 或 switch）。 希望使系統容易擴充，能輕鬆增加新的演算法或行為。 🚗 C# 策略模式範例：旅遊交通工具選擇 這次我們以旅遊時選擇交通工具作為範例。
🚅 定義策略介面 /// &amp;lt;summary&amp;gt; /// 交通策略介面 /// &amp;lt;/summary&amp;gt; public interface ITravelStrategy { /// &amp;lt;summary&amp;gt; /// 前往指定目的地 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;destination&amp;#34;&amp;gt;目的地&amp;lt;/param&amp;gt; void Travel(string destination); } ✈️ 建立具體策略類別 using System; /// &amp;lt;summary&amp;gt; /// 飛機策略 /// &amp;lt;/summary&amp;gt; public class PlaneStrategy : ITravelStrategy { public void Travel(string destination) { Console.WriteLine($&amp;#34;搭飛機前往 {destination}&amp;#34;); } } /// &amp;lt;summary&amp;gt; /// 高鐵策略 /// &amp;lt;/summary&amp;gt; public class HighSpeedRailStrategy : ITravelStrategy { public void Travel(string destination) { Console.</description></item><item><title>Day 27: 【文件 #8】數據的畫布：用 Gemini 設計「圖表元件規格書」</title><link>/ChiYu-Blob/posts/2025ithomeironmanday27/</link><pubDate>Mon, 15 Sep 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday27/</guid><description>安安，我是 ChiYu！
昨天，我們的 App 學會了「同理心」，能夠優雅地處理載入與錯誤，大幅提升了使用者體驗。至此，我們 App 的基礎建設與核心互動功能，都已相當完備。
現在，是時候兌現我們在《專案章程》中許下的最終承諾，實現我們 App 的核心價值主張了——「關聯性洞察」。
但是，圖表功能的開發，遠比一個簡單的按鈕要複雜得多。它涉及到數據的獲取、處理、整合與視覺化，稍有不慎，就可能陷入混亂。因此，在我們一頭熱地栽進去 Vibe Coding 之前，我們要重拾我們最强大的武器，再次回到 **「文件驅動開發 (DDD)」**的懷抱。
今天，我們將回頭重新設計文件，對於較為複雜的功能，為了避免AI天馬行空脫韁，還是建議回頭重新設計一份完整詳細的規格文件！我們將扮演一位「數據產品設計師」，與 Gemini 一同腦力激盪，為這個最複雜的功能，撰寫一份清晰、專業的**「圖表元件規格書」**。
Part 1：前端心法：為什麼複雜的功能更需要「文件先行」？ 你可能會問：「我們不是已經有《使用者故事》了嗎？為什麼還要再寫一份文件？」
問得好！《使用者故事》告訴我們使用者想要 什麼 (What)，但它並沒有告訴我們技術上該 如何實現 (How)。對於一個簡單的按鈕，這兩者之間的差距很小。但對於一個圖表元件，這個差距就非常巨大了：
數據契約 (Data Contract)：這個圖表元件，到底需要從外部接收什麼格式的數據才能運作？是兩個獨立的陣列，還是一個合併過的物件陣列？ 互動行為 (Interaction Behavior)：使用者與圖表的互動有哪些？滑鼠移上去要顯示什麼？點擊圖例 (Legend) 會發生什麼事？ 邊界情況 (Edge Cases)：如果沒有數據，圖表該顯示什麼？如果數據只有一天，又該如何呈現？ 在動手寫 Code 前，先把這些問題用一份 **「技術規格書」**定義清楚，就像是在畫一張精密的「零件設計圖」。有了這張圖，我們接下來的 Vibe Coding 才能精準、高效，而不是一邊寫一邊猜。
Part 2：Vibe Coding 實戰：撰寫我們的「零件設計圖」 好了，理論武裝完畢！讓我們進入 gemini chat 模式，指揮 AI 為我們撰寫這份至關重要的規格書。
【魔法詠唱：設計圖表規格】 # 角色 (Role) 你是一位頂尖的數據產品設計師與資深前端架構師，精通數據視覺化、元件化開發與無障礙網頁設計 (a11y)。你最擅長的工作是將高階的商業需求，轉化為一份清晰、穩固、可執行、且具備卓越使用者體驗的前端元件技術規格書。 # 目標 (Objective) 請根據我提供的專案上下文，為我們的核心功能「關聯性洞察圖表」，設計一份專業、完整、且可直接交付給開發者執行的**「圖表元件技術規格書 (Chart Component Technical Specification)」**。這份文件將成為該元件開發的唯一真理來源。 # 上下文與關鍵資訊 (Context &amp;amp; Key Information) * **核心價值主張**: 我們的 App 旨在「揭示個人行為與內在感受之間的微妙聯繫」(`@docs/PROJECT_CHARTER.</description></item><item><title>模板方法模式：固定流程靈活實作</title><link>/ChiYu-Blob/posts/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%9B%BA%E5%AE%9A%E6%B5%81%E7%A8%8B%E9%9D%88%E6%B4%BB%E5%AF%A6%E4%BD%9C/</link><pubDate>Fri, 13 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%9B%BA%E5%AE%9A%E6%B5%81%E7%A8%8B%E9%9D%88%E6%B4%BB%E5%AF%A6%E4%BD%9C/</guid><description>哈囉朋友們～今天我們要介紹的是非常實用且常見的模板方法模式（Template Method），透過它你可以固定一系列的步驟，讓子類別靈活地去實現細節。
🌟 模板方法模式是什麼？ 模板方法模式定義了一個演算法的骨架，並將一些步驟延遲到子類別去實現。這樣的設計可以確保演算法的結構保持一致，但又能靈活地調整細節。
例如，你在製作各種口味的披薩時，無論是海鮮披薩還是夏威夷披薩，都有一個基本的製作步驟（揉麵團、加醬料、放餡料、烤披薩）。模板方法模式就是把這個固定步驟封裝起來，讓子類別專注於實現每個細節。
🤔 什麼時候適合使用模板方法模式？ 以下情況很適合使用模板方法模式：
當你有一系列步驟，但每個步驟的具體實現可能會有所不同。 想確保演算法的結構不被子類別改變，保證流程的統一性。 希望提供一個明確的框架，讓開發者能快速實現不同的具體步驟。 🍕 C# 模板方法模式範例：披薩製作流程 這次我們以製作披薩的流程作為範例。
🍅 建立抽象類別 using System; /// &amp;lt;summary&amp;gt; /// 披薩製作抽象類別 /// &amp;lt;/summary&amp;gt; public abstract class PizzaMaker { /// &amp;lt;summary&amp;gt; /// 製作披薩的流程 /// &amp;lt;/summary&amp;gt; public void MakePizza() { PrepareDough(); AddSauce(); AddToppings(); BakePizza(); } /// &amp;lt;summary&amp;gt; /// 準備麵團 /// &amp;lt;/summary&amp;gt; protected void PrepareDough() { Console.WriteLine(&amp;#34;揉製麵團...&amp;#34;); } /// &amp;lt;summary&amp;gt; /// 加入醬料 /// &amp;lt;/summary&amp;gt; protected void AddSauce() { Console.WriteLine(&amp;#34;加入醬料...&amp;#34;); } /// &amp;lt;summary&amp;gt; /// 加入配料，由子類別實作 /// &amp;lt;/summary&amp;gt; protected abstract void AddToppings(); /// &amp;lt;summary&amp;gt; /// 烘烤披薩 /// &amp;lt;/summary&amp;gt; protected void BakePizza() { Console.</description></item><item><title>Day 28: 【前端 #8】兌現承諾：根據規格書 Vibe Coding 關聯性洞察圖表</title><link>/ChiYu-Blob/posts/2025ithomeironmanday28/</link><pubDate>Tue, 16 Sep 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday28/</guid><description>安安，我是 ChiYu！
昨天，我們再次實踐了「文件驅動開發」的核心精神。我們沒有直接衝進複雜的圖表程式碼中，而是先退一步，將一個模糊的「想法」，轉化為了一份清晰、具體、可執行的「技術規格」。
我們手上現在握著一份像素級精密的「零件設計圖」。有了它，我們接下來的開發工作將會變得無比順暢，因為所有關於「如何設計」的燒腦問題，都已經被解決了。我們的任務只剩下一個——專注於「如何實現」。
今天，我們將正式拿起工具，嚴格依據昨天的這份《圖表元件規格書》，指揮 AI 和 Chart.js，將這幅數據的畫布，變成真實、可互動的前端程式碼！
Part 1：前端心法：為什麼專業團隊痴迷於「規格書」？ 在開始之前，讓我們再次鞏固一下心法。為什麼像我們昨天產出的那份規格書，在專業團隊中如此重要？
消除模糊地帶：規格書用技術語言，將所有「可能」、「大概」、「我覺得」都變成了「必須」。前端工程師不再需要去猜測產品經理的心思，所有人都對著同一份文件工作。 實現並行開發：有了這份規格書，前端和後端甚至可以同時開工！後端工程師知道要提供什麼格式的 API，前端工程師知道要接收什麼格式的數據，雙方可以獨立開發，最後完美對接。 Vibe Coding 的「護欄」：這對我們至關重要。當我們指揮 AI 時，這份規格書就是最強大的「護欄」。我們可以非常精準地告訴 AI：「嘿，嚴格按照這份文件的 Props 定義來接收數據，嚴格按照這份文件的『互動行為』來寫 JS 邏輯。」這能確保 AI 的強大創造力，永遠在我們設定好的軌道上馳騁。 Part 2：Vibe Coding 實戰：將藍圖轉化為現實 好了，理論不再贅述，讓我們進入 gemini chat 模式，開始我們今天精彩的 Vibe Coding 之旅！
Step 1: 安裝我們的「畫筆」- Chart.js 首先，我們要為專案引入一個強大且易用的圖表函式庫。
【魔法詠唱：引入 Chart.js】 # 角色 你是一位熟悉前端生態系的前端工程師。 **# 任務** 請修改 `@frontend/index.html`，為專案引入 Chart.js 函式庫。 **# 產出要求** 請在 `&amp;lt;head&amp;gt;` 區塊中，加入 Chart.js 的 CDN 連結。請使用最新穩定版本。 AI 會為我們找到 Chart.js 的 CDN，並將 &amp;lt;script&amp;gt; 標籤加入到我們的 HTML 中。</description></item><item><title>訪問者模式：新增功能不動既有架構</title><link>/ChiYu-Blob/posts/%E8%A8%AA%E5%95%8F%E8%80%85%E6%A8%A1%E5%BC%8F%E6%96%B0%E5%A2%9E%E5%8A%9F%E8%83%BD%E4%B8%8D%E5%8B%95%E6%97%A2%E6%9C%89%E6%9E%B6%E6%A7%8B/</link><pubDate>Fri, 13 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E8%A8%AA%E5%95%8F%E8%80%85%E6%A8%A1%E5%BC%8F%E6%96%B0%E5%A2%9E%E5%8A%9F%E8%83%BD%E4%B8%8D%E5%8B%95%E6%97%A2%E6%9C%89%E6%9E%B6%E6%A7%8B/</guid><description>哈囉朋友們～今天要介紹的是比較特殊但十分強大的訪問者模式（Visitor），透過這個模式，你可以在不修改物件結構的情況下輕鬆新增功能！
🌟 訪問者模式是什麼？ 訪問者模式允許你在不改變現有類別結構的情況下，為類別增加新的操作。
舉個例子，就像遊樂園的各種設施，每個訪客來到遊樂園會玩不同的設施。設施本身不會改變，但每位訪客的行為和感受可能不同，訪客們就是訪問者（Visitor），設施則是被訪問的元素（Element）。
🤔 什麼情況適合使用訪問者模式？ 以下情況很適合使用訪問者模式：
當你需要對一個物件結構新增許多不同且不相關的操作。 希望在不修改現有結構的情況下，能輕鬆增加新功能。 當物件結構相對穩定，但操作或功能可能經常變動時。 🎢 C# 訪問者模式範例：遊樂園設施與訪客 這次我們以遊樂園的訪客與設施為例。
🎠 定義元素介面（設施） /// &amp;lt;summary&amp;gt; /// 設施介面 /// &amp;lt;/summary&amp;gt; public interface IAmusementFacility { /// &amp;lt;summary&amp;gt; /// 接受訪問者 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;visitor&amp;#34;&amp;gt;訪問者&amp;lt;/param&amp;gt; void Accept(IVisitor visitor); } 🎡 具體設施類別 /// &amp;lt;summary&amp;gt; /// 雲霄飛車 /// &amp;lt;/summary&amp;gt; public class RollerCoaster : IAmusementFacility { public void Accept(IVisitor visitor) { visitor.Visit(this); } } /// &amp;lt;summary&amp;gt; /// 摩天輪 /// &amp;lt;/summary&amp;gt; public class FerrisWheel : IAmusementFacility { public void Accept(IVisitor visitor) { visitor.</description></item><item><title>Day 29: 【文件 #9】專案的守衛：用 Gemini 規劃「前端認證流程」</title><link>/ChiYu-Blob/posts/2025ithomeironmanday29/</link><pubDate>Wed, 17 Sep 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday29/</guid><description>安安，我是 ChiYu！
昨天，我們成功地兌現了對使用者的最終承諾，將冰冷的數據轉化為了富有情感的、能啟發洞察的視覺化故事。我們的 App 核心價值已然確立。
但是，我們的 App 現在還像是一個 沒有門鎖的豪宅。雖然內部裝潢精美、功能強大，但任何人都可以隨意進出，這對於一個旨在儲存使用者私密心情與習慣數據的應用來說，是絕對不可接受的。
使用者認證 (Authentication) 流程，是任何嚴肅 Web 應用的基石。它複雜、涉及安全性、且牽一髮而動全身。因此，我們 絕對不能憑感覺去寫！
今天，我們將進行第二個前端的 DDD 循環！我們將扮演一位「資安架構師」，與 Gemini 一同腦力激盪，為這個最關鍵的功能，撰寫一份清晰、專業的**「前端認證流程規格書」**。
Part 1：前端心法：在寫 Code 前，先成為半個資安專家 在我們觸碰任何跟認證相關的程式碼之前，我們必須先在腦中建立起清晰的資安模型。這不僅僅是「使用者體驗」的問題，更是「使用者信任」的基石。
1.1 核心觀念：認證 (Authentication) vs. 授權 (Authorization) 首先，要釐清兩個最常被搞混的概念：
認證 (Authentication - 你是誰？)：這個過程是在 驗證你的身份。就像你進入一棟大樓，需要出示你的身份證或門禁卡，向保全證明「我就是住戶 ChiYu」。 登入這個動作，就是最典型的認證。 授權 (Authorization - 你能做什麼？)：這個過程是在你 通過認證後， 決定你有哪些權限。保全確認了你是 ChiYu 後，他還需要知道，你的門禁卡只能打開你家的門，不能打開別人家或頂樓機房的門。在 App 中，這可能意味著普通使用者只能讀取自己的資料，而管理員 (Admin) 則可以讀取所有人的資料。 1.2 現代 Web 的通行證：JWT (JSON Web Token) 在現代 Web App 中，我們如何實現無狀態 (Stateless) 的認證呢？答案就是 JWT。
你可以把 JWT 想像成一張 蓋了章的「數位通行證」。當你用帳號密碼成功登入後，伺服器會發給你一張 JWT。這張通行證本身包含了一些資訊（例如你是誰、你的權限是什麼），並且經過伺服器的 數位簽章，確保它沒有被偽造。</description></item><item><title>開發日誌 #1：我把『人生』變成了一款可以練功打寶的RPG！</title><link>/ChiYu-Blob/posts/hlr-devlog-1/</link><pubDate>Thu, 03 Jul 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/hlr-devlog-1/</guid><description>大家好！我是 ChiYu，很高興你正在看「習慣人生RPG」(Habit-Life RPG / H.L.R.) 的第一篇開發日誌！
先問大家一個問題：你是不是也一樣，手機裡裝了一堆待辦事項App，結果最後都懶得打開？看著那些永遠劃不完的清單，只覺得煩，完全沒有動力。
但奇怪的是，我們轉頭就能在遊戲裡，為了升1%經驗值、刷一件更好的裝備，熬夜奮戰好幾個小時。
這讓我一直在想，如果…只是如果…做正事也能像玩遊戲一樣爽，那該有多好？
這個念頭，就是「習慣人生RPG」的起點。這不只是一個App，更像是我傾注所有熱情，想實現的一個夢想：把無聊的現實生活，變成一場刺激又好玩的冒險！
所以，這到底是一款怎樣的App？ 簡單來說，你就是你自己人生的主角！你在H.L.R.中會創建一個代表你的像素小英雄，接著，你在現實中做的每一件事，都會直接影響他在遊戲裡的成長。
把鳥事變任務，把努力變獎勵！
「每日運動30分鐘」？ 這不是待辦事項，這是「體能訓練」每日任務，完成就給你滿滿的經驗值 (EXP) 和金幣！ 「交一份專案報告」？ 這不是工作，這是一次性的「史詩任務」，解完直接噴裝備！ 想戒掉宵夜？ 沒問題！把它設成你的「習慣挑戰」，只要忍住，角色就會變強；但要是破戒了…嘿嘿，角色的HP可是會下降的喔！ 打造你專屬的英雄！ 升級拿到的點數，你可以自由點在「力量」、「智力」、「敏捷」上。想當個頭好壯壯的戰士，還是聰明絕頂的法師？都由你決定！這些屬性還會強化你對應的技能，讓你在養成相關習慣時事半功倍。
獨創「BOSS戰」系統，把大目標變成超燃的副本！ 這絕對是H.L.R.的靈魂！我們誰沒有過那種超遠大的目標？像是**「多益成績要拚到金色證書」、「日文檢定要過N2」，或是「拿到那張夢寐以求的AWS雲端證照」**。
這些目標超大、超可怕，就像遊戲裡打不倒的最終BOSS。但在H.L.R.裡，你可以把它們真的變成一隻隻血條超厚的**「認證型BOSS」**！
準備多益？那「背完100個單字」就是一次普攻，「做完一回模擬測驗」就是一記強力技能，直接削掉BOSS一大格血！你會親眼看著BOSS的血條在你每天的努力下不斷減少，直到你考到證照的那天，就是你帥氣地吼出「阿搭啦！」然後擊敗BOSS的時刻！
不讓你孤單的夥伴們 冒險的路上怎麼能沒有夥伴？你可以和現實中的朋友、家人組成「公會」或「家庭」，一起挑戰公會專屬的BOSS，互相打氣。當然，還有你的AI智慧小夥伴「亞當/夏娃」，他會在你身邊給你貼心的提醒和建議。
這所有的一切，都發生在一個可愛又懷舊的像素世界裡。
接下來的計畫？ 這款App是我用愛發電的熱情專案。目前，我正全力打磨核心的任務系統，確保整個「努力-回饋」的循環玩起來是真的有趣、真的有感。同時，我也在準備「菁英大師」訂閱方案的相關功能，希望能給深度使用者帶來更多驚喜。
不久後，我們預計會展開第一輪小規模的封閉測試。
如果你也對這個「把人生變遊戲」的瘋狂計畫有興趣，想成為第一批進入這個世界的勇者，或者單純想看一個夢想是如何被一行行程式碼實現的，歡迎你繼續追蹤這個部落格。
感謝你讀完這篇日誌。我們的冒險，現在才正要開始呢！</description></item><item><title>Day 30: 【前端 #9】建立大門與鑰匙：根據流程圖實現前端使用者認證</title><link>/ChiYu-Blob/posts/2025ithomeironmanday30/</link><pubDate>Thu, 18 Sep 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday30/</guid><description>說在前頭！！！ 有些部分多花費了些時間在講，所以雖然今天已經滿30天了， 但我還沒有正式完成這次鐵人賽系列文！！！ 我後面還是會繼續更新到正式完結。畢竟還是要有頭有尾有始有終！
以下正文開始！ 安安，我是 ChiYu！
昨天，我們為 App 的安全性，打下了最堅實的理論基礎。我們沒有憑感覺去處理這個複雜的流程，而是再次透過 「文件驅動」，將所有可能的路徑與邏輯，都預先規劃得一清二楚。
我們手上現在握著一份精密的「安全白皮書」。有了它，我們接下來的開發工作將會變得無比順暢，因為所有關於「如何設計」的燒腦問題，都已經被解決了。我們的任務只剩下一個—— 專注於「如何實現」。
今天，我們將迎來前端整合的最終章！我們將 嚴格依據昨天的這份流程圖，指揮 AI，將這套堅不可摧的認證系統，變成真實、可運行的前端程式碼，為我們的 App 裝上大門與門鎖！
Part 1：前端心法：為我們的單頁應用模擬「多個頁面」 在開始之前，我們需要先解決一個結構性問題。我們的 App 目前是一個嚴格意義上的「單頁應用」——所有的 UI 都在同一個 index.html 裡。但現在，我們需要一個獨立的「登入/註冊」頁面。
在不引入複雜前端框架的情況下，最聰明、最簡單的作法，就是 「用 &amp;lt;div&amp;gt; 模擬頁面」。
我們的策略是：
將我們現有的主應用程式介面，用一個 &amp;lt;div id=&amp;quot;app-page&amp;quot;&amp;gt; 包起來。 再建立一個新的 &amp;lt;div id=&amp;quot;auth-page&amp;quot;&amp;gt;，用來放置登入和註冊的表單。 這兩個 &amp;lt;div&amp;gt; 永遠只會有一個顯示在畫面上。 我們將用 JavaScript 來控制，根據使用者的登入狀態，決定要顯示哪一個「頁面」。 這是一個輕量級且高效的前端路由 (Routing) 模擬方法。
Part 2：Vibe Coding 實戰：詠唱「認證系統創生」的超級咒語 好了，作戰計畫擬定，讓我們進入 gemini chat 模式，用一個全面的「超級 Prompt」，指揮 AI 為我們完成這次複雜的手術。
【魔法詠唱：注入認證靈魂】 # 角色 (Role) 你是一位頂尖的資安前端架構師 (Principal Frontend Engineer &amp;amp; Security Advocate)，精通 JWT 認證機制、狀態管理、API 客戶端設計與單頁應用程式 (SPA) 的路由管理。你擅長將複雜的認證規格，轉化為一個安全、穩固、可擴展且具備卓越使用者體驗的完整前端架構。 # 目標 (Objective) 請**嚴格依據**《前端認證架構藍圖》，對我現有的前端專案進行一次全面的**架構性重構與功能實作**，為其注入一個完整的「使用者認證」系統。 # 上下文與關鍵資訊 (Context &amp;amp; Key Information) * **唯一真理來源**: `@docs/AUTH_FLOW.</description></item><item><title>Day 31: 【優化篇】代碼的整形外科：JavaScript 模組化與代碼重構</title><link>/ChiYu-Blob/posts/2025ithomeironmanday31/</link><pubDate>Fri, 19 Sep 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday31/</guid><description>說在前頭～ 既然已經達成30天了，乾脆把庫存一次全部PO完好了～
安安，我是 ChiYu！
昨天，我們為 App 裝上了堅固的大門與門鎖，成功地實現了完整的使用者認證流程。至此，我們 MVP (最小可行產品) 的所有核心功能，已全部開發完成！這是一個巨大的里程碑，再次為堅持到這裡的你，獻上最熱烈的掌聲！
但是，我們的旅程還沒結束。一個專業的專案，不僅僅是功能的堆砌。回頭看看我們的 frontend/script.js 檔案，它現在已經變成一個包含了狀態管理、UI 渲染、API 請求、認證邏輯、事件監聽&amp;hellip; 的巨大怪獸。它雖然能跑，但已經變得難以閱讀和維護。
今天，我們將進行系列文的最後一次程式碼實作，也是從「開發者」邁向「架構師」的關鍵一步。我們將扮演一位「程式碼整形醫師」，為我們臃腫的 script.js 進行一次徹底的「整形手術」，引入專業的 JavaScript 模組化，讓我們的專案達到生產級別的清晰度。
Part 1：前端心法：為什麼說「高內聚，低耦合」是程式碼的最高境界？ 在我們動刀之前，先來理解一下我們手術的指導原則—— 「高內聚，低耦合 (High Cohesion, Low Coupling)」。這聽起來很玄，但卻是衡量所有軟體架構好壞的黃金標準。
高內聚 (High Cohesion)：就像一個專業的「工具箱」。一個好的工具箱裡，所有放鑿子的抽屜裡，只會有各式各樣的鑿子；放螺絲起子的抽屜裡，只會有螺絲起子。 相關的功能，應該被集中在同一個模組裡。 低耦合 (Low Coupling)：代表工具箱裡的每個抽屜，都是獨立的。你拿出鑿子抽屜時，完全不需要擔心會動到螺絲起子的抽屜。 模組與模組之間，應該盡量減少依賴，保持獨立。 我們現在的 script.js，就是一個典型的「低內聚、高耦合」的壞例子：它什麼都做（低內聚），而且裡面所有功能都互相糾纏在一起（高耦合）。
而我們的解決方案，就是使用現代 JavaScript 內建的 ES6 Module (import/export)。它能讓我們像整理工具箱一樣，將不同功能的程式碼，放進各自專屬的 .js 檔案中，然後在需要的時候，精準地「進口 (import)」我們需要的工具即可。
Part 2：Vibe Coding 實戰：詠唱「程式碼重構」的終極咒語 好了，理論武裝完畢！讓我們進入 gemini chat 模式，開始這場重構手術。
【重構後的專案結構】 frontend/ ├── assets/ │ └── logo.png ├── api.js # 只負責跟後端說話 ├── auth.js # 只負責登入登出 ├── state.</description></item><item><title>【完賽感言】左手藍圖，右手魔法：一趟旅程的結束與反思</title><link>/ChiYu-Blob/posts/2025ithomeironmanday32/</link><pubDate>Sat, 20 Sep 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/2025ithomeironmanday32/</guid><description>安安！我是 ChiYu！
三十天竟然就這樣過去了耶！回想一開始，真的只有一個超模糊的想法，就憑著一股傻勁跟對 AI 的好奇心與信任，直接衝了，開始了這趟「左手藍圖，右手魔法」的冒險。今天，我們總算成功達陣啦！
說真的，我必須要跟每一個從 Day 1 就有在看文章的夥伴，說聲「感謝！」，也謝謝身旁好友們天天提醒我發文，不要像去年一樣中斷文章。也真心恭喜大家！雖然點閱數不敢說多少，但有人看就讓我很感激了。
OK！最後一天不寫 code，放輕鬆。咱們來幹最後一件，也是最重要的一件事：好好來回顧一下這趟旅程，看看我們到底搞了些什麼。
Part 1：我們的協奏曲：從「空想」到「成品」的過程 這趟旅程，就像一首超 high 的五樂章協奏曲：
第一樂章：蹲馬步！(心法與基礎) 一開始，我們沒急著寫 code。反而是先坐下來，把內功練好。我們確立了「文件驅動開發」的遊戲規則，並學會了用 Git 這台「時光機」。
第二樂章：畫地圖！(前後端大規劃) 我們產出了從《專案章程》到《API 規格書》的全套藍圖，把地基打得超穩。
第三樂章：開秀啦！(AI 高速開發) 地圖畫好了，換「右手」上場施展魔法！我們指揮 AI 把後端的伺服器、資料庫模型，以及前端的網頁介面、按鈕互動通通變出來。
第四樂章：求個穩！(品質與體驗) 我們請來了 GitHub Actions 作為自動化「品管大師」，跑自動化測試。同時也幫我們的 App 裝上「同理心」，優雅處理非同步與錯誤狀態。
第五樂章：收尾！(打磨與升級) 最後，我們像個「程式碼醫生」，把 code 整理得乾乾淨淨（模組化），讓它以後更好照顧。
Part 2：聊聊這套方法：「左手藍圖，右手魔法」的好與壞 「好」：我們賺到了什麼？ 心裡超有底 (Certainty)：先寫文件讓我們在動手前就想清楚了變化，實作時方向感超明確。 又快又好 (Velocity &amp;amp; Quality)：規劃就像是給 AI 這匹脫韁野馬裝上了「護欄」，確保產出品質。 一份「活歷史」 (A Living History)：docs 資料夾記錄了專案從 0 到 1 的完整心路歷程。 「壞」：有什麼地方可以做得更好？ 測試可以玩得更 hardcore：下次可以嘗試結合 DDD 與 TDD，先讓 AI 根據規格書寫測試，再寫程式碼。 文件與文章的扣合：如果能更細緻地解釋文件中每一句話如何影響後面的 code， DDD 的威力會更鮮明。 Part 3：AI 時代，我們人類開發者還能幹嘛？ AI 是超強的副駕駛，但方向盤永遠握在我們手上。我們的價值在於：</description></item><item><title>【開發雜談】Vibe Coding 2.0：從文件驅動 (DDD) 進化到規格驅動 (SDD)，讓 AI 真正為你所用</title><link>/ChiYu-Blob/posts/vibe-coding-2-0-sdd/</link><pubDate>Mon, 29 Dec 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/vibe-coding-2-0-sdd/</guid><description>Hi 大家好，我是 ChiYu！
最近在社群和鐵人賽裡，我們聊了很多關於 Vibe Coding 的話題。那種「指尖在鍵盤上飛舞，AI 像讀心術一樣把程式碼一行行噴出來」的感覺，確實很容易讓人上癮，對吧？
但身為一個在代碼海裡打滾多年的資深工程師，我相信你在激情過後，一定也遇過這種「賢者時間」： 看著 AI 幫你寫出來的那幾千行程式碼，雖然能跑，但結構鬆散、變數命名隨意，甚至埋了一些你現在看不出來、但下個月會讓你加班到天亮的 Bug。
我們之前談過 DDD (Document Driven Development，文件驅動開發)，強調「先有文件，才有 Code」，這是我們馴服 AI 的第一步。但今天，我要帶大家進入更深一層的領域。
如果說 DDD 是我們跟 AI 簽訂的「君子協定」，那麼今天要介紹的 SDD (Spec Driven Development，規格驅動開發)，就是把協定升級成「法律條文」。
準備好了嗎？我們來聊聊，為什麼你需要 SDD。
一、 回顧 DDD：我們為什麼要「左移」？ 在進入新世界前，我們不能忘本。DDD 的核心價值在於 Shift-Left (左移)。
傳統的開發模式（或者是失控的 Vibe Coding），往往是「右移」的：
有一個模糊的想法。 直接開始寫 Code (或是叫 Copilot 寫)。 發現邏輯不通。 打掉重練 (Refactor)。 這個「打掉重練」的成本是巨大的。DDD 告訴我們：「在寫 Code 之前，先用自然語言把邏輯理清楚。」
在文字階段（Document）修改邏輯，成本趨近於零；但在程式碼階段（Code）修改邏輯，成本是指數級上升。所以我們寫文件，我們建立 SSoT (Single Source of Truth，單一真理來源)，讓 AI 有所依據。
但是，DDD 還有一個致命的弱點。
那就是 「文件與程式碼的同步性 (Sync Rot)」。 人是懶惰的，AI 是被動的。當專案趕上線的時候，你改了 Code 修 Bug，卻往往忘了回頭去改文件。久而久之，文件變成了「僅供參考」的歷史遺跡，AI 讀了過期的文件，寫出了過期的 Code。</description></item><item><title>我是如何使用 AI (Codex) 打造這個 Hugo 部落格的</title><link>/ChiYu-Blob/posts/%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-ai-codex-%E6%89%93%E9%80%A0%E9%80%99%E5%80%8B-hugo-%E9%83%A8%E8%90%BD%E6%A0%BC%E7%9A%84/</link><pubDate>Sun, 08 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-ai-codex-%E6%89%93%E9%80%A0%E9%80%99%E5%80%8B-hugo-%E9%83%A8%E8%90%BD%E6%A0%BC%E7%9A%84/</guid><description>在上一篇文章 《第一次認識 Codex：讓 AI 幫你寫程式不是夢！》 中，我介紹了 Codex 這個強大的 AI 程式助理。而今天，我想分享一個更具體的實戰經驗：我是如何利用 Codex 來開發你現在正在看的這個部落格。
這個網站是使用 Hugo 靜態網站產生器搭建的，並搭配 Tailwind CSS 進行樣式設計。從前端的 JavaScript 互動功能，到後端的 GitHub Actions 自動化部署，許多環節都有 AI 的深度參與。接下來，我會分享幾個關鍵功能的開發過程，以及我是如何「詠唱」我的需求，讓 AI 幫我完成任務的。
1. 前端互動功能：讓網站活起來的 JavaScript 靜態網站很容易變得單調，但透過 JavaScript，我們可以加入許多動態的現代化功能。這也是我認為 Codex 最能大顯身手的地方。
深色/淺色主題切換 這是現代網站的標配功能。我需要一個按鈕，它能：
切換 &amp;lt;html&amp;gt; 標籤上的 data-theme 屬性 (在 light 與 dark 之間)。 將用戶的偏好儲存在瀏覽器的 localStorage 中，以便下次造訪時維持設定。 當主題變更時，通知 Giscus 留言區一起變更主題。 我的提問大致如下：
「幫我寫一段 JavaScript。當使用者點擊 ID 為 theme-toggle 的按鈕時，在 &amp;lt;html&amp;gt; 元素上切換 data-theme 屬性，值為 &amp;rsquo;light&amp;rsquo; 或 &amp;lsquo;dark&amp;rsquo;。將這個設定存到 localStorage。頁面載入時，優先從 localStorage 讀取設定。最後，當主題改變時，發送一個 postMessage 給 class 為 giscus-frame 的 iframe，內容為 { giscus: { setTheme: newTheme } }。」</description></item><item><title>第一次認識 Codex：讓 AI 幫你寫程式不是夢！</title><link>/ChiYu-Blob/posts/%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%AA%8D%E8%AD%98-codex%E8%AE%93-ai-%E5%B9%AB%E4%BD%A0%E5%AF%AB%E7%A8%8B%E5%BC%8F%E4%B8%8D%E6%98%AF%E5%A4%A2/</link><pubDate>Thu, 05 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%AA%8D%E8%AD%98-codex%E8%AE%93-ai-%E5%B9%AB%E4%BD%A0%E5%AF%AB%E7%A8%8B%E5%BC%8F%E4%B8%8D%E6%98%AF%E5%A4%A2/</guid><description>最近如果你有在關注 AI 或寫程式的領域，可能會聽過一個名字——Codex。它是 OpenAI 推出的一個超厲害工具，簡單來說，就是一個會寫程式的 AI。今天這篇文章就想用比較輕鬆的方式，來帶大家初步認識一下 Codex 是什麼、可以拿來做什麼、還有怎麼開始玩看看。
Codex 是什麼？跟 ChatGPT 有關嗎？ 沒錯，Codex 是 OpenAI（就是做 ChatGPT 那家公司）開發的模型之一。它其實就是 ChatGPT 的「懂程式」版本。
你可以把它想成一個超強的助理工程師，你對它講人話，它就能幫你寫出程式碼。不管你是要寫一個 Python 函式，還是建一個簡單的網頁 API，Codex 都能幫你快速搞定，甚至連註解都幫你寫好。
Codex 可以幫你做什麼？ 它的功能說起來還真不少，這邊列幾個我覺得超實用的：
自然語言變程式碼：你只要打「幫我寫一個排序的函式」，Codex 馬上就可以用 Python 幫你寫出來。 支援多種語言：Python、JavaScript、C#、Go、Ruby……通通支援，開什麼語言的專案都能用。 幫忙除錯：看不懂 error message？丟給 Codex，讓它幫你分析。 寫測試、補註解：這些瑣碎事 Codex 做起來超快，超方便。 誰適合用 Codex？ 老實說，不管你是剛入門的新手，還是忙到炸的資深工程師，Codex 都有它的價值：
對新手來說，它就像一個 24 小時在線的老師，問什麼都不會兇你。 對老手來說，它超像一個效率助手，幫你處理一堆重複或機械性的事，省下超多時間。 要怎麼開始用？ 目前 Codex 主要是整合在 ChatGPT 專業版（Pro）裡，直接在 ChatGPT 裡輸入程式問題就可以用了。
如果你比較偏好本地開發環境，也可以試試看一些支援 Codex 的 IDE 外掛，比如 Visual Studio Code，現在已經有支援類似 Copilot 的功能。
小結一下 Codex 是一個能聽懂你說話、然後幫你寫程式的 AI，對很多人來說，它可以加速開發、降低學習門檻、甚至讓寫程式變得更輕鬆有趣。
如果你還沒試過，不妨開個 ChatGPT Pro 試試，玩玩看 Codex 的威力。這篇文章只是開個頭，之後我也會陸續寫些更進階的使用心得與實際應用分享，敬請期待！</description></item><item><title>關於我</title><link>/ChiYu-Blob/about/</link><pubDate>Sun, 01 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/about/</guid><description>你好！我是 ChiYu (也可以叫我 Eric)。
我是一名軟體工程師，目前專注於 C# .Net 後端開發領域。 熱愛研究軟體架構、設計模式 (Design Patterns) 以及各種能讓程式碼更優雅的技術。
這個部落格主要用來記錄我的技術學習筆記、開發心得以及一些 Side Projects 的開發過程。我相信「教學相長」，透過輸出來強化輸入，同時也希望能幫助到在技術路上遇到類似問題的朋友。
聯絡我 (Contact Me) 如果你有任何合作機會、技術交流或是想喝杯咖啡聊聊，歡迎透過 Email 聯繫我：
Email: iamhandsomeboy1129@gmail.com 更多連結 (Connect with Me) 除了部落格，你也可以在以下地方找到我：
GitHub 我的程式碼倉庫，存放了各種開源專案、練習範例以及這個部落格的原始碼。
iThome 鐵人賽 這裡收錄了我參加 iThome 鐵人賽的系列文章，內容包含完整的技術主題探討。
LinkedIn 我的職涯履歷與專業技能認證，歡迎建立連結交流。
CakeResume 我的線上履歷，包含更詳細的專案經歷介紹。
Threads 偶爾會在這裡分享一些技術圈的觀察、生活碎碎念或是靈光一閃的想法。
如果你對我的文章有任何建議或想法，歡迎在文章下方留言或是透過上述社群平台與我聯繫！</description></item></channel></rss>