<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ChiYu's Blob on ChiYu Code Journey</title><link>/ChiYu-Blob/</link><description>Recent content in ChiYu's Blob on ChiYu Code Journey</description><generator>Hugo -- gohugo.io</generator><language>zh-TW</language><lastBuildDate>Fri, 13 Jun 2025 07:00:00 +0800</lastBuildDate><atom:link href="/ChiYu-Blob/index.xml" rel="self" type="application/rss+xml"/><item><title>搞懂設計模式到底是什麼？</title><link>/ChiYu-Blob/posts/%E6%90%9E%E6%87%82%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E9%BA%BC/</link><pubDate>Wed, 11 Jun 2025 12:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E6%90%9E%E6%87%82%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E9%BA%BC/</guid><description>哈囉！最近我決定開始一個新的 Side Project，要來用比較輕鬆的方式跟大家分享一下什麼是「設計模式（Design Patterns）」。
等等先別跑！雖然聽起來很硬，但設計模式其實就是一些「前輩工程師們」留下來的解決問題的好方法。懂了這些，你的程式碼會變得更容易維護，更容易擴充，甚至看起來更專業！（聽起來是不是有點心動了？）
這篇先帶你入個門，我們會聊聊設計模式的概念、分類，最後也會簡單列出一些常見好用的模式，讓你一次搞懂設計模式到底在幹嘛。
🧐 所以，到底什麼是設計模式啊？ 簡單說，設計模式就像是程式設計師之間的「共通語言」。
你一定有過這種經驗：
「欸，我怎麼又寫出這種一團亂的程式碼？」 「這個功能之前不是做過了嗎？為什麼還要再寫一次？」 這時候，如果你腦袋裡裝著幾種設計模式，就像工具箱一樣，你就能更快速地解決這些問題。
設計模式其實就是經過無數開發者實踐後得出的好用解決方案，就像老前輩的私房武功，學起來絕對讓你的程式碼更整齊、更有架構，也比較不容易踩坑。
設計模式可以怎麼分？ 一般來說，設計模式分成三大類：
建立型模式（Creational Patterns）
重點在教你怎麼更聰明地「建立」物件，避免程式碼越寫越複雜。
結構型模式（Structural Patterns）
教你怎麼把物件組合在一起，像拼樂高一樣，輕鬆擴充或調整程式的架構。
行為型模式（Behavioral Patterns）
教你搞定物件之間複雜的「溝通與互動」，讓你的程式碼彼此合作起來更加順暢。
是不是聽起來越來越清楚了？接下來我們更進一步，列出每個分類下的常見模式，讓你一眼看懂設計模式家族有什麼好貨！
常見設計模式大集合 這邊先條列式介紹，未來我會用獨立的文章、一個一個講清楚：
🚀 建立型模式（Creational） 單例模式（Singleton） 工廠方法模式（Factory Method） 抽象工廠模式（Abstract Factory） 原型模式（Prototype） 建造者模式（Builder） 📌 特點： 這一類幫你搞定物件的建立，讓你不用一直煩惱物件從哪裡來，要怎麼產生之類的問題。
2. 結構型模式（Structural） 介面卡模式（Adapter） 橋接模式（Bridge） 組合模式（Composite） 裝飾者模式（Decorator） 外觀模式（Facade） 享元模式（Flyweight） 代理模式（Proxy） 📌 特點： 這些模式專門解決如何「拼裝」不同物件，讓你的程式更容易擴充、更有彈性。
想像成在玩樂高，一個一個小零件組裝起來，最後變成超酷的東西！
🚦 行為型模式（Behavioral） 責任鏈模式（Chain of Responsibility） 命令模式（Command） 解譯器模式（Interpreter） 迭代器模式（Iterator） 中介者模式（Mediator） 備忘錄模式（Memento） 觀察者模式（Observer） 狀態模式（State） 策略模式（Strategy） 模板方法模式（Template Method） 訪問者模式（Visitor） 📌 特點： 處理物件之間的「互動」。如果你常常覺得你的物件們關係很亂，溝通起來像在吵架，那這些模式就是你的救星！</description></item><item><title>單例模式：只要一個就夠！</title><link>/ChiYu-Blob/posts/%E5%96%AE%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%8F%AA%E8%A6%81%E4%B8%80%E5%80%8B%E5%B0%B1%E5%A4%A0/</link><pubDate>Thu, 12 Jun 2025 10:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E5%96%AE%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%8F%AA%E8%A6%81%E4%B8%80%E5%80%8B%E5%B0%B1%E5%A4%A0/</guid><description>在上一篇文章中，我們簡單認識了什麼是「設計模式」。這次，就讓我們從最經典的「單例模式（Singleton）」開始，看看它究竟能為開發帶來什麼幫助吧！
☕ 小故事：世界上只此一家 想像你開了一間只允許存在一個分店的咖啡廳，無論客人怎麼找，都只能到這家。單例模式的精神也差不多：確保整個應用程式裡只有同一個實例存在。
🤔 什麼情境適合用 Singleton？ 系統設定：確保設定檔只有一份，避免各模組各自讀取產生混亂。 日誌記錄：統一紀錄進入點，不會讓檔案四散。 資料庫連線：集中管理連線、節省資源。 接下來的範例將以「系統設定」為主角，用 C# 程式碼示範 Singleton 的實作。
💻 Singleton 類別 using System; /// &amp;lt;summary&amp;gt; /// 系統設定管理器，只允許產生一個實例 /// &amp;lt;/summary&amp;gt; public sealed class ConfigurationManager { // 保留唯一實例 private static ConfigurationManager _instance; // 執行緒鎖定物件，確保多執行緒環境下仍只會建立一次 private static readonly object _lock = new object(); /// &amp;lt;summary&amp;gt; /// 連線字串設定 /// &amp;lt;/summary&amp;gt; public string ConnectionString { get; private set; } // 建構子設為私有，阻止外部直接建立 private ConfigurationManager() { Console.WriteLine(&amp;#34;建立 ConfigurationManager 唯一實例&amp;#34;); // 模擬載入設定值 ConnectionString = &amp;#34;Server=myServer;Database=myDB;User Id=myUser;&amp;#34;; } /// &amp;lt;summary&amp;gt; /// 取得唯一實例的存取點 /// &amp;lt;/summary&amp;gt; public static ConfigurationManager Instance { get { if (_instance == null) { lock (_lock) { if (_instance == null) { _instance = new ConfigurationManager(); } } } return _instance; } } } 🚀 實際使用範例 using System; class Program { static void Main(string[] args) { // 第一次取得實例 ConfigurationManager config1 = ConfigurationManager.</description></item><item><title>工廠方法模式：點披薩不用親自下廚</title><link>/ChiYu-Blob/posts/%E5%B7%A5%E5%BB%A0%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E9%BB%9E%E6%8A%AB%E8%96%A9%E4%B8%8D%E7%94%A8%E8%A6%AA%E8%87%AA%E4%B8%8B%E5%BB%9A/</link><pubDate>Thu, 12 Jun 2025 10:30:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E5%B7%A5%E5%BB%A0%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E9%BB%9E%E6%8A%AB%E8%96%A9%E4%B8%8D%E7%94%A8%E8%A6%AA%E8%87%AA%E4%B8%8B%E5%BB%9A/</guid><description>哈囉大家，接續上一次 Singleton 模式，這一次我們要介紹的是另一個超實用的模式：工廠方法模式（Factory Method）。
別看到「工廠」兩個字就開始緊張，其實它超簡單！讓我們先來個輕鬆的比喻吧：
假設你今天去一家披薩店，店員跟你說：「告訴我你想吃什麼披薩，我們後面的廚師就會幫你做出來！」你不用在意披薩到底怎麼做，反正店家會處理好所有製作細節。這樣，你只要說出你想要的東西，剩下的交給專業的工廠就行。
這就是「工廠方法模式」的核心精神啦！
🤔 工廠方法模式什麼時候派得上用場？ 當你遇到以下狀況時，就可以考慮使用工廠方法模式：
你有多種類似的物件需要建立，但你不想每次都自己指定具體的類別。 你想要簡化物件的建立過程，並且統一管理物件的生成邏輯。 你想要未來可以輕鬆新增不同類型的物件，而不需要大幅修改現有的程式碼。 C# 工廠方法模式實作範例 這次我們就以「披薩店」作為具體的案例，示範如何使用工廠方法模式：
🍕 首先，定義產品介面 /// &amp;lt;summary&amp;gt; /// 披薩產品介面 /// &amp;lt;/summary&amp;gt; public interface IPizza { /// &amp;lt;summary&amp;gt; /// 準備食材 /// &amp;lt;/summary&amp;gt; void Prepare(); /// &amp;lt;summary&amp;gt; /// 烘烤披薩 /// &amp;lt;/summary&amp;gt; void Bake(); /// &amp;lt;summary&amp;gt; /// 切割披薩 /// &amp;lt;/summary&amp;gt; void Cut(); /// &amp;lt;summary&amp;gt; /// 裝盒披薩 /// &amp;lt;/summary&amp;gt; void Box(); } 🧑‍🍳 建立具體的產品類別 using System; /// &amp;lt;summary&amp;gt; /// 起司披薩 /// &amp;lt;/summary&amp;gt; public class CheesePizza : IPizza { public void Prepare() =&amp;gt; Console.</description></item><item><title>想快速打造個人部落格？試試 HugoBlobTemplate，極簡、開源，讓你專注寫作！</title><link>/ChiYu-Blob/posts/%E6%83%B3%E5%BF%AB%E9%80%9F%E6%89%93%E9%80%A0%E5%80%8B%E4%BA%BA%E9%83%A8%E8%90%BD%E6%A0%BC%E8%A9%A6%E8%A9%A6-hugoblobtemplate%E6%A5%B5%E7%B0%A1%E9%96%8B%E6%BA%90%E8%AE%93%E4%BD%A0%E5%B0%88%E6%B3%A8%E5%AF%AB%E4%BD%9C/</link><pubDate>Wed, 11 Jun 2025 10:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E6%83%B3%E5%BF%AB%E9%80%9F%E6%89%93%E9%80%A0%E5%80%8B%E4%BA%BA%E9%83%A8%E8%90%BD%E6%A0%BC%E8%A9%A6%E8%A9%A6-hugoblobtemplate%E6%A5%B5%E7%B0%A1%E9%96%8B%E6%BA%90%E8%AE%93%E4%BD%A0%E5%B0%88%E6%B3%A8%E5%AF%AB%E4%BD%9C/</guid><description>【文章最終整合版】 想快速打造個人部落格？試試 HugoBlobTemplate，極簡、開源，讓你專注寫作！ 你是不是也曾想過，要建立一個屬於自己的小天地，放些技術筆記、生活隨筆，或是作品集？但一想到要租主機、搞定複雜的後台設定、擔心網站速度，頭就開始痛了？
別擔心！今天就是要來跟你介紹一個我完成的開源專案：HugoBlobTemplate，它能讓你幾乎零成本、超快速地建立一個美觀又實用的個人部落格。
點我前往 HugoBlobTemplate 的 GitHub 專案頁面 這到底是什麼？適合誰用？ 簡單來說，HugoBlobTemplate 是一個基於 Hugo 這個靜態網站生成器所打造的「部落格模板」。
你可能聽過 WordPress，但 Hugo 不一樣。它不會動態去讀取資料庫，而是在你寫完文章後，直接「生成」一整個網站的 HTML 靜態檔案。這樣做有幾個超強的優點：
快！快到飛起！ 因為使用者瀏覽的都只是純粹的 HTML，沒有後端處理、沒有資料庫查詢，載入速度幾乎是瞬間完成。 安全！ 沒有後台登入頁面、沒有資料庫，自然就少了很多被攻擊的風險。 便宜（甚至免費）！ 你可以把生成好的網站檔案，輕鬆部署到像是 GitHub Pages、Netlify 或 Vercel 這些提供免費託管服務的平台上。 所以，HugoBlobTemplate 就是幫你把 Hugo 的環境都設定好，給你一個「開箱即用」的部落格樣式。它特別適合：
工程師/學生：想記錄技術筆記、學習心得，需要一個簡潔、支援程式碼高亮的平台。 文字創作者：不想被複雜的編輯器綁架，希望專注在內容本身。 任何人：想擁有一個「自己的」網站，不想付月費，也不想花大把時間在維護上。 HugoBlobTemplate 有哪些貼心的功能？ 這個專案雖然主打極簡，但在基礎功能上一點也不馬虎。我已經幫你內建了許多實用的功能：
內建亮色/暗色模式：自動偵測使用者系統的偏好設定，也可以讓訪客手動切換，非常貼心。 社群連結整合：想放你的 GitHub、LinkedIn 等連結？只要在設定檔裡填上你的帳號，就會自動出現在個人介紹區塊。 SEO 友善：專案已經幫你處理好基礎的搜尋引擎優化（SEO），讓你的內容更容易被 Google 等搜尋引擎找到。 響應式設計 (RWD)：無論你的訪客用的是電腦、平板還是手機，網站版面都能自動適應，提供最佳的閱讀體驗。 好！我想用！該如何開始？ 整個過程比你想像的還要簡單，大概可以分成以下幾步：
第 1 步：準備環境 (若想在本機預覽) 如果你想在自己的電腦上看到網站的即時變化，需要先安裝兩樣東西：
Git：用來抓取專案程式碼。 Hugo：用來產生網站的核心工具。（官方安裝說明 ） 第 2 步：把專案抓下來 打開你的終端機，輸入以下指令：
git clone https://github.</description></item><item><title>抽象工廠模式：系列產品輕鬆生產</title><link>/ChiYu-Blob/posts/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%BB%A0%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E7%94%A2%E5%93%81%E8%BC%95%E9%AC%86%E7%94%9F%E7%94%A2/</link><pubDate>Thu, 12 Jun 2025 11:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%BB%A0%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E7%94%A2%E5%93%81%E8%BC%95%E9%AC%86%E7%94%9F%E7%94%A2/</guid><description>嗨各位朋友～前面我們介紹過了 Singleton 和 Factory Method，今天要繼續往下走，聊一個稍微進階一點點的設計模式：「抽象工廠模式（Abstract Factory）」。
🌟 什麼是抽象工廠模式？ 簡單來說，抽象工廠模式就是提供一個介面，讓你可以建立一整系列相關的產品，而不需要關心產品具體的實作方式。
舉個例子，今天你到 IKEA 買家具，通常會想要一次買齊同一系列的產品，比如椅子、桌子、書架等等。如果這些家具都是同系列，外觀看起來會很搭調，品質和風格也會一致。這樣的一個系列產品，就是抽象工廠想幫你解決的問題！
🧐 抽象工廠模式適合什麼場景？ 以下情境適合用抽象工廠模式解決：
你的產品需要有不同的系列或主題，每個系列內又有多個相關產品。 想要保證同系列產品之間能夠完美兼容。 未來可能需要新增更多產品系列，而希望盡可能避免修改現有程式碼。 🛋️ C# 抽象工廠模式範例 這次，我們就用「家具工廠」作為範例來示範抽象工廠模式的實作吧！
1️⃣ 定義產品介面 /// &amp;lt;summary&amp;gt; /// 椅子介面 /// &amp;lt;/summary&amp;gt; public interface IChair { /// &amp;lt;summary&amp;gt; /// 坐在椅子上 /// &amp;lt;/summary&amp;gt; void SitOn(); } /// &amp;lt;summary&amp;gt; /// 桌子介面 /// &amp;lt;/summary&amp;gt; public interface ITable { /// &amp;lt;summary&amp;gt; /// 使用桌子 /// &amp;lt;/summary&amp;gt; void Use(); } 🛋️ 建立具體產品（現代系列和古典系列） using System; /// &amp;lt;summary&amp;gt; /// 現代風格椅子 /// &amp;lt;/summary&amp;gt; public class ModernChair : IChair { public void SitOn() =&amp;gt; Console.</description></item><item><title>讓部落格成為你的形狀：Hugo 個人化設定終極指南</title><link>/ChiYu-Blob/posts/%E8%AE%93%E9%83%A8%E8%90%BD%E6%A0%BC%E6%88%90%E7%82%BA%E4%BD%A0%E7%9A%84%E5%BD%A2%E7%8B%80hugo-%E5%80%8B%E4%BA%BA%E5%8C%96%E8%A8%AD%E5%AE%9A%E7%B5%82%E6%A5%B5%E6%8C%87%E5%8D%97/</link><pubDate>Wed, 11 Jun 2025 11:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E8%AE%93%E9%83%A8%E8%90%BD%E6%A0%BC%E6%88%90%E7%82%BA%E4%BD%A0%E7%9A%84%E5%BD%A2%E7%8B%80hugo-%E5%80%8B%E4%BA%BA%E5%8C%96%E8%A8%AD%E5%AE%9A%E7%B5%82%E6%A5%B5%E6%8C%87%E5%8D%97/</guid><description>讓部落格成為你的形狀：Hugo 個人化設定終極指南 當你成功部署了這個部落格模板，恭喜你完成了第一步！但真正的樂趣現在才開始：將這個公版的部落格，徹底改造成專屬於你的樣子。
這篇文章是一份完整的個人化指南，將帶你從裡到外，一步步設定與調整，打造出獨一無二的個人網站。
第一站：核心設定 (hugo.toml) hugo.toml 是你部落格的「大腦」與「指揮中心」，幾乎所有基本資訊都在這裡設定。
1. 網站基本資訊 首先，打開 hugo.toml 檔案，找到並修改以下幾個關鍵欄位：
baseURL: (最重要!) 這裡必須換成你未來部署網站的最終網址。如果是使用 GitHub Pages，通常會是 https://&amp;lt;你的GitHub帳號&amp;gt;.github.io/&amp;lt;你的專案名稱&amp;gt;/。 title: 你部落格的主要名稱，會顯示在瀏覽器分頁和網站標頭上。 [params] description: 網站的副標題或描述，會顯示在首頁的大標題下方。 [params.author] name: 你的名字或暱稱。 2. 你的社交連結 在 hugo.toml 中，有一個 [params.social] 區塊，你可以在這裡新增、刪除或修改你的社群媒體連結。
# hugo.toml [params.social] GitHub = &amp;#34;https://github.com/eric861129&amp;#34; LinkedIn = &amp;#34;https://www.linkedin.com/in/chiyu-huang/&amp;#34; Threads = &amp;#34;https://www.threads.com/@chiyuisme&amp;#34; # 你也可以新增自己的，例如： # Twitter = &amp;#34;https://twitter.com/your_account&amp;#34; 3. 啟用你自己的留言區 (Giscus) 這個部落格模板整合了 Giscus 留言系統。為了讓讀者能在你的部落格留言，而不是在我的模板專案上，你必須進行設定：
跟隨 Giscus 官網的教學，為你自己的 GitHub 專案啟用 Giscus。 將 hugo.toml 檔案中 [params.giscus] 的設定值，換成你在 Giscus 官網上取得的你自己的設定。 這些設定會被 layouts/_default/baseof.</description></item><item><title>原型模式：複製的藝術</title><link>/ChiYu-Blob/posts/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E8%A4%87%E8%A3%BD%E7%9A%84%E8%97%9D%E8%A1%93/</link><pubDate>Thu, 12 Jun 2025 12:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E8%A4%87%E8%A3%BD%E7%9A%84%E8%97%9D%E8%A1%93/</guid><description>嗨！繼續設計模式系列，這次要介紹的主角是原型模式（Prototype）。聽到「原型」這個詞是不是有點不太確定這到底是什麼？別擔心，我們還是用輕鬆易懂的方式來理解它吧！
🌟 原型模式到底在做什麼？ 原型模式簡單來說就是透過「複製」現有的物件，來建立一個新物件。就像我們常用的「複製貼上」一樣。
比如你去文具店要印名片，你只需要給店員一張原稿，他就能根據這份原稿複製出許多張一模一樣的名片，而不用一張一張重新設計。
🤔 什麼時候該用原型模式？ 物件的建立成本較高（例如需要從資料庫讀取大量資料）。 你要建立的物件跟現有物件差異不大，只需要稍微修改一下就可以使用。 希望降低物件建立時的複雜度與耗時。 📑 C# 原型模式範例 這次我們就以「履歷表複製」作為實際案例，來看看怎麼使用原型模式吧！
📄 定義原型介面 /// &amp;lt;summary&amp;gt; /// 原型介面，提供複製方法 /// &amp;lt;/summary&amp;gt; public interface IResume { /// &amp;lt;summary&amp;gt; /// 複製自身 /// &amp;lt;/summary&amp;gt; IResume Clone(); /// &amp;lt;summary&amp;gt; /// 顯示履歷內容 /// &amp;lt;/summary&amp;gt; void Display(); } 📄 實作具體原型類別 using System; /// &amp;lt;summary&amp;gt; /// 履歷表 /// &amp;lt;/summary&amp;gt; public class Resume : IResume { /// &amp;lt;summary&amp;gt; /// 姓名 /// &amp;lt;/summary&amp;gt; public string Name { get; set; } /// &amp;lt;summary&amp;gt; /// 工作經驗 /// &amp;lt;/summary&amp;gt; public string Experience { get; set; } public Resume(string name, string experience) { Name = name; Experience = experience; } /// &amp;lt;summary&amp;gt; /// 複製自身 /// &amp;lt;/summary&amp;gt; public IResume Clone() { // 直接淺層複製即可 return (IResume)this.</description></item><item><title>建造者模式：一步步完成複雜任務</title><link>/ChiYu-Blob/posts/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%80%E6%AD%A5%E6%AD%A5%E5%AE%8C%E6%88%90%E8%A4%87%E9%9B%9C%E4%BB%BB%E5%8B%99/</link><pubDate>Thu, 12 Jun 2025 13:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%80%E6%AD%A5%E6%AD%A5%E5%AE%8C%E6%88%90%E8%A4%87%E9%9B%9C%E4%BB%BB%E5%8B%99/</guid><description>哈囉各位朋友們～今天我們繼續設計模式之旅，來聊聊 建造者模式（Builder） 吧！
🌟 建造者模式是什麼？ 簡單地說，建造者模式就是將一個複雜產品的建構過程拆分成幾個獨立的步驟，然後逐步組裝起來。
你可以想像去 Subway 點三明治：店員會一步一步詢問你想加什麼食材，麵包種類、起司、蔬菜、醬料……最後做出你最愛的那個獨特三明治。這個點餐流程就有點像建造者模式的概念。
透過建造者模式，你可以有系統地建立出不同組合的複雜產品，並且輕鬆管理每一個步驟。
🤔 什麼時候要用建造者模式？ 產品建立過程複雜，有許多可變步驟或選項。 想要明確區分物件的構建步驟與產出的物件。 未來可能會新增更多的建構方式，但不想更動產品本身。 🥪 C# 建造者模式範例 我們就用「三明治店」當作實際範例，讓你馬上理解這個模式吧！
🥖 首先定義產品類別 using System; using System.Collections.Generic; /// &amp;lt;summary&amp;gt; /// 三明治產品 /// &amp;lt;/summary&amp;gt; public class Sandwich { /// &amp;lt;summary&amp;gt; /// 麵包種類 /// &amp;lt;/summary&amp;gt; public string Bread { get; set; } /// &amp;lt;summary&amp;gt; /// 起司種類 /// &amp;lt;/summary&amp;gt; public string Cheese { get; set; } /// &amp;lt;summary&amp;gt; /// 蔬菜配料 /// &amp;lt;/summary&amp;gt; public List&amp;lt;string&amp;gt; Veggies { get; set; } = new List&amp;lt;string&amp;gt;(); /// &amp;lt;summary&amp;gt; /// 醬料 /// &amp;lt;/summary&amp;gt; public string Sauce { get; set; } /// &amp;lt;summary&amp;gt; /// 顯示三明治內容 /// &amp;lt;/summary&amp;gt; public void Display() { Console.</description></item><item><title>介面卡模式：讓不相容也能合作</title><link>/ChiYu-Blob/posts/%E4%BB%8B%E9%9D%A2%E5%8D%A1%E6%A8%A1%E5%BC%8F%E8%AE%93%E4%B8%8D%E7%9B%B8%E5%AE%B9%E4%B9%9F%E8%83%BD%E5%90%88%E4%BD%9C/</link><pubDate>Thu, 12 Jun 2025 14:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E4%BB%8B%E9%9D%A2%E5%8D%A1%E6%A8%A1%E5%BC%8F%E8%AE%93%E4%B8%8D%E7%9B%B8%E5%AE%B9%E4%B9%9F%E8%83%BD%E5%90%88%E4%BD%9C/</guid><description>哈囉大家！今天我們要介紹的設計模式是：介面卡模式（Adapter），又叫做轉接器模式。
🌟 介面卡模式（Adapter）到底在做什麼？ 就像生活中的轉接頭，它能讓本來不相容的介面順利溝通。在軟體開發裡，Adapter 模式同樣扮演橋樑角色，讓舊有系統與新系統或外部套件能順利合作。
🤔 什麼時候適合用 Adapter？ 既有系統或類別的介面與你需要的不相容。 想使用外部套件，但介面不同，無法直接套用。 希望在不修改既有程式碼的前提下解決介面不合的問題。 🔌 C# Adapter 模式範例 我們以「充電器轉接頭」的例子來說明介面卡模式。
🔋 既有不相容的類別 using System; /// &amp;lt;summary&amp;gt; /// 現有的歐洲插座 /// &amp;lt;/summary&amp;gt; public class EuropeanSocket { public void SpecificRequest() =&amp;gt; Console.WriteLine(&amp;#34;使用歐洲規格的插座&amp;#34;); } 🔋 定義目標介面 /// &amp;lt;summary&amp;gt; /// 台灣插頭介面 /// &amp;lt;/summary&amp;gt; public interface ITaiwanPlug { /// &amp;lt;summary&amp;gt; /// 連接插座 /// &amp;lt;/summary&amp;gt; void Request(); } 🔌 建立介面卡 /// &amp;lt;summary&amp;gt; /// 介面卡：讓歐洲插座能用於台灣插頭 /// &amp;lt;/summary&amp;gt; public class PlugAdapter : ITaiwanPlug { private EuropeanSocket _europeanSocket; public PlugAdapter(EuropeanSocket socket) { _europeanSocket = socket; } public void Request() { // 透過轉接頭呼叫原本的歐洲規格插座 _europeanSocket.</description></item><item><title>橋接模式：抽象與實作分離</title><link>/ChiYu-Blob/posts/%E6%A9%8B%E6%8E%A5%E6%A8%A1%E5%BC%8F%E6%8A%BD%E8%B1%A1%E8%88%87%E5%AF%A6%E4%BD%9C%E5%88%86%E9%9B%A2/</link><pubDate>Thu, 12 Jun 2025 15:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E6%A9%8B%E6%8E%A5%E6%A8%A1%E5%BC%8F%E6%8A%BD%E8%B1%A1%E8%88%87%E5%AF%A6%E4%BD%9C%E5%88%86%E9%9B%A2/</guid><description>哈囉大家～我們繼續來探索設計模式的世界吧！今天要介紹的是一個聽起來可能有點陌生，但其實很實用的設計模式：橋接模式（Bridge）。
🌟 橋接模式是什麼？ 橋接模式將抽象部分和實作部分分離，讓它們可以獨立變化。想像遙控器與電視：不希望為每種遙控器和電視的組合都寫一次程式碼，這時就能運用橋接模式。
🤔 什麼時候適合用橋接模式？ 避免抽象和實作之間產生過多耦合。 有多個維度需要獨立擴充。 想降低程式複雜度，避免類別過多。 📺 C# 橋接模式範例 以「遙控器控制電視」為例說明。
📡 建立實作介面（電視） /// &amp;lt;summary&amp;gt; /// 電視實作介面 /// &amp;lt;/summary&amp;gt; public interface ITV { void On(); void Off(); void SetChannel(int channel); } 📺 建立具體實作 using System; /// &amp;lt;summary&amp;gt; /// Sony 電視 /// &amp;lt;/summary&amp;gt; public class SonyTV : ITV { public void On() =&amp;gt; Console.WriteLine(&amp;#34;Sony 電視開機&amp;#34;); public void Off() =&amp;gt; Console.WriteLine(&amp;#34;Sony 電視關機&amp;#34;); public void SetChannel(int channel) =&amp;gt; Console.WriteLine($&amp;#34;Sony 電視設定頻道：{channel}&amp;#34;); } /// &amp;lt;summary&amp;gt; /// Samsung 電視 /// &amp;lt;/summary&amp;gt; public class SamsungTV : ITV { public void On() =&amp;gt; Console.</description></item><item><title>組合模式：樹狀結構的好幫手</title><link>/ChiYu-Blob/posts/%E7%B5%84%E5%90%88%E6%A8%A1%E5%BC%8F%E6%A8%B9%E7%8B%80%E7%B5%90%E6%A7%8B%E7%9A%84%E5%A5%BD%E5%B9%AB%E6%89%8B/</link><pubDate>Thu, 12 Jun 2025 16:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E7%B5%84%E5%90%88%E6%A8%A1%E5%BC%8F%E6%A8%B9%E7%8B%80%E7%B5%90%E6%A7%8B%E7%9A%84%E5%A5%BD%E5%B9%AB%E6%89%8B/</guid><description>哈囉大家，歡迎繼續探索設計模式之旅！今天要介紹的是一個既實用又好理解的設計模式：組合模式（Composite）。
🌟 組合模式是什麼？ 組合模式讓你能將物件組織成樹狀結構，表示「整體—部分」的層次關係。像資料夾裡有資料夾、檔案又放在資料夾中，這正是組合模式的典型應用。
🤔 什麼時候適合用組合模式？ 需要表示物件的「整體—部分」階層。 想要用一致的方式處理個別物件和物件群組。 希望簡化客戶端程式碼，不必區分個體與集合的處理邏輯。 📁 C# 組合模式範例 用「檔案系統」來示範組合模式。
📄 建立抽象組件介面 /// &amp;lt;summary&amp;gt; /// 抽象檔案系統元件 /// &amp;lt;/summary&amp;gt; public interface IFileSystemComponent { /// &amp;lt;summary&amp;gt; /// 以縮排方式顯示結構 /// &amp;lt;/summary&amp;gt; void Display(int depth); } 📁 建立樹枝構件（資料夾） using System; using System.Collections.Generic; /// &amp;lt;summary&amp;gt; /// 資料夾 /// &amp;lt;/summary&amp;gt; public class Folder : IFileSystemComponent { private string _name; private List&amp;lt;IFileSystemComponent&amp;gt; _components = new List&amp;lt;IFileSystemComponent&amp;gt;(); public Folder(string name) { _name = name; } /// &amp;lt;summary&amp;gt; /// 新增子元件 /// &amp;lt;/summary&amp;gt; public void Add(IFileSystemComponent component) { _components.</description></item><item><title>裝飾者模式：讓功能自由加點</title><link>/ChiYu-Blob/posts/%E8%A3%9D%E9%A3%BE%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AE%93%E5%8A%9F%E8%83%BD%E8%87%AA%E7%94%B1%E5%8A%A0%E9%BB%9E/</link><pubDate>Thu, 12 Jun 2025 17:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E8%A3%9D%E9%A3%BE%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AE%93%E5%8A%9F%E8%83%BD%E8%87%AA%E7%94%B1%E5%8A%A0%E9%BB%9E/</guid><description>哈囉朋友們～今天要介紹的設計模式可是非常實用又有趣的喔，那就是 裝飾者模式（Decorator）！
🌟 什麼是裝飾者模式？ 裝飾者模式讓你在不修改現有物件程式碼的情況下，動態地增加新的功能。簡單來說，就是「包一層再包一層」的概念。
想像一下買一杯飲料，你可以加珍珠、椰果、鮮奶油等等，每個配料就像一個裝飾，你可以自由組合，做出你專屬的飲料，這就是裝飾者模式的概念！
🤔 什麼情況適合用裝飾者模式？ 當你遇到以下情境時，很適合使用裝飾者模式：
需要動態地為物件增加或移除功能。 不想直接修改原本類別的程式碼，避免影響原本物件的穩定性。 想要彈性地組合不同的功能，並且可以隨時調整功能。 🎂 C# 裝飾者模式範例 我們用最容易理解的「咖啡加料」案例，來看看怎麼實作裝飾者模式吧！
☕ 定義抽象元件（Component） using System; /// &amp;lt;summary&amp;gt; /// 咖啡抽象元件 /// &amp;lt;/summary&amp;gt; public abstract class Coffee { /// &amp;lt;summary&amp;gt; /// 取得描述 /// &amp;lt;/summary&amp;gt; public abstract string GetDescription(); /// &amp;lt;summary&amp;gt; /// 供應咖啡 /// &amp;lt;/summary&amp;gt; public abstract void Serve(); } ☕ 實作具體元件 using System; /// &amp;lt;summary&amp;gt; /// 基本咖啡 /// &amp;lt;/summary&amp;gt; public class SimpleCoffee : Coffee { /// &amp;lt;summary&amp;gt; /// 取得描述 /// &amp;lt;/summary&amp;gt; public override string GetDescription() =&amp;gt; &amp;#34;基本咖啡&amp;#34;; /// &amp;lt;summary&amp;gt; /// 供應咖啡 /// &amp;lt;/summary&amp;gt; public override void Serve() { Console.</description></item><item><title>外觀模式：化繁為簡</title><link>/ChiYu-Blob/posts/%E5%A4%96%E8%A7%80%E6%A8%A1%E5%BC%8F%E5%8C%96%E7%B9%81%E7%82%BA%E7%B0%A1/</link><pubDate>Thu, 12 Jun 2025 18:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E5%A4%96%E8%A7%80%E6%A8%A1%E5%BC%8F%E5%8C%96%E7%B9%81%E7%82%BA%E7%B0%A1/</guid><description>哈囉大家～今天的主題非常實用，那就是「外觀模式（Facade）」！這個模式可以有效地讓複雜的系統變得簡單又好用，就像你按下遙控器的開機鍵，電視就會自動開啟、調整音量，甚至切換到你最愛的頻道一樣。
🌟 外觀模式是什麼？ 外觀模式其實就是為複雜系統提供一個簡單的介面，讓使用者不需要了解複雜的細節，就能輕鬆操作系統內部的功能。
例如，去電影院看電影時，你只需要買一張電影票，電影院就幫你搞定座位安排、播放電影、空調系統等等，這就是外觀模式的概念啦！
🤔 什麼情況適合用外觀模式？ 當你遇到以下的狀況時，特別適合使用外觀模式：
系統變得複雜，使用者需要了解太多細節。 想提供一個簡單的介面給使用者，隱藏複雜的內部運作細節。 想降低系統的耦合性，提高易用性與可維護性。 🎬 C# 外觀模式範例 這次我們就用「電影院系統」的例子，來看看外觀模式怎麼運作吧！
🎥 複雜的子系統類別 using System; /// &amp;lt;summary&amp;gt; /// 投影機 /// &amp;lt;/summary&amp;gt; public class Projector { /// &amp;lt;summary&amp;gt; /// 開啟投影機 /// &amp;lt;/summary&amp;gt; public void TurnOn() =&amp;gt; Console.WriteLine(&amp;#34;投影機已開啟。&amp;#34;); /// &amp;lt;summary&amp;gt; /// 關閉投影機 /// &amp;lt;/summary&amp;gt; public void TurnOff() =&amp;gt; Console.WriteLine(&amp;#34;投影機已關閉。&amp;#34;); } /// &amp;lt;summary&amp;gt; /// 音響系統 /// &amp;lt;/summary&amp;gt; public class AudioSystem { /// &amp;lt;summary&amp;gt; /// 開啟音響系統 /// &amp;lt;/summary&amp;gt; public void TurnOn() =&amp;gt; Console.</description></item><item><title>享元模式：節省記憶體的利器</title><link>/ChiYu-Blob/posts/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E7%AF%80%E7%9C%81%E8%A8%98%E6%86%B6%E9%AB%94%E7%9A%84%E5%88%A9%E5%99%A8/</link><pubDate>Thu, 12 Jun 2025 19:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E7%AF%80%E7%9C%81%E8%A8%98%E6%86%B6%E9%AB%94%E7%9A%84%E5%88%A9%E5%99%A8/</guid><description>哈囉各位朋友，今天我們要聊的是一個特別省資源的設計模式：享元模式（Flyweight）。
🌟 享元模式是什麼？ 享元模式是一種可以有效節省記憶體的設計模式，透過共享相同或相似的物件，避免建立過多重複的小型物件。
舉個例子：假設你在做簡報，需要大量使用同一張圖片，與其在每張投影片裡都重新複製一次圖片，不如只保留一張原始圖片，其他投影片只需要參考這張圖片就好。這樣一來可以降低檔案大小，節省記憶體。
🤔 什麼情境適合使用享元模式？ 系統中存在大量重複的物件。 物件的建立與銷毀成本過高，並且這些物件大多類似。 想節省記憶體資源，提升系統效能。 🌳 C# 享元模式範例 以下以遊戲中常見的「樹木」為例，示範享元模式的實作方式。
🌳 享元介面與實作 using System; /// &amp;lt;summary&amp;gt; /// 樹木介面 /// &amp;lt;/summary&amp;gt; public interface ITree { /// &amp;lt;summary&amp;gt; /// 顯示樹木 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;x&amp;#34;&amp;gt;位置 X 座標&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;y&amp;#34;&amp;gt;位置 Y 座標&amp;lt;/param&amp;gt; void Display(int x, int y); } /// &amp;lt;summary&amp;gt; /// 具體享元類別 /// &amp;lt;/summary&amp;gt; public class Tree : ITree { private readonly string _treeType; public Tree(string treeType) { _treeType = treeType; Console.</description></item><item><title>代理模式：控制存取的守門員</title><link>/ChiYu-Blob/posts/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E6%8E%A7%E5%88%B6%E5%AD%98%E5%8F%96%E7%9A%84%E5%AE%88%E9%96%80%E5%93%A1/</link><pubDate>Thu, 12 Jun 2025 20:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E6%8E%A7%E5%88%B6%E5%AD%98%E5%8F%96%E7%9A%84%E5%AE%88%E9%96%80%E5%93%A1/</guid><description>哈囉各位朋友～今天我們要介紹的是很實用且日常生活也常碰到的 代理模式（Proxy）！
🌟 代理模式是什麼？ 代理模式提供一個中介物件來控制對某個目標物件的存取，藉此加入額外行為或保護原本的物件。 就像看醫生必須先掛號一樣，櫃檯人員就是代理，他負責管理你與醫生之間的互動。
🤔 什麼情況適合用代理模式？ 需要控制物件的存取權限，例如安全管理或權限限制。 想延遲建立昂貴的物件實例，例如檔案或資料庫連線。 想在不影響原有物件的情況下，加入額外行為（例如日誌紀錄）。 🛂 C# 代理模式範例 這裡以「檔案存取權限控制」為例，示範代理模式的實作。
📂 定義共通介面 /// &amp;lt;summary&amp;gt; /// 檔案介面 /// &amp;lt;/summary&amp;gt; public interface IFile { /// &amp;lt;summary&amp;gt; /// 顯示檔案內容 /// &amp;lt;/summary&amp;gt; void Display(); } 📄 建立具體物件類別 using System; /// &amp;lt;summary&amp;gt; /// 真實存取檔案的類別 /// &amp;lt;/summary&amp;gt; public class RealFile : IFile { private readonly string _fileName; public RealFile(string fileName) { _fileName = fileName; LoadFromDisk(fileName); } /// &amp;lt;summary&amp;gt; /// 顯示檔案 /// &amp;lt;/summary&amp;gt; public void Display() { Console.</description></item><item><title>責任鏈模式：層層把關的處理機制</title><link>/ChiYu-Blob/posts/%E8%B2%AC%E4%BB%BB%E9%8F%88%E6%A8%A1%E5%BC%8F%E5%B1%A4%E5%B1%A4%E6%8A%8A%E9%97%9C%E7%9A%84%E8%99%95%E7%90%86%E6%A9%9F%E5%88%B6/</link><pubDate>Thu, 12 Jun 2025 21:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E8%B2%AC%E4%BB%BB%E9%8F%88%E6%A8%A1%E5%BC%8F%E5%B1%A4%E5%B1%A4%E6%8A%8A%E9%97%9C%E7%9A%84%E8%99%95%E7%90%86%E6%A9%9F%E5%88%B6/</guid><description>哈囉～又來到了我們設計模式系列啦，今天要介紹的是一個非常靈活又好用的模式：責任鏈模式（Chain of Responsibility）。
🌟 責任鏈模式是什麼？ 責任鏈模式是一種將請求逐一傳遞，直到找到合適的處理者來處理的設計模式。就像公司報銷流程，先交給直屬主管簽核，如果權限不足就往上一層，直到有權限的人批准為止。
透過這個模式，每個處理者只專注自己的職責，無法處理的部分就交給下一個處理者，既清楚又明確。
🤔 什麼情況適合使用責任鏈模式？ 多個物件都能處理同一個請求，但條件或處理範圍不同。 責任層級可能會更動，希望降低請求者與處理者的耦合度。 想讓系統更彈性，可依需求增減處理節點。 📝 C# 責任鏈模式範例 以下以「公司費用審核」為例，示範責任鏈模式的實作。
💼 建立抽象處理者（Handler） using System; /// &amp;lt;summary&amp;gt; /// 抽象處理者 /// &amp;lt;/summary&amp;gt; public abstract class Approver { /// &amp;lt;summary&amp;gt; /// 下一位處理者 /// &amp;lt;/summary&amp;gt; protected Approver _nextApprover; /// &amp;lt;summary&amp;gt; /// 設定下一位處理者 /// &amp;lt;/summary&amp;gt; public void SetNext(Approver approver) { _nextApprover = approver; } /// &amp;lt;summary&amp;gt; /// 處理請求 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;amount&amp;#34;&amp;gt;請求金額&amp;lt;/param&amp;gt; public abstract void HandleRequest(decimal amount); } 👩‍💻 建立具體處理者（主管、經理、總經理） using System; /// &amp;lt;summary&amp;gt; /// 主管 /// &amp;lt;/summary&amp;gt; public class Supervisor : Approver { public override void HandleRequest(decimal amount) { if (amount &amp;lt;= 1000) { Console.</description></item><item><title>命令模式：靈活封裝的請求指令</title><link>/ChiYu-Blob/posts/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E9%9D%88%E6%B4%BB%E5%B0%81%E8%A3%9D%E7%9A%84%E8%AB%8B%E6%B1%82%E6%8C%87%E4%BB%A4/</link><pubDate>Thu, 12 Jun 2025 22:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E9%9D%88%E6%B4%BB%E5%B0%81%E8%A3%9D%E7%9A%84%E8%AB%8B%E6%B1%82%E6%8C%87%E4%BB%A4/</guid><description>哈囉大家，今天我們來聊聊 命令模式（Command），這個設計模式能幫助你將請求封裝成物件，讓你可以輕鬆地操作、延遲或撤銷命令。
🌟 命令模式是什麼？ 命令模式是一種將「動作」封裝成獨立物件的設計模式。這樣做的好處是，你可以隨時決定何時執行這個動作，甚至是取消它。
舉個例子來說，就像餐廳點餐時，你的每一份點餐單都是一個命令，廚房按照你的點餐單來做餐點，服務生只需將點餐單交給廚房即可，不需要知道廚房如何烹飪食物。
🤔 什麼情況適合使用命令模式？ 想要將執行動作的物件與觸發動作的物件解耦。 需要將命令排程、延遲或撤銷。 想記錄請求歷史，以支援撤銷操作。 🍔 C# 命令模式範例 這次我們以餐廳點餐的例子來實作命令模式。
📝 定義命令介面 /// &amp;lt;summary&amp;gt; /// 命令介面 /// &amp;lt;/summary&amp;gt; public interface ICommand { /// &amp;lt;summary&amp;gt; /// 執行命令 /// &amp;lt;/summary&amp;gt; void Execute(); } 🍲 建立具體命令 using System; /// &amp;lt;summary&amp;gt; /// 點餐命令 /// &amp;lt;/summary&amp;gt; public class OrderCommand : ICommand { private readonly Kitchen _kitchen; private readonly string _dish; public OrderCommand(Kitchen kitchen, string dish) { _kitchen = kitchen; _dish = dish; } /// &amp;lt;summary&amp;gt; /// 執行點餐動作 /// &amp;lt;/summary&amp;gt; public void Execute() { _kitchen.</description></item><item><title>解譯器模式：讓程式聽懂你的指令</title><link>/ChiYu-Blob/posts/%E8%A7%A3%E8%AD%AF%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%AE%93%E7%A8%8B%E5%BC%8F%E8%81%BD%E6%87%82%E4%BD%A0%E7%9A%84%E6%8C%87%E4%BB%A4/</link><pubDate>Thu, 12 Jun 2025 23:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E8%A7%A3%E8%AD%AF%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%AE%93%E7%A8%8B%E5%BC%8F%E8%81%BD%E6%87%82%E4%BD%A0%E7%9A%84%E6%8C%87%E4%BB%A4/</guid><description>哈囉各位朋友，今天我們來認識一個有趣又實用的設計模式：解譯器模式（Interpreter），並以好玩的「文字冒險遊戲」為例，輕鬆學會如何讓你的程式讀懂自訂語言或指令。
🌟 解譯器模式是什麼？ 解譯器模式是一種用來解析特定語言或表達式的設計模式，它能夠讓你的程式懂得使用者輸入的特定語法或指令，並做出相應的回應或行動。
就像在玩文字冒險遊戲時，你輸入「攻擊 巨龍 使用 火球」，遊戲就能理解你的指令，並做出相應的動作一樣。
🤔 什麼情況適合使用解譯器模式？ 需要處理使用者輸入的特殊指令或語法。 想設計一個易於擴充與修改的指令解析系統。 系統需要理解並執行使用者自定義的操作。 🎮 C# 解譯器模式範例（文字冒險遊戲） 以下以文字冒險遊戲為例，示範如何透過解譯器模式解析玩家輸入的指令。
🎲 定義抽象指令介面 /// &amp;lt;summary&amp;gt; /// 遊戲指令介面 /// &amp;lt;/summary&amp;gt; public interface IGameCommand { /// &amp;lt;summary&amp;gt; /// 執行指令 /// &amp;lt;/summary&amp;gt; void Execute(); } ⚔️ 建立具體指令 using System; /// &amp;lt;summary&amp;gt; /// 攻擊指令 /// &amp;lt;/summary&amp;gt; public class AttackCommand : IGameCommand { private readonly string _target; // 攻擊目標 private readonly string _weapon; // 使用武器 public AttackCommand(string target, string weapon) { _target = target; _weapon = weapon; } /// &amp;lt;inheritdoc /&amp;gt; public void Execute() { Console.</description></item><item><title>迭代器模式：輕鬆遍歷集合元素</title><link>/ChiYu-Blob/posts/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%BC%95%E9%AC%86%E9%81%8D%E6%AD%B7%E9%9B%86%E5%90%88%E5%85%83%E7%B4%A0/</link><pubDate>Fri, 13 Jun 2025 00:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%BC%95%E9%AC%86%E9%81%8D%E6%AD%B7%E9%9B%86%E5%90%88%E5%85%83%E7%B4%A0/</guid><description>哈囉朋友們～今天來聊聊迭代器模式（Iterator），這個設計模式能幫你輕鬆管理和操作集合中的元素。
🌟 什麼是迭代器模式？ 迭代器模式讓你可以逐一瀏覽集合中的每個元素，而不需知道集合的內部結構。 就像你用音樂 App 播放音樂時，播放清單會自動幫你一首一首播放下一首歌曲，你不需要知道歌曲是怎麼儲存的。這就是迭代器模式的精髓啦！
🤔 什麼情況適合使用迭代器模式？ 以下情況很適合使用迭代器模式：
當你需要循序瀏覽集合中的元素，但不想暴露集合的內部結構。 你希望使用相同的方式來遍歷不同類型的集合。 想要讓集合的操作更加直觀與易用。 🎧 C# 迭代器模式範例：音樂播放清單 我們以「音樂播放清單」為範例，讓你輕鬆理解迭代器模式的應用。
🎵 定義抽象迭代器介面 /// &amp;lt;summary&amp;gt; /// 迭代器介面 /// &amp;lt;/summary&amp;gt; public interface IIterator { /// &amp;lt;summary&amp;gt; /// 是否還有下一首 /// &amp;lt;/summary&amp;gt; bool HasNext(); /// &amp;lt;summary&amp;gt; /// 取得下一首歌曲 /// &amp;lt;/summary&amp;gt; string Next(); } 🎶 建立集合類別（播放清單） using System.Collections.Generic; /// &amp;lt;summary&amp;gt; /// 音樂播放清單 /// &amp;lt;/summary&amp;gt; public class Playlist { private readonly List&amp;lt;string&amp;gt; _songs = new(); // 儲存歌曲 /// &amp;lt;summary&amp;gt; /// 歌曲清單(唯讀) /// &amp;lt;/summary&amp;gt; public IReadOnlyList&amp;lt;string&amp;gt; Songs =&amp;gt; _songs; /// &amp;lt;summary&amp;gt; /// 新增歌曲 /// &amp;lt;/summary&amp;gt; public void AddSong(string song) { _songs.</description></item><item><title>中介者模式：管理複雜溝通的好幫手</title><link>/ChiYu-Blob/posts/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%E7%AE%A1%E7%90%86%E8%A4%87%E9%9B%9C%E6%BA%9D%E9%80%9A%E7%9A%84%E5%A5%BD%E5%B9%AB%E6%89%8B/</link><pubDate>Fri, 13 Jun 2025 01:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%E7%AE%A1%E7%90%86%E8%A4%87%E9%9B%9C%E6%BA%9D%E9%80%9A%E7%9A%84%E5%A5%BD%E5%B9%AB%E6%89%8B/</guid><description>哈囉朋友們～今天要聊的設計模式是中介者模式（Mediator），這個模式能讓你的程式輕鬆管理物件之間複雜的溝通關係。
🌟 中介者模式是什麼？ 中介者模式透過一個中介者物件來協調其他物件之間的互動，避免物件間的直接聯繫導致的混亂。
想像你使用聊天室時，你並不直接跟每個使用者對話，而是透過聊天室作為中介，幫你發送訊息給其他使用者，這樣每個人只要與聊天室溝通即可，簡單明瞭。
🤔 什麼情況適合使用中介者模式？ 以下情況適合使用中介者模式：
當系統內有許多物件需要彼此溝通，關係變得複雜難以管理。 想降低物件間的耦合度，讓系統容易維護與擴充。 想集中管理物件之間的溝通邏輯。 💬 C# 中介者模式範例：聊天室應用程式 我們透過「聊天室」範例來實際展示中介者模式。
💻 定義中介者介面 /// &amp;lt;summary&amp;gt; /// 中介者介面 /// &amp;lt;/summary&amp;gt; public interface IChatMediator { /// &amp;lt;summary&amp;gt; /// 傳送訊息給其他使用者 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;message&amp;#34;&amp;gt;訊息內容&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;user&amp;#34;&amp;gt;發送者&amp;lt;/param&amp;gt; void SendMessage(string message, User user); /// &amp;lt;summary&amp;gt; /// 註冊使用者到聊天室 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;user&amp;#34;&amp;gt;新使用者&amp;lt;/param&amp;gt; void RegisterUser(User user); } 👥 建立具體中介者（聊天室） using System; using System.Collections.Generic; /// &amp;lt;summary&amp;gt; /// 聊天室中介者，負責轉發訊息 /// &amp;lt;/summary&amp;gt; public class ChatMediator : IChatMediator { private readonly List&amp;lt;User&amp;gt; _users = new(); // 聊天室中的使用者名單 /// &amp;lt;inheritdoc /&amp;gt; public void RegisterUser(User user) { _users.</description></item><item><title>備忘錄模式：保存與恢復物件狀態</title><link>/ChiYu-Blob/posts/%E5%82%99%E5%BF%98%E9%8C%84%E6%A8%A1%E5%BC%8F%E4%BF%9D%E5%AD%98%E8%88%87%E6%81%A2%E5%BE%A9%E7%89%A9%E4%BB%B6%E7%8B%80%E6%85%8B/</link><pubDate>Fri, 13 Jun 2025 02:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E5%82%99%E5%BF%98%E9%8C%84%E6%A8%A1%E5%BC%8F%E4%BF%9D%E5%AD%98%E8%88%87%E6%81%A2%E5%BE%A9%E7%89%A9%E4%BB%B6%E7%8B%80%E6%85%8B/</guid><description>哈囉朋友們！今天我們要介紹的是一個超實用的設計模式：備忘錄模式（Memento），透過它，我們可以輕鬆儲存並回復物件的狀態！
🌟 備忘錄模式是什麼？ 備忘錄模式允許你捕捉一個物件的內部狀態，並且在未來需要時，能夠將物件回復到原先的狀態。
就像玩遊戲時的「存檔」和「讀取進度」功能一樣，當你不小心走錯路或失敗時，可以輕鬆回到之前的狀態重新來過。
🤔 什麼情況適合使用備忘錄模式？ 當你有以下情境時，很適合使用備忘錄模式：
需要提供撤銷（undo）或回復（redo）操作。 物件狀態可能頻繁改變，且希望能隨時回到某個特定的狀態。 不想暴露物件內部狀態的細節給外部使用者。 🎮 C# 備忘錄模式範例：遊戲存檔系統 我們透過「遊戲角色存檔」來說明備忘錄模式的應用。
🎲 建立備忘錄（Memento） /// &amp;lt;summary&amp;gt; /// 遊戲狀態備忘錄 /// &amp;lt;/summary&amp;gt; public class GameMemento { /// &amp;lt;summary&amp;gt; /// 等級 /// &amp;lt;/summary&amp;gt; public int Level { get; } /// &amp;lt;summary&amp;gt; /// 生命值 /// &amp;lt;/summary&amp;gt; public int Health { get; } public GameMemento(int level, int health) { Level = level; Health = health; } } 🧙 遊戲角色（Originator） using System; /// &amp;lt;summary&amp;gt; /// 遊戲角色 /// &amp;lt;/summary&amp;gt; public class GameCharacter { /// &amp;lt;summary&amp;gt; /// 等級 /// &amp;lt;/summary&amp;gt; public int Level { get; set; } /// &amp;lt;summary&amp;gt; /// 生命值 /// &amp;lt;/summary&amp;gt; public int Health { get; set; } /// &amp;lt;summary&amp;gt; /// 顯示目前狀態 /// &amp;lt;/summary&amp;gt; public void DisplayStatus() { Console.</description></item><item><title>觀察者模式：即時通知的好幫手</title><link>/ChiYu-Blob/posts/%E8%A7%80%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%8D%B3%E6%99%82%E9%80%9A%E7%9F%A5%E7%9A%84%E5%A5%BD%E5%B9%AB%E6%89%8B/</link><pubDate>Fri, 13 Jun 2025 03:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E8%A7%80%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%8D%B3%E6%99%82%E9%80%9A%E7%9F%A5%E7%9A%84%E5%A5%BD%E5%B9%AB%E6%89%8B/</guid><description>哈囉朋友們～今天我們要聊的是觀察者模式（Observer），這個模式在現實生活中非常常見，讓我們輕鬆理解並學會如何運用它！
🌟 觀察者模式是什麼？ 觀察者模式定義了物件之間一對多的依賴關係，當一個物件的狀態發生變化時，所有依賴它的物件都能立即收到通知。
就像你在追蹤 YouTuber 的頻道一樣，當他們有新影片上傳，你就會收到通知，立刻去觀看新內容。這個頻道就像被觀察的物件（Subject），而你就像是觀察者（Observer）。
🤔 什麼時候適合使用觀察者模式？ 以下情況很適合使用觀察者模式：
當你想要在物件的狀態改變時，自動通知其他相關物件。 希望實現鬆散耦合，提升系統彈性。 當系統的變更可能會影響多個物件時。 🔔 C# 觀察者模式範例：YouTube 頻道通知系統 這次我們以 YouTube 頻道訂閱通知為例，來實作觀察者模式。
📺 建立主題介面（Subject） using System.Collections.Generic; /// &amp;lt;summary&amp;gt; /// 主題介面，負責管理訂閱者 /// &amp;lt;/summary&amp;gt; public interface IChannel { /// &amp;lt;summary&amp;gt; /// 訂閱頻道 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;subscriber&amp;#34;&amp;gt;訂閱者&amp;lt;/param&amp;gt; void Subscribe(ISubscriber subscriber); /// &amp;lt;summary&amp;gt; /// 取消訂閱 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;subscriber&amp;#34;&amp;gt;訂閱者&amp;lt;/param&amp;gt; void Unsubscribe(ISubscriber subscriber); /// &amp;lt;summary&amp;gt; /// 通知所有訂閱者 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;videoTitle&amp;#34;&amp;gt;影片標題&amp;lt;/param&amp;gt; void NotifySubscribers(string videoTitle); } 🎥 具體主題類別（頻道） using System; using System.</description></item><item><title>狀態模式：依狀態改變行為的祕訣</title><link>/ChiYu-Blob/posts/%E7%8B%80%E6%85%8B%E6%A8%A1%E5%BC%8F%E4%BE%9D%E7%8B%80%E6%85%8B%E6%94%B9%E8%AE%8A%E8%A1%8C%E7%82%BA%E7%9A%84%E7%A5%95%E8%A8%A3/</link><pubDate>Fri, 13 Jun 2025 04:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E7%8B%80%E6%85%8B%E6%A8%A1%E5%BC%8F%E4%BE%9D%E7%8B%80%E6%85%8B%E6%94%B9%E8%AE%8A%E8%A1%8C%E7%82%BA%E7%9A%84%E7%A5%95%E8%A8%A3/</guid><description>哈囉朋友們～今天我們要聊的是非常實用且有趣的狀態模式（State），這個模式讓你的物件能夠根據內部狀態的變化而自動改變行為。
🌟 狀態模式是什麼？ 狀態模式允許一個物件在內部狀態改變時改變它的行為，就像換了一個角色一樣。
舉個實際例子，就像是手機的鈴聲狀態，手機在「靜音」模式時，不會響鈴；切換到「響鈴」模式後，就會有聲音通知你。這就是狀態模式的基本概念，透過改變狀態讓物件呈現不同的行為。
🤔 什麼時候適合使用狀態模式？ 以下情況很適合使用狀態模式：
物件的行為會根據內部狀態不同而有所改變。 當有大量條件判斷，且這些條件判斷取決於物件的狀態時。 希望避免使用大量的條件語句（if-else或switch），讓程式更清晰、更易於維護。 📱 C# 狀態模式範例：手機鈴聲模式 我們以手機鈴聲模式為範例來示範狀態模式。
🔕 定義狀態介面 /// &amp;lt;summary&amp;gt; /// 狀態介面 /// &amp;lt;/summary&amp;gt; public interface IMobileState { /// &amp;lt;summary&amp;gt; /// 依目前狀態執行提醒 /// &amp;lt;/summary&amp;gt; void Alert(); } 📳 建立具體狀態類別 using System; /// &amp;lt;summary&amp;gt; /// 響鈴模式 /// &amp;lt;/summary&amp;gt; public class RingingState : IMobileState { /// &amp;lt;inheritdoc /&amp;gt; public void Alert() { Console.WriteLine(&amp;#34;手機正在響鈴...&amp;#34;); } } /// &amp;lt;summary&amp;gt; /// 靜音模式 /// &amp;lt;/summary&amp;gt; public class SilentState : IMobileState { /// &amp;lt;inheritdoc /&amp;gt; public void Alert() { Console.</description></item><item><title>策略模式：靈活切換行為的好幫手</title><link>/ChiYu-Blob/posts/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E9%9D%88%E6%B4%BB%E5%88%87%E6%8F%9B%E8%A1%8C%E7%82%BA%E7%9A%84%E5%A5%BD%E5%B9%AB%E6%89%8B/</link><pubDate>Fri, 13 Jun 2025 05:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E9%9D%88%E6%B4%BB%E5%88%87%E6%8F%9B%E8%A1%8C%E7%82%BA%E7%9A%84%E5%A5%BD%E5%B9%AB%E6%89%8B/</guid><description>哈囉朋友們～今天我們要介紹的設計模式是非常靈活好用的策略模式（Strategy），透過它，你可以輕鬆替換不同的行為，讓你的程式更有彈性！
🌟 策略模式是什麼？ 策略模式允許你定義一系列的演算法，並讓這些演算法可以互相替換，且獨立於使用它們的客戶端。
想像一下，你去旅行時可以選擇不同的交通方式，比如搭飛機、搭高鐵或開車。你根據不同的需求（時間、成本、舒適度）選擇不同的策略，這就是策略模式的核心概念！
🤔 什麼情況適合使用策略模式？ 以下情況很適合使用策略模式：
需要動態地切換不同的演算法或行為。 想避免使用大量的條件判斷語句（if-else 或 switch）。 希望使系統容易擴充，能輕鬆增加新的演算法或行為。 🚗 C# 策略模式範例：旅遊交通工具選擇 這次我們以旅遊時選擇交通工具作為範例。
🚅 定義策略介面 /// &amp;lt;summary&amp;gt; /// 交通策略介面 /// &amp;lt;/summary&amp;gt; public interface ITravelStrategy { /// &amp;lt;summary&amp;gt; /// 前往指定目的地 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;destination&amp;#34;&amp;gt;目的地&amp;lt;/param&amp;gt; void Travel(string destination); } ✈️ 建立具體策略類別 using System; /// &amp;lt;summary&amp;gt; /// 飛機策略 /// &amp;lt;/summary&amp;gt; public class PlaneStrategy : ITravelStrategy { public void Travel(string destination) { Console.WriteLine($&amp;#34;搭飛機前往 {destination}&amp;#34;); } } /// &amp;lt;summary&amp;gt; /// 高鐵策略 /// &amp;lt;/summary&amp;gt; public class HighSpeedRailStrategy : ITravelStrategy { public void Travel(string destination) { Console.</description></item><item><title>模板方法模式：固定流程靈活實作</title><link>/ChiYu-Blob/posts/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%9B%BA%E5%AE%9A%E6%B5%81%E7%A8%8B%E9%9D%88%E6%B4%BB%E5%AF%A6%E4%BD%9C/</link><pubDate>Fri, 13 Jun 2025 06:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%9B%BA%E5%AE%9A%E6%B5%81%E7%A8%8B%E9%9D%88%E6%B4%BB%E5%AF%A6%E4%BD%9C/</guid><description>哈囉朋友們～今天我們要介紹的是非常實用且常見的模板方法模式（Template Method），透過它你可以固定一系列的步驟，讓子類別靈活地去實現細節。
🌟 模板方法模式是什麼？ 模板方法模式定義了一個演算法的骨架，並將一些步驟延遲到子類別去實現。這樣的設計可以確保演算法的結構保持一致，但又能靈活地調整細節。
例如，你在製作各種口味的披薩時，無論是海鮮披薩還是夏威夷披薩，都有一個基本的製作步驟（揉麵團、加醬料、放餡料、烤披薩）。模板方法模式就是把這個固定步驟封裝起來，讓子類別專注於實現每個細節。
🤔 什麼時候適合使用模板方法模式？ 以下情況很適合使用模板方法模式：
當你有一系列步驟，但每個步驟的具體實現可能會有所不同。 想確保演算法的結構不被子類別改變，保證流程的統一性。 希望提供一個明確的框架，讓開發者能快速實現不同的具體步驟。 🍕 C# 模板方法模式範例：披薩製作流程 這次我們以製作披薩的流程作為範例。
🍅 建立抽象類別 using System; /// &amp;lt;summary&amp;gt; /// 披薩製作抽象類別 /// &amp;lt;/summary&amp;gt; public abstract class PizzaMaker { /// &amp;lt;summary&amp;gt; /// 製作披薩的流程 /// &amp;lt;/summary&amp;gt; public void MakePizza() { PrepareDough(); AddSauce(); AddToppings(); BakePizza(); } /// &amp;lt;summary&amp;gt; /// 準備麵團 /// &amp;lt;/summary&amp;gt; protected void PrepareDough() { Console.WriteLine(&amp;#34;揉製麵團...&amp;#34;); } /// &amp;lt;summary&amp;gt; /// 加入醬料 /// &amp;lt;/summary&amp;gt; protected void AddSauce() { Console.WriteLine(&amp;#34;加入醬料...&amp;#34;); } /// &amp;lt;summary&amp;gt; /// 加入配料，由子類別實作 /// &amp;lt;/summary&amp;gt; protected abstract void AddToppings(); /// &amp;lt;summary&amp;gt; /// 烘烤披薩 /// &amp;lt;/summary&amp;gt; protected void BakePizza() { Console.</description></item><item><title>訪問者模式：新增功能不動既有架構</title><link>/ChiYu-Blob/posts/%E8%A8%AA%E5%95%8F%E8%80%85%E6%A8%A1%E5%BC%8F%E6%96%B0%E5%A2%9E%E5%8A%9F%E8%83%BD%E4%B8%8D%E5%8B%95%E6%97%A2%E6%9C%89%E6%9E%B6%E6%A7%8B/</link><pubDate>Fri, 13 Jun 2025 07:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E8%A8%AA%E5%95%8F%E8%80%85%E6%A8%A1%E5%BC%8F%E6%96%B0%E5%A2%9E%E5%8A%9F%E8%83%BD%E4%B8%8D%E5%8B%95%E6%97%A2%E6%9C%89%E6%9E%B6%E6%A7%8B/</guid><description>哈囉朋友們～今天要介紹的是比較特殊但十分強大的訪問者模式（Visitor），透過這個模式，你可以在不修改物件結構的情況下輕鬆新增功能！
🌟 訪問者模式是什麼？ 訪問者模式允許你在不改變現有類別結構的情況下，為類別增加新的操作。
舉個例子，就像遊樂園的各種設施，每個訪客來到遊樂園會玩不同的設施。設施本身不會改變，但每位訪客的行為和感受可能不同，訪客們就是訪問者（Visitor），設施則是被訪問的元素（Element）。
🤔 什麼情況適合使用訪問者模式？ 以下情況很適合使用訪問者模式：
當你需要對一個物件結構新增許多不同且不相關的操作。 希望在不修改現有結構的情況下，能輕鬆增加新功能。 當物件結構相對穩定，但操作或功能可能經常變動時。 🎢 C# 訪問者模式範例：遊樂園設施與訪客 這次我們以遊樂園的訪客與設施為例。
🎠 定義元素介面（設施） /// &amp;lt;summary&amp;gt; /// 設施介面 /// &amp;lt;/summary&amp;gt; public interface IAmusementFacility { /// &amp;lt;summary&amp;gt; /// 接受訪問者 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;visitor&amp;#34;&amp;gt;訪問者&amp;lt;/param&amp;gt; void Accept(IVisitor visitor); } 🎡 具體設施類別 /// &amp;lt;summary&amp;gt; /// 雲霄飛車 /// &amp;lt;/summary&amp;gt; public class RollerCoaster : IAmusementFacility { public void Accept(IVisitor visitor) { visitor.Visit(this); } } /// &amp;lt;summary&amp;gt; /// 摩天輪 /// &amp;lt;/summary&amp;gt; public class FerrisWheel : IAmusementFacility { public void Accept(IVisitor visitor) { visitor.</description></item><item><title>我是如何使用 AI (Codex) 打造這個 Hugo 部落格的</title><link>/ChiYu-Blob/posts/%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-ai-codex-%E6%89%93%E9%80%A0%E9%80%99%E5%80%8B-hugo-%E9%83%A8%E8%90%BD%E6%A0%BC%E7%9A%84/</link><pubDate>Sun, 08 Jun 2025 10:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-ai-codex-%E6%89%93%E9%80%A0%E9%80%99%E5%80%8B-hugo-%E9%83%A8%E8%90%BD%E6%A0%BC%E7%9A%84/</guid><description>在上一篇文章 《第一次認識 Codex：讓 AI 幫你寫程式不是夢！》 中，我介紹了 Codex 這個強大的 AI 程式助理。而今天，我想分享一個更具體的實戰經驗：我是如何利用 Codex 來開發你現在正在看的這個部落格。
這個網站是使用 Hugo 靜態網站產生器搭建的，並搭配 Tailwind CSS 進行樣式設計。從前端的 JavaScript 互動功能，到後端的 GitHub Actions 自動化部署，許多環節都有 AI 的深度參與。接下來，我會分享幾個關鍵功能的開發過程，以及我是如何「詠唱」我的需求，讓 AI 幫我完成任務的。
1. 前端互動功能：讓網站活起來的 JavaScript 靜態網站很容易變得單調，但透過 JavaScript，我們可以加入許多動態的現代化功能。這也是我認為 Codex 最能大顯身手的地方。
深色/淺色主題切換 這是現代網站的標配功能。我需要一個按鈕，它能：
切換 &amp;lt;html&amp;gt; 標籤上的 data-theme 屬性 (在 light 與 dark 之間)。 將用戶的偏好儲存在瀏覽器的 localStorage 中，以便下次造訪時維持設定。 當主題變更時，通知 Giscus 留言區一起變更主題。 我的提問大致如下：
「幫我寫一段 JavaScript。當使用者點擊 ID 為 theme-toggle 的按鈕時，在 &amp;lt;html&amp;gt; 元素上切換 data-theme 屬性，值為 &amp;rsquo;light&amp;rsquo; 或 &amp;lsquo;dark&amp;rsquo;。將這個設定存到 localStorage。頁面載入時，優先從 localStorage 讀取設定。最後，當主題改變時，發送一個 postMessage 給 class 為 giscus-frame 的 iframe，內容為 { giscus: { setTheme: newTheme } }。」</description></item><item><title>第一次認識 Codex：讓 AI 幫你寫程式不是夢！</title><link>/ChiYu-Blob/posts/%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%AA%8D%E8%AD%98-codex%E8%AE%93-ai-%E5%B9%AB%E4%BD%A0%E5%AF%AB%E7%A8%8B%E5%BC%8F%E4%B8%8D%E6%98%AF%E5%A4%A2/</link><pubDate>Thu, 05 Jun 2025 10:00:00 +0800</pubDate><guid>/ChiYu-Blob/posts/%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%AA%8D%E8%AD%98-codex%E8%AE%93-ai-%E5%B9%AB%E4%BD%A0%E5%AF%AB%E7%A8%8B%E5%BC%8F%E4%B8%8D%E6%98%AF%E5%A4%A2/</guid><description>最近如果你有在關注 AI 或寫程式的領域，可能會聽過一個名字——Codex。它是 OpenAI 推出的一個超厲害工具，簡單來說，就是一個會寫程式的 AI。今天這篇文章就想用比較輕鬆的方式，來帶大家初步認識一下 Codex 是什麼、可以拿來做什麼、還有怎麼開始玩看看。
Codex 是什麼？跟 ChatGPT 有關嗎？ 沒錯，Codex 是 OpenAI（就是做 ChatGPT 那家公司）開發的模型之一。它其實就是 ChatGPT 的「懂程式」版本。
你可以把它想成一個超強的助理工程師，你對它講人話，它就能幫你寫出程式碼。不管你是要寫一個 Python 函式，還是建一個簡單的網頁 API，Codex 都能幫你快速搞定，甚至連註解都幫你寫好。
Codex 可以幫你做什麼？ 它的功能說起來還真不少，這邊列幾個我覺得超實用的：
自然語言變程式碼：你只要打「幫我寫一個排序的函式」，Codex 馬上就可以用 Python 幫你寫出來。 支援多種語言：Python、JavaScript、C#、Go、Ruby……通通支援，開什麼語言的專案都能用。 幫忙除錯：看不懂 error message？丟給 Codex，讓它幫你分析。 寫測試、補註解：這些瑣碎事 Codex 做起來超快，超方便。 誰適合用 Codex？ 老實說，不管你是剛入門的新手，還是忙到炸的資深工程師，Codex 都有它的價值：
對新手來說，它就像一個 24 小時在線的老師，問什麼都不會兇你。 對老手來說，它超像一個效率助手，幫你處理一堆重複或機械性的事，省下超多時間。 要怎麼開始用？ 目前 Codex 主要是整合在 ChatGPT 專業版（Pro）裡，直接在 ChatGPT 裡輸入程式問題就可以用了。
如果你比較偏好本地開發環境，也可以試試看一些支援 Codex 的 IDE 外掛，比如 Visual Studio Code，現在已經有支援類似 Copilot 的功能。
小結一下 Codex 是一個能聽懂你說話、然後幫你寫程式的 AI，對很多人來說，它可以加速開發、降低學習門檻、甚至讓寫程式變得更輕鬆有趣。
如果你還沒試過，不妨開個 ChatGPT Pro 試試，玩玩看 Codex 的威力。這篇文章只是開個頭，之後我也會陸續寫些更進階的使用心得與實際應用分享，敬請期待！</description></item><item><title>關於</title><link>/ChiYu-Blob/about/</link><pubDate>Sat, 29 Nov 1997 00:00:00 +0000</pubDate><guid>/ChiYu-Blob/about/</guid><description>我是 ChiYu ~ 也可以叫我Eric。 一名軟體工程師。 擅長C# .Net 開發。</description></item></channel></rss>